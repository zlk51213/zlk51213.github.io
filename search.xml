<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统</title>
      <link href="/2024/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/10/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>操作系统</p><h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="操作系统的概念"><a href="#操作系统的概念" class="headerlink" title="操作系统的概念"></a>操作系统的概念</h3><p>操作系统（Operating System，OS）是管理计算机硬件和软件资源的计算机程序，是计算机系统的核心。</p><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ol><li>方便性</li><li>有效性</li><li>可扩展性</li><li>开放性</li></ol><h3 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ol><li>进程管理：操作系统负责管理计算机系统的进程，包括进程的创建、调度、同步、通信和终止等。</li><li>内存管理：操作系统负责管理计算机系统的内存，包括内存的分配、回收、保护和共享等。</li><li>文件管理：操作系统负责管理计算机系统的文件，包括文件的创建、删除、读写、保护和共享等。</li><li>设备管理：操作系统负责管理计算机系统的设备，包括设备的分配、控制和通信等。</li><li>用户接口：操作系统负责提供用户接口，包括命令行接口和图形用户接口等，以便用户与计算机系统进行交互。</li></ol><h3 id="操作系统的历史"><a href="#操作系统的历史" class="headerlink" title="操作系统的历史"></a>操作系统的历史</h3><ol><li>20世纪50年代：操作系统起源于20世纪50年代的大型计算机系统。当时，计算机系统主要用于科学计算和军事应用，操作系统的主要功能是管理计算机的硬件资源。</li><li>20世纪60年代：随着计算机技术的不断发展，操作系统开始应用于个人计算机。当时，操作系统的主要功能是管理计算机的硬件资源，并提供用户接口。</li><li>20世纪70年代：随着个人计算机的普及，操作系统开始出现各种不同的版本。当时，操作系统的主要功能是管理计算机的硬件资源，并提供用户接口。</li><li>20世纪80年代：随着计算机网络的兴起，操作系统开始出现网络操作系统。当时，操作系统的主要功能是管理计算机的硬件资源，并提供用户接口。</li><li>21世纪：随着云计算和大数据技术的兴起，操作系统开始出现分布式操作系统。当时，操作系统的主要功能是管理计算机的硬件资源，并提供用户接口。</li></ol><h3 id="操作系统的组成"><a href="#操作系统的组成" class="headerlink" title="操作系统的组成"></a>操作系统的组成</h3><ol><li>内核：内核是操作系统的核心部分，负责管理计算机系统的硬件资源，包括CPU、内存、磁盘等。内核通常由一组系统调用组成，供应用程序使用。</li><li>系统调用：系统调用是操作系统提供的接口，供应用程序使用。应用程序通过系统调用请求操作系统提供的服务，如创建进程、读写文件等。</li><li>设备驱动程序：设备驱动程序是操作系统的一部分，负责管理计算机系统的硬件设备。设备驱动程序通常由硬件制造商提供。</li><li>文件系统：文件系统是操作系统的一部分，负责管理计算机系统的文件和目录。文件系统通常由一组文件操作组成，供应用程序使用。</li><li>用户界面：用户界面是操作系统的一部分，负责与用户进行交互。用户界面通常由一组图形界面或命令行界面组成。</li></ol><h3 id="操作系统的功能-1"><a href="#操作系统的功能-1" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h3><ol><li>进程管理：操作系统负责管理计算机系统的进程，包括进程的创建、调度、通信和同步。</li><li>内存管理：操作系统负责管理计算机系统的内存，包括内存的分配、回收和保护。</li><li>文件管理：操作系统负责管理计算机系统的文件，包括文件的创建、删除、读写和搜索。</li><li>设备管理：操作系统负责管理计算机系统的硬件设备，包括设备的初始化、配置和操作。</li><li>网络管理：操作系统负责管理计算机系统的网络，包括网络的配置、通信和安全管理。</li><li>用户接口：操作系统负责提供用户接口，包括命令行接口和图形用户接口等，以便用户与计算机系统进行交互。</li></ol><h3 id="操作系统的分类"><a href="#操作系统的分类" class="headerlink" title="操作系统的分类"></a>操作系统的分类</h3><ol><li>实时操作系统：实时操作系统（Real-Time Operating System，RTOS）是一种能够及时响应外部事件并执行相应操作的操作系统。它通常用于需要实时响应的应用场景，如嵌入式系统和实时控制系统。</li><li>批处理操作系统：批处理操作系统（Batch Processing Operating System）是一种能够自动处理一批作业的操作系统。它通常用于大型计算机系统，如大型机。</li><li>分时操作系统：分时操作系统（Time-Sharing Operating System）是一种能够将计算机系统的资源分配给多个用户或进程的操作系统。它通常用于多用户环境，如个人计算机。</li><li>网络操作系统：网络操作系统（Network Operating System，NOS）是一种能够管理计算机网络的操作系统。它通常用于计算机网络，如局域网和广域网。</li><li>分布式操作系统：分布式操作系统（Distributed Operating System，DOS）是一种能够管理多个计算机系统的操作系统。它通常用于分布式计算环境，如云计算和大数据处理。</li></ol><h3 id="操作系统的发展"><a href="#操作系统的发展" class="headerlink" title="操作系统的发展"></a>操作系统的发展</h3><h4 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h4><p>在计算机系统出现之初，没有配置操作系统的计算机系统只能执行单个程序，用户需要手动输入程序指令，效率低下。</p><ol><li>人工操作方式：用户需要手动输入程序指令，然后等待计算机执行，效率低下。</li><li>脱机I&#x2F;O方式：用户将程序和数据准备好后，将程序和数据输入计算机，然后计算机执行程序，执行完毕后，将结果输出到用户指定的设备上。</li></ol><h4 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h4><p>单道批处理系统是一种能够自动处理一批作业的操作系统。它通常用于大型计算机系统，如大型机。</p><ol><li>作业：作业是指用户提交给计算机系统的一组程序和数据，计算机系统需要按照一定的顺序执行这些程序和数据。</li><li>批处理：批处理是指将一组作业按照一定的顺序输入计算机系统，计算机系统按照顺序执行这些作业。</li><li>优点：单道批处理系统可以自动处理一批作业，提高了计算机系统的资源利用率，提高了计算机系统的效率。</li><li>缺点：单道批处理系统只能同时处理一个作业，如果作业执行过程中出现错误，需要重新输入作业，效率较低。</li></ol><h4 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h4><p>多道批处理系统是一种能够同时处理多个作业的操作系统。它通常用于大型计算机系统，如大型机。<br>优缺点：</p><ol><li>优点：多道批处理系统可以同时处理多个作业，提高了计算机系统的资源利用率，提高了计算机系统的效率。</li><li>缺点：多道批处理系统只能按照作业的顺序执行，如果作业执行过程中出现错误，需要重新输入作业，效率较低。</li></ol><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><p>分时操作系统是一种能够将计算机系统的资源分配给多个用户或进程的操作系统。它通常用于多用户环境，如个人计算机。</p><ol><li>分时：分时是指将计算机系统的资源分配给多个用户或进程，每个用户或进程可以按照一定的时隙使用计算机系统的资源。</li><li>优点：分时操作系统可以同时处理多个用户或进程，提高了计算机系统的资源利用率，提高了计算机系统的效率。</li><li>缺点：分时操作系统需要为每个用户或进程分配一定的资源，如果用户或进程需要更多的资源，需要等待其他用户或进程释放资源，效率较低。</li></ol><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><p>实时操作系统是一种能够及时响应外部事件并执行相应操作的操作系统。它通常用于实时控制环境，如工业控制、航空航天和医疗设备。</p><ol><li>实时控制：实时控制是指计算机系统需要及时响应外部事件并执行相应操作，以满足实时控制的要求。</li><li>优点：实时操作系统可以及时响应外部事件并执行相应操作，满足实时控制的要求。</li><li>缺点：实时操作系统需要及时响应外部事件并执行相应操作，如果外部事件频繁发生，计算机系统需要频繁切换任务，效率较低。</li></ol><h4 id="微内核操作系统"><a href="#微内核操作系统" class="headerlink" title="微内核操作系统"></a>微内核操作系统</h4><p>微内核操作系统是一种将操作系统的主要功能模块化，并将一些功能模块移到用户空间的操作系统。它通常用于高性能计算和嵌入式系统。</p><ol><li>微内核：微内核是指操作系统的主要功能模块化，并将一些功能模块移到用户空间。</li><li>优点：微内核操作系统可以提高系统的可扩展性和可维护性，提高系统的安全性。</li><li>缺点：微内核操作系统需要更多的用户空间资源，如果用户空间资源不足，系统性能可能会受到影响。</li></ol><h4 id="嵌入式操作系统"><a href="#嵌入式操作系统" class="headerlink" title="嵌入式操作系统"></a>嵌入式操作系统</h4><p>嵌入式操作系统是一种用于嵌入式系统的操作系统。它通常用于嵌入式设备，如智能手机、平板电脑、汽车电子设备等。</p><ol><li>嵌入式系统：嵌入式系统是指将计算机系统嵌入到其他设备中，以实现特定功能。</li><li>优点：嵌入式操作系统可以提高设备的性能和可靠性，降低设备的成本。</li><li>缺点：嵌入式操作系统需要根据设备的需求进行定制，开发周期较长。</li></ol><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><p>网络操作系统是一种用于网络环境的操作系统。它通常用于计算机网络，如局域网、广域网等。</p><ol><li>网络环境：网络环境是指计算机系统通过网络进行通信和资源共享的环境。</li><li>优点：网络操作系统可以提高计算机系统的通信效率和资源共享能力，提高计算机系统的可用性和可靠性。</li><li>缺点：网络操作系统需要更多的网络资源，如果网络资源不足，系统性能可能会受到影响。</li></ol><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><p>分布式操作系统是一种将计算机系统通过网络连接起来，形成一个整体系统的操作系统。它通常用于分布式计算和云计算环境。</p><ol><li>分布式计算：分布式计算是指将计算任务分配给多个计算机系统，以实现更高的计算性能。</li><li>优点：分布式操作系统可以提高计算机系统的计算性能和可靠性，提高计算机系统的可用性和可扩展性。</li><li>缺点：分布式操作系统需要更多的网络资源，如果网络资源不足，系统性能可能会受到影响。</li></ol><h3 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h3><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><p>并发：指两个或多个事件可以在同一个时间间隔发生，用户看起来是每个程序都在运行，实际上是每个程序都交替执行。<br>并行：指两个或多个事件可以在同一个时刻发生，多核CPU可以实现并行，一个cpu同一时刻只有一个程序在运行；</p><h4 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h4><p>操作系统允许多个进程或线程共享计算机系统的资源，如CPU、内存、输入输出设备等。</p><ol><li>互斥共享：多个进程或线程需要互斥地访问共享资源，以避免资源冲突。</li><li>同时共享：多个进程或线程可以同时访问共享资源，以提高系统性能。</li></ol><h4 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h4><p>操作系统通过虚拟化技术，将物理资源映射为虚拟资源，为进程或线程提供独立的运行环境。<br>运用的技术：</p><ol><li>时分复用技术</li><li>空间复用技术</li></ol><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>操作系统支持异步操作，即进程或线程可以在等待某个操作完成时继续执行其他操作。</p><h3 id="操作系统的中断处理"><a href="#操作系统的中断处理" class="headerlink" title="操作系统的中断处理"></a>操作系统的中断处理</h3><p>中断机制的作用：为了在多道批处理系统中让用户进行交互</p><h4 id="中断产生："><a href="#中断产生：" class="headerlink" title="中断产生："></a>中断产生：</h4><pre><code>发生中断时，CPU立马切换到管态，开展管理工作；（管态又叫特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）发生中断后，当前运行的进程回暂停运行，由操作系统内核对中断进行处理；对于不同的中断信号，会进行不同的处理</code></pre><h4 id="中断处理过程："><a href="#中断处理过程：" class="headerlink" title="中断处理过程："></a>中断处理过程：</h4><pre><code>保护现场：将当前进程的CPU环境保存起来，以便中断处理结束后恢复；中断处理：根据中断信号，执行相应的中断处理程序；恢复现场：将保存的CPU环境恢复，继续执行被中断的进程；中断返回：返回到被中断的进程，继续执行。</code></pre><h4 id="中断的分类"><a href="#中断的分类" class="headerlink" title="中断的分类"></a>中断的分类</h4><pre><code>内中断：由CPU检测到的异常事件，如除零错误、非法指令等。外中断：由外部设备发出的中断信号，如时钟中断、I/O中断等。</code></pre><h5 id="外中断的处理过程"><a href="#外中断的处理过程" class="headerlink" title="外中断的处理过程"></a>外中断的处理过程</h5><pre><code>1.每执行完一个指令后，CPU都需要检查当前是否有外部中断 信号；2。如果检查到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）；3.根据中断信号类型转入相应的中断处理程序；4.恢复原进程的CPU环境并退出中断，返回原进程继续执行。</code></pre><h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><h4 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h4><ol><li>进程控制：创建、撤销进程，以及进程状态的转换；</li><li>进程同步：解决进程间的竞争和协作问题；</li><li>进程通信：实现进程间的数据交换和消息传递；</li><li>调度：决定进程的执行顺序，提高系统资源利用率；</li></ol><h4 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h4><ol><li>内存分配和回收：为进程分配内存空间，实现内存保护；</li><li>内存保护：防止进程间非法访问内存；</li><li>内存扩充：通过虚拟内存技术，实现内存的扩充；</li><li>地址映射：将逻辑地址映射为物理地址，实现内存访问；</li></ol><h4 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h4><ol><li>缓冲管理：通过缓冲区，提高I&#x2F;O效率；</li><li>设备分配：为进程分配所需的I&#x2F;O设备；</li><li>设备处理：处理I&#x2F;O请求，实现设备与进程的交互；</li></ol><h4 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h4><ol><li>文件存储空间管理：分配和回收文件存储空间；</li><li>文件读写操作：实现文件的读写操作；</li><li>文件目录管理：实现文件的查找、创建、删除等操作；</li><li>文件保护：实现文件的安全性和完整性保护。</li></ol><h4 id="接口管理功能"><a href="#接口管理功能" class="headerlink" title="接口管理功能"></a>接口管理功能</h4><ol><li>用户接口：提供用户与操作系统交互的界面，如命令行、图形界面等；</li><li>程序接口：提供应用程序与操作系统交互的接口，如系统调用、库函数等；</li></ol><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><h4 id="简单结构"><a href="#简单结构" class="headerlink" title="简单结构"></a>简单结构</h4><pre><code>1. 内核：负责进程管理、内存管理、设备管理等核心功能；2. 外壳：提供用户接口，实现用户与内核的交互；</code></pre><h4 id="模块化结构"><a href="#模块化结构" class="headerlink" title="模块化结构"></a>模块化结构</h4><pre><code>1. 内核：负责进程管理、内存管理、设备管理等核心功能；2. 模块：实现特定的功能，如文件管理、网络通信等；3. 外壳：提供用户接口，实现用户与内核、模块的交互；</code></pre><p>优缺点：<br>    优点：模块化设计，易于维护和扩展；<br>    缺点：模块间通信复杂，可能导致性能下降。</p><h4 id="分层式结构"><a href="#分层式结构" class="headerlink" title="分层式结构"></a>分层式结构</h4><pre><code>1. 用户层：提供用户接口，实现用户与操作系统的交互；2. 系统调用层：实现系统调用，提供应用程序与内核的接口；3. 内核层：负责进程管理、内存管理、设备管理等核心功能；4. 设备驱动层：实现设备驱动程序，实现设备与内核的交互；</code></pre><p>优缺点：<br>    优点：层次清晰，易于理解和维护；<br>    缺点：层次过多，可能导致性能下降。</p><h4 id="微内核结构"><a href="#微内核结构" class="headerlink" title="微内核结构"></a>微内核结构</h4><pre><code>1. 微内核：只提供最基本的功能，如进程管理、内存管理等；2. 客户进程：实现特定的功能，如文件管理、网络通信等；</code></pre><p>优缺点：<br>    优点：模块化设计，易于维护和扩展；<br>    缺点：微内核功能有限，可能需要更多的客户进程来实现复杂功能。</p><h4 id="外核结构"><a href="#外核结构" class="headerlink" title="外核结构"></a>外核结构</h4><pre><code>1. 内核：负责进程管理、内存管理、设备管理等核心功能；2. 外核：提供用户接口，实现用户与内核的交互；</code></pre><p>优缺点：<br>    优点：模块化设计，易于维护和扩展；<br>    缺点：外核功能有限，可能需要更多的内核来实现复杂功能。</p><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h3><ol><li>进程是程序在计算机上的一次执行过程，是系统进行资源分配和调度的基本单位；</li><li>进程具有独立的地址空间，可以并发执行，实现多任务处理；</li><li>进程之间可以通过通信、同步、互斥等机制实现协作和协调。</li></ol><h4 id="进程（Process）与线程（Thread）："><a href="#进程（Process）与线程（Thread）：" class="headerlink" title="进程（Process）与线程（Thread）："></a>进程（Process）与线程（Thread）：</h4><pre><code>线程：操作系统进行运行调度的最小单位。进程：系统进行资源分配和调度的基本单位。</code></pre><p>区别与联系：<br>    一个进程可以有一个或多个线程；<br>    线程包含在进程之中，是进程中实际运行工作的单位；<br>    进程的线程共享进程资源；<br>    一个进程可以并发多个线程，每个线程执行不同的任<br><img src="/operating_sys/jincheng.png" alt="进程"></img></p><h4 id="进程特征："><a href="#进程特征：" class="headerlink" title="进程特征："></a>进程特征：</h4><pre><code>    动态性：进程是动态产生、消亡的；    并发性：进程可以并发执行，实现多任务处理；    独立性：进程具有独立的地址空间，可以独立运行；    异步性：进程的执行是异步的，进程之间需要通过通信、同步、互斥等机制实现协作和协调。</code></pre><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ol><li>就绪状态：进程已经获取了除CPU外的所有资源，等待CPU调度；</li><li>运行状态：进程正在使用CPU，执行程序指令；</li><li>阻塞状态：进程等待某个事件（如I&#x2F;O操作、等待资源）的发生，无法继续执行；</li></ol><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><ol><li>先来先服务调度算法：按照进程到达的顺序进行调度；</li><li>最短作业优先调度算法：按照进程执行所需时间的长短进行调度；</li><li>时间片轮转调度算法：将CPU时间划分为固定长度的时间片，按照进程到达的顺序进行调度；</li><li>多级反馈队列调度算法：将进程分为多个队列，按照队列的优先级进行调度。</li></ol><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ol><li>管道通信：用于具有亲缘关系的进程之间的通信；</li><li>套接字通信：用于网络通信；</li><li>消息队列通信：用于进程间的数据交换；</li><li>共享内存通信：用于进程间的数据共享；</li><li>信号量通信：用于进程间的同步和互斥。</li></ol><h2 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h2><h3 id="进程调度-1"><a href="#进程调度-1" class="headerlink" title="进程调度"></a>进程调度</h3><p>定义：指计算机通过决策决定哪个就绪进程可以获得CPU使用权。<br>什么时候需要进程调度？</p><pre><code>主动放弃：进程正常终止；运行过程中发生异常而终止；主动阻塞（如等待I/O）；被动放弃：分给进程的时间片用完；有更高优先级的进程进入就绪队列；有更紧急的事情需要处理（如I/O中断）；</code></pre><p>进程调度方式：</p><pre><code>非抢占式调度：只能由当前运行的进程主动放弃CPU；    处理器一旦分配给某个进程，就让该进程一直使用下去；    调度程序不以任何原因抢占正在被使用的处理器；    调度程序不以任何原因抢占正在被使用的处理器；抢占式调度：可由操作系统剥夺当前进程的CPU使用权。    允许调度程序以一定的策略暂停当前运行的进程；    保存好旧进程的上下文信息，分配处理器给新进程；</code></pre><p><img src="/operating_sys/diaodu.png" alt="进程"></img></p><p>进程调度的三大机制：</p><p>就绪队列的排队机制：为了提高进程调度的效率，将就绪进程按照一定的方式排成队列，以便调度程序可以最快找到就绪进程。</p><h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><ol><li>先来先服务（FCFS）：按照进程到达的顺序进行调度；</li><li>最短作业优先（SJF）：按照进程执行所需时间的长短进行调度；</li><li>最短剩余时间优先（SRTF）：按照进程剩余执行时间的长短进行调度；</li><li>时间片轮转（RR）：将CPU时间划分为固定长度的时间片，按照进程到达的顺序进行调度；</li><li>多级反馈队列（MFQ）：将进程分为多个队列，按照队列的优先级进行调度。</li></ol><h3 id="进程死锁"><a href="#进程死锁" class="headerlink" title="进程死锁"></a>进程死锁</h3><p> 进程死锁是指多个进程在等待对方释放资源时，导致无法继续执行的情况；<br> 导致进程死锁的原因包括资源竞争、循环等待、不释放已获得的资源等；<br> 解决进程死锁的方法包括预防死锁、避免死锁、检测死锁和解除死锁等。<br>死锁的四个必要条件：<br>    互斥条件：必须互斥使用资源才会产生死锁；<br>    请求保持条件：进程至少保持一个资源，又提出新的资源请求，新资源被占用，请求被阻塞，被阻塞的进程不释放自己保持的资源；<br>    不可剥夺条件：进程获得的资源在未完成使用前不能被剥夺（包括OS），只能由进程自身释放；<br>    环路等待条件：发生死锁时，必然存在进程-资源环形链,环路等待不一定造成死锁，但是死锁一定有循环等待。</p><h4 id="死锁的处理决策"><a href="#死锁的处理决策" class="headerlink" title="死锁的处理决策"></a>死锁的处理决策</h4><p>一.预防死锁的方法：破坏四个必要条件的中一个或多个。</p><p>破坏互斥条件：将临界资源改造成共享资源（Spooling池化技术）；（可行性不高，很多时候无法破坏互斥条件）<br>破坏请求保持条件：系统规定进程运行之前，一次性申请所有需要的资源；（资源利用率低，可能导致别的线程饥饿）<br>破坏不可剥夺条件：当一个进程请求新的资源得不到满足时，必须释放占有的资源；（实现复杂，剥夺资源可能导致部分工作失效，反复申请和释放造成额外的系统开销）<br>破坏环路等待条件：可用资源线性排序，申请必须按照需要递增申请；（进程实际使用资源顺序和编号顺序不同，会导致资源浪费）<br>二.银行家算法：检查当前资源剩余是否可以满足某个进程的最大需求；如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；重复1，2，直到当前没有线程等待资源；</p><p>三.死锁的检测和解除：死锁检测算法，资源剥夺法，撤销进程法（终止进程法），进程回退法；</p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>互斥锁：用于保护临界区，防止多个进程同时访问共享资源；<br>信号量：用于进程间的同步和互斥，可以控制多个进程对共享资源的访问；<br>事件：用于进程间的同步，可以等待某个事件的发生；<br>条件变量：用于进程间的同步，可以等待某个条件变量的满足。</p><h3 id="进程同步与互斥"><a href="#进程同步与互斥" class="headerlink" title="进程同步与互斥"></a>进程同步与互斥</h3><ol><li>进程同步：进程间的协调和协作，确保进程按照一定的顺序执行；</li><li>进程互斥：进程间的竞争和限制，防止多个进程同时访问共享资源；</li><li>临界区：进程访问共享资源的一段代码；</li><li>信号量：用于进程间的同步和互斥，可以控制多个进程对共享资源的访问；</li><li>管程：用于进程间的同步和互斥，可以保护临界区，防止多个进程同时访问共享资源。</li></ol><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>单工通信信道：只能一个方向通信，没有反方向反馈的信道；<br>半双工通信信道：双方都可以发送和接受信息，但不能同时发送也不能同时接收；<br>全双工通信信道：双方都可以同时发送和接收。</p><h4 id="常用编码方式"><a href="#常用编码方式" class="headerlink" title="常用编码方式"></a>常用编码方式</h4><ol><li>不归零编码：正电平代表1，负电平代表0。</li><li>归零编码：正脉冲代表1，负脉冲代表0。</li><li>曼彻斯特编码：位周期中心的向上跳代表0，位周期中心的向下跳代表1。</li><li>差分曼彻斯特编码：每一位的中间都有一条电平跳变，位开始边界有跳变代表0，位开始边界无跳变代表1。</li></ol><h4 id="基本带通调制方法"><a href="#基本带通调制方法" class="headerlink" title="基本带通调制方法"></a>基本带通调制方法</h4><ol><li>调幅：改变载波的幅度。</li><li>调频：改变载波的频率。</li><li>调相：改变载波的相位。</li></ol><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><p>信道的极限容量是指信道能够传输的最大数据速率，即信道所能传输的最高数据率。</p><h4 id="信道能通过的控制范围"><a href="#信道能通过的控制范围" class="headerlink" title="信道能通过的控制范围"></a>信道能通过的控制范围</h4><p>奈氏准则指出，在理想低通信道的条件下，为了避免码间串扰，极限数据传输速率（即信道的最大数据传输速率）为：<br>C &#x3D; 2H log2V bps<br>其中：<br>C：信道的极限容量，单位为比特&#x2F;秒（bps）<br>H：信道带宽，单位为赫兹（Hz）<br>V：每个信号所用的码元个数<br>奈氏准则适用于理想低通信道，即信道的带宽足够宽，且信道的信噪比足够高。在实际应用中，为了满足奈氏准则，需要采取适当的编码方式，如差分曼彻斯特编码等。</p><p>信道的极限容量可以用以下公式计算：<br>C &#x3D; B log2(1 + S&#x2F;N)</p><p>其中：<br>C：信道的极限容量，单位为比特&#x2F;秒（bps）<br>B：信道的带宽，单位为赫兹（Hz）<br>S：信号功率<br>N：噪声功率</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><p>信号量机制是一种用于进程同步和互斥的机制，它通过一个整型变量（称为信号量）来控制对共享资源的访问。<br>信号量机制的基本思想是：当一个进程需要访问共享资源时，它首先检查信号量的值。如果信号量的值大于0，则表示有可用的资源，进程可以继续执行。如果信号量的值等于0，则表示没有可用的资源，进程需要等待，直到有其他进程释放资源为止。<br>当进程访问完共享资源后，它会增加信号量的值，以表示释放了资源。这样，其他等待的进程就可以继续执行了。<br>信号量机制可以确保多个进程对共享资源的访问是互斥的，即同一时刻只有一个进程可以访问共享资源。这样可以避免多个进程同时访问共享资源时出现的数据竞争和死锁等问题。</p><h4 id="信号量机制的基本操作包括P操作和V操作："><a href="#信号量机制的基本操作包括P操作和V操作：" class="headerlink" title="信号量机制的基本操作包括P操作和V操作："></a>信号量机制的基本操作包括P操作和V操作：</h4><p>P操作：将信号量的值减1，如果信号量的值小于0，则进程需要等待，直到有其他进程释放资源为止。<br>V操作：将信号量的值加1，如果有等待的进程，则唤醒其中一个进程。</p><h4 id="信号量机制的应用"><a href="#信号量机制的应用" class="headerlink" title="信号量机制的应用"></a>信号量机制的应用</h4><p>信号量机制可以用于实现进程同步和互斥，例如：</p><ol><li>进程同步：当一个进程需要等待另一个进程完成某个操作后才能继续执行时，可以使用信号量机制来实现进程同步。</li><li>进程互斥：当一个进程需要访问共享资源时，可以使用信号量机制来实现进程互斥，即同一时刻只有一个进程可以访问共享资源。</li><li>资源池：当一个进程需要访问有限数量的资源时，可以使用信号量机制来实现资源池，即限制对资源的访问数量，以避免资源耗尽。</li></ol><h4 id="信号量机制的特点"><a href="#信号量机制的特点" class="headerlink" title="信号量机制的特点"></a>信号量机制的特点</h4><ol><li>信号量机制是一种用于进程同步和互斥的机制，它通过一个整型变量（称为信号量）来控制对共享资源的访问。</li><li>信号量机制的基本操作包括P操作和V操作，P操作将信号量的值减1，V操作将信号量的值加1。</li><li>信号量机制可以确保多个进程对共享资源的访问是互斥的，即同一时刻只有一个进程可以访问共享资源。</li><li>信号量机制可以用于实现进程同步、进程互斥和资源池等功能。</li></ol><h4 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h4><p>信道复用技术是一种将多个信道合并为一个信道的技术，以提高通信效率和资源利用率。常见的信道复用技术包括频分复用（FDM）、时分复用（TDM）、波分复用（WDM）和码分复用（CDM）等。<br>频分复用（FDM）：将一个信道分成多个频率不同的子信道，每个子信道传输不同的信号。频分复用技术可以同时传输多个信号，但每个信号只能占用一个子信道。<br>时分复用（TDM）：将一个信道分成多个时间片，每个时间片传输不同的信号。时分复用技术可以同时传输多个信号，但每个信号只能在一个时间片内传输。<br>波分复用（WDM）：将一个信道分成多个波长不同的子信道，每个子信道传输不同的信号。波分复用技术可以同时传输多个信号，但每个信号只能占用一个子信道。<br>码分复用（CDM）：将一个信道分成多个码片，每个码片传输不同的信号。码分复用技术可以同时传输多个信号，但每个信号只能占用一个码片。</p><h4 id="信道复用技术的特点"><a href="#信道复用技术的特点" class="headerlink" title="信道复用技术的特点"></a>信道复用技术的特点</h4><ol><li>信道复用技术是一种将多个信道合并为一个信道的技术，以提高通信效率和资源利用率。</li><li>频分复用（FDM）、时分复用（TDM）、波分复用（WDM）和码分复用（CDM）是常见的信道复用技术。</li><li>频分复用技术将一个信道分成多个频率不同的子信道，每个子信道传输不同的信号。</li><li>时分复用技术将一个信道分成多个时间片，每个时间片传输不同的信号。</li><li>波分复用技术将一个信道分成多个波长不同的子信道，每个子信道传输不同的信号。</li><li>码分复用技术将一个信道分成多个码片，每个码片传输不同的信号。</li></ol><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象，导致这些进程都无法继续执行。死锁的产生通常是由于以下原因：</p><ol><li>资源竞争：当多个进程需要同时访问同一资源时，如果没有适当的同步机制，可能会导致死锁。</li><li>资源不可抢占：当进程已经获得一个资源，但无法继续执行时，该资源将无法被其他进程抢占，从而导致死锁。</li><li>循环等待：当多个进程互相等待对方释放资源时，如果没有适当的同步机制，可能会导致死锁。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>计算机网络是指将地理位置不同的具有独立功能的多个计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。</p><h2 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h2><h3 id="按照网络覆盖范围分类"><a href="#按照网络覆盖范围分类" class="headerlink" title="按照网络覆盖范围分类"></a>按照网络覆盖范围分类</h3><ol><li>局域网（LAN）：覆盖范围在几百米到十几公里以内，用于连接家庭、办公室、学校等小范围内的计算机设备。</li><li>城域网（MAN）：覆盖范围在几公里到几十公里以内，用于连接城市或地区内的计算机设备。</li><li>广域网（WAN）：覆盖范围在几十公里到几千公里以上，用于连接不同城市、地区或国家的计算机设备。</li></ol><h3 id="按照网络拓扑结构分类"><a href="#按照网络拓扑结构分类" class="headerlink" title="按照网络拓扑结构分类"></a>按照网络拓扑结构分类</h3><ol><li>星型拓扑：所有设备都连接到一个中央节点，中央节点负责数据转发。</li><li>环型拓扑：设备通过环形线路连接，数据沿环行线路传输。</li><li>总线拓扑：所有设备都连接到一条公共线路，数据沿线路传输。</li><li>网状拓扑：设备通过多条线路连接，数据可以沿多条路径传输。</li></ol><h3 id="按照网络传输介质分类"><a href="#按照网络传输介质分类" class="headerlink" title="按照网络传输介质分类"></a>按照网络传输介质分类</h3><ol><li>有线网络：使用物理介质（如电缆、光纤）进行数据传输。</li><li>无线网络：使用电磁波进行数据传输。</li></ol><h3 id="按照网络协议分类"><a href="#按照网络协议分类" class="headerlink" title="按照网络协议分类"></a>按照网络协议分类</h3><ol><li>TCP&#x2F;IP网络：使用TCP&#x2F;IP协议栈进行数据传输。</li><li>OSI网络：使用OSI模型进行数据传输。</li></ol><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>网络协议是计算机网络中不同设备之间进行通信的规则和约定。它定义了数据传输的格式、顺序、错误检测和纠正等。常见的网络协议包括：</p><ol><li>IP协议：互联网协议，用于在网络中传输数据包。</li><li>TCP协议：传输控制协议，用于在网络上可靠地传输数据。</li><li>UDP协议：用户数据报协议，用于在网络上快速传输数据。</li><li>HTTP协议：超文本传输协议，用于在互联网上传输超文本数据。</li><li>FTP协议：文件传输协议，用于在网络上传输文件。</li><li>SMTP协议：简单邮件传输协议，用于在网络上传输电子邮件。</li><li>DNS协议：域名系统协议，用于将域名解析为IP地址。</li></ol><h3 id="网络协议三要素"><a href="#网络协议三要素" class="headerlink" title="网络协议三要素"></a>网络协议三要素</h3><ol><li>语法：数据与控制信息的结构和格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>时序：事件发生顺序的详细说明</li></ol><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>OSI（Open System Interconnection，开放系统互连）模型是一个七层模型，用于描述计算机网络中不同层次的功能和交互。OSI模型将网络通信分为七个层次，从低到高依次为：</p><ol><li>物理层（Physical Layer）：负责物理传输介质上的比特流传输，包括电气特性、信号编码、传输速率等。</li><li>数据链路层（Data Link Layer）：负责在两个相邻节点之间建立、维护和断开数据链路，包括错误检测和纠正、帧的封装和拆封等。</li><li>网络层（Network Layer）：负责数据包的传输和路由选择，包括IP地址、路由协议、网络拥塞控制等。</li><li>传输层（Transport Layer）：负责端到端的可靠数据传输，包括TCP、UDP等协议。</li><li>会话层（Session Layer）：负责建立、管理和终止会话，包括同步、检查点等。</li><li>表示层（Presentation Layer）：负责数据格式的转换和加密解密，包括字符编码、数据压缩等。</li><li>应用层（Application Layer）：负责提供各种网络服务，如HTTP、FTP、SMTP等。</li></ol><p><img src="/jiwang/seven.png"></img></p><h3 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h3><p>TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;互联网协议）模型是一个四层模型，用于描述计算机网络中不同层次的功能和交互。TCP&#x2F;IP模型将网络通信分为四个层次，从低到高依次为：</p><ol><li>链路层（Link Layer）：负责在两个相邻节点之间建立、维护和断开数据链路，包括错误检测和纠正、帧的封装和拆封等。</li><li>网络层（Network Layer）：负责数据包的传输和路由选择，包括IP地址、路由协议、网络拥塞控制等。</li><li>传输层（Transport Layer）：负责端到端的可靠数据传输，包括TCP、UDP等协议。</li><li>应用层（Application Layer）：负责提供各种网络服务，如HTTP、FTP、SMTP等。</li></ol><p>TCP&#x2F;IP四层模型与OSI体系结构对比：</p><p><img src="/jiwang/osi_tcp.jpeg"></img></p><h3 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h3><p>五层模型是一种简化的网络体系结构模型，将OSI七层模型和TCP&#x2F;IP四层模型进行了合并和简化。五层模型将网络通信分为五个层次，从低到高依次为：</p><ol><li>物理层（Physical Layer）：负责物理传输介质上的比特流传输，包括电气特性、信号编码、传输速率等。</li><li>数据链路层（Data Link Layer）：负责在两个相邻节点之间建立、维护和断开数据链路，包括错误检测和纠正、帧的封装和拆封等。</li><li>网络层（Network Layer）：负责数据包的传输和路由选择，包括IP地址、路由协议、网络拥塞控制等。</li><li>传输层（Transport Layer）：负责端到端的可靠数据传输，包括TCP、UDP等协议。</li><li>应用层（Application Layer）：负责提供各种网络服务，如HTTP、FTP、SMTP等。</li></ol><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><ol><li>速率：数据传输速率，单位为比特每秒（bps）。</li><li>带宽：网络中某条链路的最高数据传输速率，单位为比特每秒（bps）。</li><li>吞吐量：网络中某条链路在单位时间内实际传输的数据量，单位为比特每秒（bps）。</li><li>时延：数据从发送端到接收端所需的时间，包括发送时延、传播时延、处理时延和排队时延。</li><li>时延带宽积：时延带宽积等于带宽乘以时延，表示网络中某条链路的缓冲区大小。</li><li>往返时间（RTT）：数据从发送端发送到接收端，再从接收端返回到发送端所需的时间。</li><li>利用率：网络中某条链路被实际数据传输占用的比例。</li></ol><h2 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h2><p>网络设备是计算机网络中用于实现数据传输和路由的设备。常见的网络设备包括：</p><ol><li>路由器（Router）：用于连接不同的网络，实现数据包的路由和转发。</li><li>交换机（Switch）：用于连接计算机和其他网络设备，实现数据包的交换。</li><li>集线器（Hub）：用于连接计算机和其他网络设备，实现数据包的广播。</li><li>网桥（Bridge）：用于连接两个或多个网络，实现数据包的转发。</li><li>网关（Gateway）：用于连接不同的网络，实现不同网络协议之间的转换。</li><li>防火墙（Firewall）：用于保护网络免受外部攻击，实现数据包的过滤和转发。</li><li>负载均衡器（Load Balancer）：用于将网络流量分配到多个服务器，提高网络性能和可靠性。</li></ol><h2 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h2><p>网络安全是计算机网络中保护数据传输和系统安全的重要方面。常见的网络安全措施包括：</p><ol><li>加密：使用加密算法对数据进行加密，确保数据在传输过程中的安全性。</li><li>认证：使用身份验证机制，确保只有授权用户才能访问网络资源。</li><li>访问控制：使用访问控制列表（ACL）限制对网络资源的访问。</li><li>防火墙：使用防火墙阻止未经授权的访问和数据传输。</li><li>入侵检测系统（IDS）：监控网络流量，检测和报告潜在的入侵行为。</li><li>入侵防御系统（IPS）：阻止和防御已知的入侵行为。</li><li>安全审计：定期审计网络和系统安全，发现和修复安全漏洞。</li></ol><h2 id="网络性能优化"><a href="#网络性能优化" class="headerlink" title="网络性能优化"></a>网络性能优化</h2><p>网络性能优化是提高网络传输速度和可靠性的重要方面。常见的网络性能优化措施包括：</p><ol><li>优化网络拓扑：通过优化网络拓扑结构，减少网络延迟和提高网络带宽。</li><li>优化路由算法：通过优化路由算法，选择最优路径进行数据传输。</li><li>优化数据传输协议：通过优化数据传输协议，提高数据传输效率和可靠性。</li><li>优化网络设备配置：通过优化网络设备配置，提高网络设备的性能和可靠性。</li><li>优化网络带宽：通过优化网络带宽，提高网络传输速度和可靠性。</li><li>优化网络流量管理：通过优化网络流量管理，减少网络拥塞和提高网络性能。</li><li>优化网络监控：通过优化网络监控，及时发现和解决网络性能问题。</li></ol><h2 id="网络故障排除"><a href="#网络故障排除" class="headerlink" title="网络故障排除"></a>网络故障排除</h2><p>网络故障排除是解决网络问题的重要方面。常见的网络故障排除方法包括：</p><ol><li>检查网络连接：检查网络连接是否正常，包括物理连接和网络配置。</li><li>检查网络设备：检查网络设备是否正常工作，包括路由器、交换机和防火墙等。</li><li>检查网络协议：检查网络协议是否正常工作，包括IP协议、TCP协议和UDP协议等。</li><li>检查网络流量：检查网络流量是否正常，包括网络带宽和流量分布等。</li><li>检查网络日志：检查网络日志，发现和解决网络问题。</li><li>使用网络诊断工具：使用网络诊断工具，如ping、traceroute和netstat等，诊断网络问题。</li><li>检查网络配置：检查网络配置是否正确，包括IP地址、子网掩码和网关等。</li></ol><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p>网络管理是确保网络正常运行和维护网络性能的重要方面。常见的网络管理任务包括：</p><ol><li>监控网络性能：监控网络性能，包括网络带宽、网络延迟和网络流量等。</li><li>网络故障排除：解决网络故障，包括网络连接故障、网络设备故障和网络协议故障等。</li><li>网络配置管理：管理网络配置，包括IP地址、子网掩码和网关等。</li><li>网络安全管理：管理网络安全，包括防火墙配置、访问控制列表和入侵检测系统等。</li><li>网络设备管理：管理网络设备，包括路由器、交换机和防火墙等。</li><li>网络用户管理：管理网络用户，包括用户身份验证、用户权限和用户访问控制等。</li><li>网络备份和恢复：备份和恢复网络数据，确保网络数据的安全和可靠。</li></ol><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>应用层是计算机网络体系结构中的最高层，它为用户提供各种网络服务。应用层协议包括HTTP、FTP、SMTP、DNS等。应用层协议负责处理用户请求，并将请求发送到网络层。</p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="域名系统概述"><a href="#域名系统概述" class="headerlink" title="域名系统概述"></a>域名系统概述</h3><p>域名系统（DNS）是互联网中的一个重要服务，它将域名解析为IP地址。DNS协议使用UDP协议进行通信，端口号为53。</p><h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><p>域名由多个标签组成，每个标签之间用点号（.）分隔。例如，<a href="http://www.example.com是一个域名,其中www是主机名,example是二级域名,com是顶级域名./">www.example.com是一个域名，其中www是主机名，example是二级域名，com是顶级域名。</a></p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><p>域名服务器是存储域名和IP地址映射关系的数据库。DNS协议使用域名服务器来解析域名。域名服务器分为以下几种类型：</p><ol><li>根域名服务器：根域名服务器存储顶级域名的IP地址。</li><li>顶级域名服务器：顶级域名服务器存储二级域名的IP地址。</li><li>权限域名服务器：权限域名服务器存储特定域名的IP地址。</li><li>本地域名服务器：本地域名服务器是用户计算机上的DNS服务器，它负责将域名解析为IP地址。</li></ol><h3 id="DNS解析过程："><a href="#DNS解析过程：" class="headerlink" title="DNS解析过程："></a>DNS解析过程：</h3><ol><li>用户在浏览器中输入域名，如<a href="http://www.example.com./">www.example.com。</a></li><li>浏览器向本地DNS服务器发送DNS查询请求，请求解析域名。</li><li>本地DNS服务器向根DNS服务器发送DNS查询请求，请求解析域名。</li><li>根DNS服务器返回顶级域名（如.com）的DNS服务器地址。</li><li>本地DNS服务器向顶级域名DNS服务器发送DNS查询请求，请求解析域名。</li><li>顶级域名DNS服务器返回二级域名（如example.com）的DNS服务器地址。</li><li>本地DNS服务器向二级域名DNS服务器发送DNS查询请求，请求解析域名。</li><li>二级域名DNS服务器返回域名对应的IP地址。</li><li>本地DNS服务器将IP地址返回给浏览器。</li><li>浏览器使用IP地址与服务器建立连接，并获取网页内容。</li></ol><h3 id="递归查询和迭代查询"><a href="#递归查询和迭代查询" class="headerlink" title="递归查询和迭代查询"></a>递归查询和迭代查询</h3><p>DNS查询有两种类型：递归查询和迭代查询。</p><p>递归查询是指DNS服务器将查询结果返回给用户计算机。如果DNS服务器无法解析域名，它将向其他DNS服务器发送查询请求，直到找到IP地址为止。<br>迭代查询是指DNS服务器将查询结果返回给用户计算机。如果DNS服务器无法解析域名，它将向其他DNS服务器发送查询请求，直到找到IP地址为止。</p><h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>DNS缓存是指将域名和IP地址的映射关系存储在本地计算机上，以便快速解析域名。DNS缓存可以减少DNS查询的次数，提高网络性能。</p><h3 id="DNS安全"><a href="#DNS安全" class="headerlink" title="DNS安全"></a>DNS安全</h3><p>DNS安全是保护DNS服务器和DNS数据免受攻击的重要方面。常见的DNS安全措施包括：</p><ol><li>使用DNSSEC：DNSSEC是一种数字签名技术，用于验证DNS数据的完整性和真实性。</li><li>使用DNS加密：DNS加密是一种加密技术，用于保护DNS查询和响应的机密性。</li><li>使用DNS缓存：DNS缓存可以减少DNS查询的次数，提高网络性能。</li><li>使用DNS过滤：DNS过滤是一种技术，用于过滤DNS查询和响应，防止恶意域名解析。</li><li>使用DNS监控：DNS监控是一种技术，用于监控DNS服务器的状态和性能，及时发现和解决DNS问题。</li></ol><h2 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h2><p>FTP（File Transfer Protocol，文件传输协议）是一种用于在计算机之间传输文件的协议。FTP使用TCP协议进行通信，端口号为20和21。</p><h3 id="FTP工作原理："><a href="#FTP工作原理：" class="headerlink" title="FTP工作原理："></a>FTP工作原理：</h3><ol><li>客户端向FTP服务器发送连接请求，建立TCP连接。</li><li>客户端向FTP服务器发送用户名和密码，进行身份验证。</li><li>客户端向FTP服务器发送文件传输命令，如上传、下载或删除文件。</li><li>FTP服务器接收到命令后，执行相应的操作，并将结果返回给客户端。</li><li>客户端接收到结果后，关闭连接。</li></ol><h3 id="FTP传输模式："><a href="#FTP传输模式：" class="headerlink" title="FTP传输模式："></a>FTP传输模式：</h3><p>FTP协议有两种传输模式：主动模式和被动模式。<br>主动模式是指FTP服务器主动向客户端发送连接请求，建立TCP连接。主动模式需要客户端的防火墙允许外部连接。<br>被动模式是指FTP服务器被动地等待客户端的连接请求，建立TCP连接。被动模式需要客户端的防火墙允许外部连接。</p><h3 id="FTP安全"><a href="#FTP安全" class="headerlink" title="FTP安全"></a>FTP安全</h3><p>FTP协议本身不提供加密功能，因此存在安全风险。为了保护数据传输的安全性，可以使用以下方法：</p><ol><li>使用SFTP（Secure File Transfer Protocol，安全文件传输协议）：SFTP是一种基于SSH协议的文件传输协议，提供加密功能，可以保护数据传输的安全性。</li><li>使用FTPS（FTP Secure，安全FTP）：FTPS是一种基于SSL&#x2F;TLS协议的FTP协议，提供加密功能，可以保护数据传输的安全性。</li><li>使用加密通道：可以使用VPN（Virtual Private Network，虚拟专用网络）等加密通道，保护数据传输的安全性。</li></ol><h2 id="简单文件传输协议"><a href="#简单文件传输协议" class="headerlink" title="简单文件传输协议"></a>简单文件传输协议</h2><p>TFTP（Trivial File Transfer Protocol，简单文件传输协议）是一种用于在计算机之间传输文件的协议。FTP使用TCP协议进行通信，端口号为20和21。</p><h3 id="TFTP优点："><a href="#TFTP优点：" class="headerlink" title="TFTP优点："></a>TFTP优点：</h3><ol><li>TFTP可用于UDP传输，无需建立TCP连接，传输速度快。</li><li>TFTP代码量小，实现简单，适合嵌入式系统使用。</li></ol><h3 id="TFTP缺点："><a href="#TFTP缺点：" class="headerlink" title="TFTP缺点："></a>TFTP缺点：</h3><ol><li>不支持断点续传：TFTP协议不支持断点续传，如果传输过程中出现错误，需要重新传输整个文件。</li><li>不支持目录操作：TFTP协议不支持目录操作，只能传输文件。</li><li>不支持加密：TFTP协议本身不提供加密功能，因此存在安全风险。</li></ol><h3 id="TFTP的主要特点"><a href="#TFTP的主要特点" class="headerlink" title="TFTP的主要特点"></a>TFTP的主要特点</h3><ol><li>每次传输的数据报文中有512字节的数据，但最后一次可不足512字节</li><li>数据报文按序编号，从1开始</li><li>支持ASCII码或二进制传送</li><li>可对文件进行读或写</li><li>使用简单的首部</li></ol><h2 id="远程终端协议-TELNET"><a href="#远程终端协议-TELNET" class="headerlink" title="远程终端协议 TELNET"></a>远程终端协议 TELNET</h2><p>TELNET（Teletype Network，电传网络）是一种用于远程登录的协议，允许用户通过计算机终端连接到远程计算机，并执行远程计算机上的命令。TELNET使用TCP协议进行通信，端口号为23。</p><h3 id="TELNET的主要特点"><a href="#TELNET的主要特点" class="headerlink" title="TELNET的主要特点"></a>TELNET的主要特点</h3><ol><li>支持多种操作系统和终端类型</li><li>支持多种字符集和编码</li><li>支持多种命令和操作</li><li>支持多种传输模式和协议</li><li>支持多种安全性和认证机制</li></ol><h2 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h2><p>万维网（World Wide Web，简称WWW）是一个基于超文本的分布式系统，允许用户通过浏览器访问和浏览互联网上的信息。万维网使用HTTP协议进行通信，端口号为80。</p><h3 id="万维网的主要特点"><a href="#万维网的主要特点" class="headerlink" title="万维网的主要特点"></a>万维网的主要特点</h3><ol><li>超文本：万维网使用超文本技术，允许用户通过链接从一个页面跳转到另一个页面。</li><li>分布式：万维网是一个分布式系统，由多个服务器和客户端组成，用户可以通过浏览器访问和浏览互联网上的信息。</li><li>交互性：万维网支持用户与网页的交互，如填写表单、点击链接等。</li><li>多媒体：万维网支持多种媒体类型，如文本、图片、音频、视频等。</li><li>易用性：万维网使用户可以轻松地访问和浏览互联网上的信息，无需了解复杂的网络协议和技术。</li></ol><h3 id="统一资源定位符-URL"><a href="#统一资源定位符-URL" class="headerlink" title="统一资源定位符 URL"></a>统一资源定位符 URL</h3><p>统一资源定位符（Uniform Resource Locator，简称URL）是万维网中用于标识资源的唯一标识符。URL由协议、域名、路径、查询参数和锚点组成，例如：<a href="http://www.example.com/path/to/resource?query=param#anchor">http://www.example.com/path/to/resource?query=param#anchor</a></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP（HyperText Transfer Protocol，超文本传输协议）是互联网中最常用的协议之一，用于在Web浏览器和Web服务器之间传输数据。HTTP协议使用TCP协议进行通信，端口号为80。</p><h3 id="HTTP请求和响应："><a href="#HTTP请求和响应：" class="headerlink" title="HTTP请求和响应："></a>HTTP请求和响应：</h3><ol><li>客户端向服务器发送HTTP请求，请求服务器提供特定的资源，如网页、图片或视频等。</li><li>服务器接收到请求后，根据请求的内容返回相应的HTTP响应，如200 OK表示请求成功，404 Not Found表示请求的资源不存在等。</li><li>客户端接收到HTTP响应后，根据响应的内容进行相应的处理，如显示网页、下载文件或播放视频等。</li></ol><h3 id="HTTP请求方法："><a href="#HTTP请求方法：" class="headerlink" title="HTTP请求方法："></a>HTTP请求方法：</h3><ol><li>GET：请求指定的资源。</li><li>POST：向指定的资源提交数据进行处理请求（例如提交表单或者上传文件）。</li><li>PUT：向指定的资源位置上传其最新内容。</li><li>DELETE：请求服务器删除指定的资源。</li><li>HEAD：与GET请求相同，但服务器在响应中只返回头部信息，不返回实体的主体。</li><li>OPTIONS：返回目标资源所支持的通信选项。</li><li>PATCH：对资源进行部分修改。</li><li>CONNECT：HTTP&#x2F;1.1协议中预留给能够将连接改为管道方式的代理服务器。</li><li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li></ol><h3 id="HTTP状态码："><a href="#HTTP状态码：" class="headerlink" title="HTTP状态码："></a>HTTP状态码：</h3><pre><code>1xx：信息性状态码，表示请求已被接收，继续处理。2xx：成功状态码，表示请求已成功被服务器接收、理解、并接受。3xx：重定向状态码，表示需要客户端采取进一步的操作才能完成请求。4xx：客户端错误状态码，表示请求包含语法错误或无法被服务器理解。5xx：服务器错误状态码，表示服务器在处理请求的过程中发生了错误。</code></pre><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>电子邮件是一种通过互联网发送和接收消息的通信方式。电子邮件使用SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）进行邮件的发送，使用POP3（Post Office Protocol version 3，邮局协议版本3）或IMAP（Internet Message Access Protocol，互联网消息访问协议）进行邮件的接收。</p><h3 id="电子邮件的组成部分："><a href="#电子邮件的组成部分：" class="headerlink" title="电子邮件的组成部分："></a>电子邮件的组成部分：</h3><ol><li>发件人：邮件的发件人地址，表示邮件的发送者。</li><li>收件人：邮件的收件人地址，表示邮件的接收者。</li><li>主题：邮件的主题，表示邮件的主要内容。</li><li>正文：邮件的正文，表示邮件的具体内容。</li><li>附件：邮件的附件，表示邮件中包含的额外文件。</li></ol><h3 id="电子邮件的工作流程："><a href="#电子邮件的工作流程：" class="headerlink" title="电子邮件的工作流程："></a>电子邮件的工作流程：</h3><ol><li>用户通过邮件客户端编写邮件，并设置发件人和收件人地址。</li><li>邮件客户端使用SMTP协议将邮件发送到邮件服务器。</li><li>邮件服务器接收到邮件后，根据收件人地址将邮件发送到相应的邮件服务器。</li><li>收件人的邮件服务器接收到邮件后，根据用户的设置将邮件存储到用户的邮箱中。</li><li>用户通过邮件客户端使用POP3或IMAP协议从邮件服务器中下载邮件。</li></ol><h2 id="动态主机配置协议（DHCP）"><a href="#动态主机配置协议（DHCP）" class="headerlink" title="动态主机配置协议（DHCP）"></a>动态主机配置协议（DHCP）</h2><p>动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）是一种用于自动分配IP地址和其他网络配置参数的协议。DHCP服务器负责为客户端分配IP地址和其他网络配置参数，例如子网掩码、默认网关和DNS服务器地址等。</p><h3 id="DHCP的工作流程："><a href="#DHCP的工作流程：" class="headerlink" title="DHCP的工作流程："></a>DHCP的工作流程：</h3><ol><li>客户端发送DHCP Discover报文，广播请求IP地址。</li><li>DHCP服务器接收到DHCP Discover报文后，发送DHCP Offer报文，提供可用的IP地址和其他网络配置参数。</li><li>客户端接收到DHCP Offer报文后，发送DHCP Request报文，选择一个DHCP服务器，并请求分配IP地址和其他网络配置参数。</li><li>DHCP服务器接收到DHCP Request报文后，发送DHCP Ack报文，确认分配的IP地址和其他网络配置参数。</li><li>客户端接收到DHCP Ack报文后，开始使用分配的IP地址和其他网络配置参数。</li></ol><h3 id="DHCP的租约机制："><a href="#DHCP的租约机制：" class="headerlink" title="DHCP的租约机制："></a>DHCP的租约机制：</h3><p>DHCP服务器会为客户端分配一个IP地址和其他网络配置参数，并设置一个租约期限。租约期限到期后，客户端需要重新申请IP地址和其他网络配置参数。如果客户端在租约期限内没有重新申请IP地址和其他网络配置参数，DHCP服务器会回收该IP地址和其他网络配置参数，并将其分配给其他客户端。</p><h3 id="DHCP的配置："><a href="#DHCP的配置：" class="headerlink" title="DHCP的配置："></a>DHCP的配置：</h3><p>DHCP服务器的配置通常包括以下内容：</p><ol><li>DHCP服务器的IP地址和子网掩码。</li><li>DHCP服务器的网关地址和DNS服务器地址。</li><li>可分配的IP地址范围和租约期限。</li><li>预留的IP地址和MAC地址的对应关系。</li></ol><h3 id="DHCP的优缺点："><a href="#DHCP的优缺点：" class="headerlink" title="DHCP的优缺点："></a>DHCP的优缺点：</h3><p>优点：</p><ol><li>自动分配IP地址和其他网络配置参数，简化了网络配置和管理。</li><li>可以动态地分配IP地址和其他网络配置参数，提高了IP地址的利用率。</li><li>可以防止IP地址冲突和地址冲突。</li></ol><p>缺点：</p><ol><li>DHCP服务器需要足够的IP地址和其他网络配置参数，否则无法满足客户端的需求。 </li><li>DHCP服务器需要足够的带宽和计算资源，否则会影响网络性能。</li></ol><h2 id="简单网络管理协议（SNMP）"><a href="#简单网络管理协议（SNMP）" class="headerlink" title="简单网络管理协议（SNMP）"></a>简单网络管理协议（SNMP）</h2><p>简单网络管理协议（Simple Network Management Protocol，SNMP）是一种用于网络设备管理和监控的协议。SNMP允许网络管理员通过网络查询和修改网络设备的配置，并获取网络设备的运行状态和性能数据。</p><h3 id="SNMP的工作流程："><a href="#SNMP的工作流程：" class="headerlink" title="SNMP的工作流程："></a>SNMP的工作流程：</h3><ol><li>管理员使用SNMP管理工具发送SNMP请求报文到网络设备。</li><li>网络设备接收到SNMP请求报文后，根据请求报文中的操作码执行相应的操作，并将结果返回给管理员。</li><li>管理员接收到网络设备的响应报文后，根据响应报文中的信息进行相应的处理。</li></ol><h3 id="SNMP的报文格式："><a href="#SNMP的报文格式：" class="headerlink" title="SNMP的报文格式："></a>SNMP的报文格式：</h3><p>SNMP报文由以下部分组成：</p><ol><li>版本号：标识SNMP的版本。</li><li>通用头：包含SNMP请求或响应的标识符、请求或响应的类型、请求或响应的序列号等信息。</li><li>特定头：包含SNMP请求或响应的操作码、请求或响应的参数等信息。</li><li>数据：包含SNMP请求或响应的具体数据。</li></ol><h3 id="SNMP的报文类型："><a href="#SNMP的报文类型：" class="headerlink" title="SNMP的报文类型："></a>SNMP的报文类型：</h3><p>SNMP的报文类型包括以下几种：</p><ol><li>GET请求：管理员发送GET请求报文到网络设备，请求获取网络设备的配置、运行状态和性能数据。</li><li>GETNEXT请求：管理员发送GETNEXT请求报文到网络设备，请求获取网络设备的下一个配置、运行状态和性能数据。</li><li>GETBULK请求：管理员发送GETBULK请求报文到网络设备，请求获取网络设备的多个配置、运行状态和性能数据。</li><li>SET请求：管理员发送SET请求报文到网络设备，请求修改网络设备的配置。</li><li>TRAP报文：网络设备发送TRAP报文到管理员，通知管理员网络设备发生了某些事件。</li></ol><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层是OSI参考模型中的最低层，它负责在物理媒体上传输比特流。物理层的主要功能包括：</p><ol><li>定义物理媒体：物理层定义了物理媒体，如电缆、光纤、无线电波等。</li><li>定义比特流传输：物理层定义了比特流传输的方式，如串行传输和并行传输。</li><li>定义比特流编码：物理层定义了比特流的编码方式，如曼彻斯特编码和差分曼彻斯特编码。</li><li>定义比特流同步：物理层定义了比特流的同步方式，如时钟同步和数据同步。</li><li>定义比特流错误检测：物理层定义了比特流的错误检测方式，如奇偶校验和循环冗余校验。</li><li>定义比特流传输控制：物理层定义了比特流的传输控制方式，如流量控制和拥塞控制。</li></ol><h3 id="物理层的作用"><a href="#物理层的作用" class="headerlink" title="物理层的作用"></a>物理层的作用</h3><p>连接不同的物理设备，传输比特流。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</p><p>物理层的主要任务为确定与传输媒体的接口有关的一些特性</p><ol><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li>电气特性：指明在接口电缆的各条线上出现的电压范围。（一般为5~12v）</li><li>功能特性：指明某条线上出现的某一电平表示何种意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现，接口每一方所应执行的动作。</li></ol><h3 id="数据通信基础知识"><a href="#数据通信基础知识" class="headerlink" title="数据通信基础知识"></a>数据通信基础知识</h3><p>一个数据通信系统可以划分为三大部分：源系统（发送端，发送方）、传输系统（传输网络）、目的系统（接收端，接收方）。</p><p>源系统一般包括以下两个部分：</p><ol><li>源点：源点负责产生要传输的数据。</li><li>发送器：发送器负责将要传输的数据转换成信号。</li></ol><p>目的系统一般也包含以下两个部分：</p><ol><li>接收器：接收器负责将从传输系统中接收到的信号转换成数据。</li><li>终点：终点负责处理接收到的数据。</li></ol><p>传输系统一般包括以下两个部分：</p><ol><li>传输介质：传输介质负责在源系统和目的系统之间传输信号。</li><li>路由器：路由器负责在源系统和目的系统之间选择最佳路径。</li></ol><p>常用术语：</p><ol><li>数据：数据是运送信息的实体，是通信的负载。</li><li>信号：信号是数据的电气或电磁的表现，是数据在传输系统中物理上的表现形式。</li><li>比特：比特是信号量的基本度量单位，是计算机中数据量的基本单位。</li><li>码元：码元是信号量的另一种度量单位，是数字通信中信号量的基本单位。</li><li>速率：速率是数据传输速率的度量单位，是单位时间内传输的数据量。</li><li>带宽：带宽是信号传输能力的度量单位，是单位时间内传输的信号量。</li></ol><p>信号的分类：</p><ol><li>模拟信号：模拟信号是连续变化的信号，如音频信号。</li><li>数字信号：数字信号是离散变化的信号，如二进制信号。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车载娱乐小平板</title>
      <link href="/2024/08/15/%E8%BD%A6%E8%BD%BD%E5%A8%B1%E4%B9%90%E5%B0%8F%E5%B9%B3%E6%9D%BF/"/>
      <url>/2024/08/15/%E8%BD%A6%E8%BD%BD%E5%A8%B1%E4%B9%90%E5%B0%8F%E5%B9%B3%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>开发平台：gec6818开发板<br>开发环境：ubuntu 24.04<br>开发语言：c语言<br>开发工具：vscode<br>编译工具：arm-linux-gcc<br>开发内容：实现一个车载娱乐小平板，包括登陆注册、播放音乐、播放视频、显示图片等功能。</p><h2 id="1-系统功能"><a href="#1-系统功能" class="headerlink" title="1. 系统功能"></a>1. 系统功能</h2><h3 id="1-1-登陆注册"><a href="#1-1-登陆注册" class="headerlink" title="1.1 登陆注册"></a>1.1 登陆注册</h3><p>如果用户没有注册过账号，则可以注册账号，账号密码保存在文件中，用户可以登陆账号，登陆成功后进入主界面，登陆失败则等待5秒后退回到登陆界面等待用户再次输入。</p><h3 id="1-2-播放音乐"><a href="#1-2-播放音乐" class="headerlink" title="1.2 播放音乐"></a>1.2 播放音乐</h3><p>用户可以播放音乐，音乐文件保存在文件中，用户可以选择播放音乐，播放音乐时可以暂停、继续、上一首、下一首。</p><h3 id="1-3-游戏"><a href="#1-3-游戏" class="headerlink" title="1.3 游戏"></a>1.3 游戏</h3><p>用户可以玩2048游戏，扫雷等游戏。</p><h3 id="1-4-显示图片"><a href="#1-4-显示图片" class="headerlink" title="1.4 显示图片"></a>1.4 显示图片</h3><p>用户可以显示图片，图片显示支持多种格式(bmp,jpg),图片文件保存在文件中，用户可以选择显示图片，显示图片时可以切换图片，图片显示支持放大显示和切换图片动画效果。</p><h2 id="2-系统设计"><a href="#2-系统设计" class="headerlink" title="2. 系统设计"></a>2. 系统设计</h2><h3 id="2-1-系统架构"><a href="#2-1-系统架构" class="headerlink" title="2.1 系统架构"></a>2.1 系统架构</h3><p>系统采用模块化设计，分为以下几个模块：</p><ul><li>用户管理模块：实现用户注册、登陆等功能。</li><li>音乐播放模块：实现音乐播放、暂停、继续、上一首、下一首等功能。</li><li>游戏模块：实现2048、扫雷等游戏功能。</li><li>图片显示模块：实现图片显示、切换等功能。</li><li>主界面模块：实现主界面显示、菜单选择等功能。</li></ul><h3 id="2-2-系统流程"><a href="#2-2-系统流程" class="headerlink" title="2.2 系统流程"></a>2.2 系统流程</h3><p>系统流程如下：</p><ol><li>用户注册：用户输入账号、密码，系统将账号、密码保存在文件中。</li><li>用户登陆：用户输入账号、密码，系统验证账号、密码是否正确，正确则进入主界面，错误则退出程序。</li><li>主界面：显示菜单，用户选择菜单项，进入相应功能。</li><li>音乐播放：用户选择音乐文件，系统播放音乐，用户可以选择暂停、继续、上一首、下一首。</li><li>游戏游玩：用户可以选择游戏，系统进入游戏界面，用户可以游玩游戏。</li><li>图片显示：用户选择图片文件，系统显示图片，用户可以选择切换图片。</li></ol><h2 id="3-系统实现"><a href="#3-系统实现" class="headerlink" title="3. 系统实现"></a>3. 系统实现</h2><h3 id="3-1-用户管理模块"><a href="#3-1-用户管理模块" class="headerlink" title="3.1 用户管理模块"></a>3.1 用户管理模块</h3><p>用户管理模块实现用户注册、登陆等功能，具体实现如下：</p><ol><li>用户注册：用户输入账号、密码，系统将账号、密码保存在文件中。</li><li>用户登陆：用户输入账号、密码，系统验证账号、密码是否正确，正确则进入主界面，错误则退出程序。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/input.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;font.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;framebuffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;login.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIG 800 * 480 * 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LITTLE 76 * 56 * 3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X1 203 + 80 * 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X2 203 + 80 * 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X3 203 + 80 * 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X4 203 + 80 * 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X5 203 + 80 * 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> X6 203 + 80 * 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACCOUNT_Y 43</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PASSWD_Y 123</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K0 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K1 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K2 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K3 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K4 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K5 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K6 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K7 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K8 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K9 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_DELETE 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> K_OK 11</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> fb_fd;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *fb_addr;</span><br><span class="line">font *f;</span><br><span class="line">bitmap bm;    <span class="comment">// 位图结构体</span></span><br><span class="line"><span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 0表示已注册，1表示未注册</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getPoint</span><span class="params">(<span class="type">int</span> *x, <span class="type">int</span> *y, <span class="type">int</span> *key_status)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// int x,y;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1、打开触摸屏驱动</span></span><br><span class="line">    <span class="type">int</span> ts_fd;</span><br><span class="line">    ts_fd = open(<span class="string">&quot;/dev/input/event0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (ts_fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开触摸屏失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义事件结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ts_event</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2、读取触摸坐标</span></span><br><span class="line">        read(ts_fd, &amp;ts_event, <span class="keyword">sizeof</span>(ts_event));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、处理坐标，判断信息 if</span></span><br><span class="line">        <span class="keyword">if</span> (ts_event.type == EV_ABS) <span class="comment">// 判断当前是否为触摸</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ts_event.code == ABS_X) <span class="comment">// 判断当前触摸坐标是否是x轴</span></span><br><span class="line">            &#123;</span><br><span class="line">                *x = ts_event.value; <span class="comment">// 输出x轴坐标</span></span><br><span class="line">                <span class="comment">// printf(&quot;x轴的坐标为：%d\n&quot;,x);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ts_event.code == ABS_Y) <span class="comment">// 判断当前触摸坐标是否是x轴</span></span><br><span class="line">            &#123;</span><br><span class="line">                *y = ts_event.value; <span class="comment">// 输出x轴坐标</span></span><br><span class="line">                <span class="comment">// printf(&quot;y轴的坐标为：%d\n&quot;,y);</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前的坐标为：(%d,%d)\n&quot;</span>, *x, *y);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否按下   按下：1  松开0</span></span><br><span class="line">        <span class="keyword">if</span> (ts_event.type == EV_KEY &amp;&amp; ts_event.code == BTN_TOUCH &amp;&amp; ts_event.value == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;当前的触摸值：%d\n&quot;</span>, ts_event.value);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;最后的坐标为：(%d,%d)\n&quot;</span>, *x, *y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;you have leaving....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、关闭触摸</span></span><br><span class="line">    *key_status = <span class="number">0</span>;</span><br><span class="line">    close(ts_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadBigImg</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> lcdbuf[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bmpfd;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> wet;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> bmpbuf[BIG];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, path);</span><br><span class="line">    bmpfd = open(path, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bmpfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开图片失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略过头字节</span></span><br><span class="line">    lseek(bmpfd, <span class="number">54</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、读取BMP图片的像素点</span></span><br><span class="line">    ret = read(bmpfd, bmpbuf, BIG);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;读取图片失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取的图片字节数为%d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-4字节转换</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">800</span> * <span class="number">480</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//       B                  G                  R            A</span></span><br><span class="line">        lcdbuf[i] = bmpbuf[<span class="number">0</span> + i * <span class="number">3</span>] &lt;&lt; <span class="number">0</span> | bmpbuf[<span class="number">1</span> + i * <span class="number">3</span>] &lt;&lt; <span class="number">8</span> | bmpbuf[<span class="number">2</span> + i * <span class="number">3</span>] &lt;&lt; <span class="number">16</span> | <span class="number">0x00</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> temp[<span class="number">800</span> * <span class="number">480</span>];</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">480</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">800</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[<span class="number">800</span> * y + x] = lcdbuf[<span class="number">800</span> * (<span class="number">479</span> - y) + x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">480</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">800</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            lcdbuf[<span class="number">800</span> * y + x] = temp[<span class="number">800</span> * y + x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(bmpfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">loadLittleImg</span><span class="params">(<span class="type">char</span> *path, <span class="type">int</span> lcdbuf[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> bmpfd;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> wet;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> bmpbuf[LITTLE];</span><br><span class="line"></span><br><span class="line">    bmpfd = open(path, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (bmpfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开图片失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 略过头字节</span></span><br><span class="line">    lseek(bmpfd, <span class="number">54</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、读取BMP图片的像素点</span></span><br><span class="line">    ret = read(bmpfd, bmpbuf, LITTLE);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;读取图片失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;读取的图片字节数为%d\n&quot;</span>, ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3-4字节转换</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">76</span> * <span class="number">56</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//       B                  G                  R            A</span></span><br><span class="line">        lcdbuf[i] = bmpbuf[<span class="number">0</span> + i * <span class="number">3</span>] &lt;&lt; <span class="number">0</span> | bmpbuf[<span class="number">1</span> + i * <span class="number">3</span>] &lt;&lt; <span class="number">8</span> | bmpbuf[<span class="number">2</span> + i * <span class="number">3</span>] &lt;&lt; <span class="number">16</span> | <span class="number">0x00</span> &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 翻转</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> temp[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">56</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">76</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[<span class="number">76</span> * y + x] = lcdbuf[<span class="number">76</span> * (<span class="number">55</span> - y) + x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">56</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">76</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            lcdbuf[<span class="number">76</span> * y + x] = temp[<span class="number">76</span> * y + x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(bmpfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">changeBuf</span><span class="params">(<span class="type">int</span> lcdbuf[], <span class="type">int</span> data[], <span class="type">int</span> type, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = ACCOUNT_Y;</span><br><span class="line">        <span class="keyword">switch</span> (index)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            x = X1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            x = X2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            x = X3;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            x = X4;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            x = X5;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            x = X6;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = PASSWD_Y;</span><br><span class="line">        <span class="keyword">switch</span> (index)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            x = X1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            x = X2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            x = X3;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            x = X4;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            x = X5;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            x = X6;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = y; i &lt; <span class="number">56</span> + y; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = x; j &lt; <span class="number">76</span> + x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            lcdbuf[<span class="number">800</span> * i + j] = data[(i - y) * <span class="number">76</span> + j - x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">updateGui</span><span class="params">(<span class="type">int</span> lcdbuf[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *lcdmmap;</span><br><span class="line">    <span class="type">int</span> lcdfd;</span><br><span class="line"></span><br><span class="line">    lcdfd = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (lcdfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;打开lcd失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lcdmmap = mmap(<span class="literal">NULL</span>, <span class="number">800</span> * <span class="number">480</span> * <span class="number">4</span>, PROT_EXEC | PROT_READ | PROT_WRITE, MAP_SHARED, lcdfd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (lcdmmap == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;映射失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 输出错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">480</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">800</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            lcdmmap[<span class="number">800</span> * y + x] = lcdbuf[<span class="number">800</span> * y + x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    munmap(lcdmmap, <span class="number">800</span> * <span class="number">480</span> * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// //将字体写到点阵图上node.name    iller.name for (i=0; i&lt;4; i++)  &#123;fontPrint; pos =pos-&gt;next;&#125;</span></span><br><span class="line">        fontPrint(f, &amp;bm, <span class="number">380</span>, <span class="number">0</span>, <span class="string">&quot;注册&quot;</span>, getColor(<span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>), <span class="number">0</span>); <span class="comment">// fontPrint(字体资源， 显存资源， x坐标，y坐标，显示的字符串, 字体颜色, 默认写0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fontPrint(f, &amp;bm, <span class="number">380</span>, <span class="number">0</span>, <span class="string">&quot;登陆&quot;</span>, getColor(<span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>), <span class="number">0</span>); <span class="comment">// fontPrint(字体资源， 显存资源， x坐标，y坐标，显示的字符串, 字体颜色, 默认写0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、关闭BMP和lcd</span></span><br><span class="line"></span><br><span class="line">    close(lcdfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getKey</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">261</span> &amp;&amp; x &lt;= <span class="number">579</span> &amp;&amp; y &gt;= <span class="number">241</span> &amp;&amp; y &lt;= <span class="number">419</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">501</span> &amp;&amp; x &lt;= <span class="number">579</span> &amp;&amp; y &gt;= <span class="number">301</span> &amp;&amp; y &lt;= <span class="number">359</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K0;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">261</span> &amp;&amp; x &lt;= <span class="number">339</span> &amp;&amp; y &gt;= <span class="number">241</span> &amp;&amp; y &lt;= <span class="number">299</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">341</span> &amp;&amp; x &lt;= <span class="number">419</span> &amp;&amp; y &gt;= <span class="number">241</span> &amp;&amp; y &lt;= <span class="number">299</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">421</span> &amp;&amp; x &lt;= <span class="number">499</span> &amp;&amp; y &gt;= <span class="number">241</span> &amp;&amp; y &lt;= <span class="number">299</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">261</span> &amp;&amp; x &lt;= <span class="number">339</span> &amp;&amp; y &gt;= <span class="number">301</span> &amp;&amp; y &lt;= <span class="number">359</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K4;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">341</span> &amp;&amp; x &lt;= <span class="number">419</span> &amp;&amp; y &gt;= <span class="number">301</span> &amp;&amp; y &lt;= <span class="number">359</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K5;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">421</span> &amp;&amp; x &lt;= <span class="number">499</span> &amp;&amp; y &gt;= <span class="number">301</span> &amp;&amp; y &lt;= <span class="number">359</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K6;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">261</span> &amp;&amp; x &lt;= <span class="number">339</span> &amp;&amp; y &gt;= <span class="number">361</span> &amp;&amp; y &lt;= <span class="number">419</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K7;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">341</span> &amp;&amp; x &lt;= <span class="number">419</span> &amp;&amp; y &gt;= <span class="number">361</span> &amp;&amp; y &lt;= <span class="number">419</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K8;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">421</span> &amp;&amp; x &lt;= <span class="number">499</span> &amp;&amp; y &gt;= <span class="number">361</span> &amp;&amp; y &lt;= <span class="number">419</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K9;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">501</span> &amp;&amp; x &lt;= <span class="number">579</span> &amp;&amp; y &gt;= <span class="number">241</span> &amp;&amp; y &lt;= <span class="number">299</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K_DELETE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= <span class="number">501</span> &amp;&amp; x &lt;= <span class="number">579</span> &amp;&amp; y &gt;= <span class="number">361</span> &amp;&amp; y &lt;= <span class="number">419</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> K_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">int</span> lcdbuf[], <span class="type">int</span> type, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = ACCOUNT_Y;</span><br><span class="line">        <span class="keyword">switch</span> (index)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            x = X1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            x = X2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            x = X3;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            x = X4;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            x = X5;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            x = X6;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = PASSWD_Y;</span><br><span class="line">        <span class="keyword">switch</span> (index)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            x = X1;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            x = X2;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            x = X3;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            x = X4;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            x = X5;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            x = X6;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = y; i &lt; <span class="number">56</span> + y; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = x; j &lt; <span class="number">76</span> + x; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// lcdbuf[800 * i + j] = data[(i - y) * 76 + j - x];</span></span><br><span class="line">            lcdbuf[<span class="number">800</span> * i + j] = <span class="number">0xFFFFFF</span>; <span class="comment">// 白色</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">login</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    FILE *login_fd;</span><br><span class="line"></span><br><span class="line">    login_fd = fopen(<span class="string">&quot;login.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (login_fd == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;没有login.txt文件，用户未注册\n&quot;</span>);</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fb_addr = init_framebuffer_device(&amp;fb_fd); <span class="comment">// 初始化显存设备</span></span><br><span class="line">    f = fontLoad(<span class="string">&quot;/usr/share/fonts/DroidSansFallback.ttf&quot;</span>);</span><br><span class="line"></span><br><span class="line">    fontSetSize(f, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    bm.height = <span class="number">480</span>;</span><br><span class="line">    bm.width = <span class="number">800</span>;</span><br><span class="line">    bm.byteperpixel = <span class="number">4</span>;</span><br><span class="line">    bm.<span class="built_in">map</span> = (<span class="type">void</span> *)fb_addr; <span class="comment">// 指定画板是显存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lcdbuf_main[<span class="number">800</span> * <span class="number">480</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf_dl[<span class="number">800</span> * <span class="number">480</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf_lo[<span class="number">800</span> * <span class="number">480</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf_sb[<span class="number">800</span> * <span class="number">480</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf0[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf1[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf2[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf3[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf4[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf5[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf6[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf7[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf8[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbuf9[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> lcdbufm[<span class="number">76</span> * <span class="number">56</span>];</span><br><span class="line">    <span class="type">int</span> key_status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> accountNum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> passwdNum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> account[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> passwd[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> inputAccount[<span class="number">10</span>];</span><br><span class="line">    <span class="type">char</span> inputPasswd[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> input_status = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> login_Account[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">memset</span>(account, <span class="number">0</span>, <span class="keyword">sizeof</span>(account));</span><br><span class="line">    <span class="built_in">memset</span>(passwd, <span class="number">0</span>, <span class="keyword">sizeof</span>(passwd));</span><br><span class="line">    <span class="built_in">memset</span>(inputAccount, <span class="number">0</span>, <span class="keyword">sizeof</span>(inputAccount));</span><br><span class="line">    <span class="built_in">memset</span>(inputPasswd, <span class="number">0</span>, <span class="keyword">sizeof</span>(inputPasswd));</span><br><span class="line"></span><br><span class="line">    loadBigImg(<span class="string">&quot;../login_img/main.bmp&quot;</span>, lcdbuf_main);</span><br><span class="line">    loadBigImg(<span class="string">&quot;../login_img/dl.bmp&quot;</span>, lcdbuf_dl);</span><br><span class="line">    loadBigImg(<span class="string">&quot;../login_img/sb.bmp&quot;</span>, lcdbuf_sb);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/0.bmp&quot;</span>, lcdbuf0);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/1.bmp&quot;</span>, lcdbuf1);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/2.bmp&quot;</span>, lcdbuf2);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/3.bmp&quot;</span>, lcdbuf3);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/4.bmp&quot;</span>, lcdbuf4);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/5.bmp&quot;</span>, lcdbuf5);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/6.bmp&quot;</span>, lcdbuf6);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/7.bmp&quot;</span>, lcdbuf7);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/8.bmp&quot;</span>, lcdbuf8);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/9.bmp&quot;</span>, lcdbuf9);</span><br><span class="line">    loadLittleImg(<span class="string">&quot;../login_img/m.bmp&quot;</span>, lcdbufm);</span><br><span class="line">    loadBigImg(<span class="string">&quot;../login_img/lo.bmp&quot;</span>, lcdbuf_lo);</span><br><span class="line">login_begin:</span><br><span class="line">    updateGui(lcdbuf_main);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// //将字体写到点阵图上node.name    iller.name for (i=0; i&lt;4; i++)  &#123;fontPrint; pos =pos-&gt;next;&#125;</span></span><br><span class="line">        fontPrint(f, &amp;bm, <span class="number">380</span>, <span class="number">0</span>, <span class="string">&quot;注册&quot;</span>, getColor(<span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>), <span class="number">0</span>); <span class="comment">// fontPrint(字体资源， 显存资源， x坐标，y坐标，显示的字符串, 字体颜色, 默认写0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fontPrint(f, &amp;bm, <span class="number">380</span>, <span class="number">0</span>, <span class="string">&quot;登陆&quot;</span>, getColor(<span class="number">0</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">30</span>), <span class="number">0</span>); <span class="comment">// fontPrint(字体资源， 显存资源， x坐标，y坐标，显示的字符串, 字体颜色, 默认写0);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        getPoint(&amp;x, &amp;y, &amp;key_status);</span><br><span class="line">        <span class="keyword">if</span> (key_status == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;x = %d  y = %d\n&quot;</span>, x, y);</span><br><span class="line">            <span class="keyword">switch</span> (getKey(x, y))</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> K0:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了0\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf0, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = K0;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf0, <span class="number">0</span>, input_status);</span><br><span class="line"></span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K1:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了1\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf1, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf1, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K2:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了2\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf2, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf2, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K3:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了3\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf3, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf3, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;3&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K4:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了4\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf4, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf4, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K5:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了5\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf5, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf5, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;5&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K6:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了6\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf6, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf6, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;6&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K7:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了7\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf7, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf7, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;7&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K8:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了8\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf8, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf8, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K9:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了9\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;输入已满\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">6</span> &amp;&amp; input_status &lt;= <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf9, <span class="number">1</span>, input_status - <span class="number">6</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputPasswd[input_status - <span class="number">7</span>] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">0</span> &amp;&amp; input_status &lt;= <span class="number">6</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    changeBuf(lcdbuf_main, lcdbuf9, <span class="number">0</span>, input_status);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    inputAccount[input_status - <span class="number">1</span>] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                    input_status++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K_DELETE:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了Delete\n&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (input_status &gt; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (input_status &gt; <span class="number">1</span> &amp;&amp; input_status &lt;= <span class="number">7</span>)</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        delete (lcdbuf_main, <span class="number">0</span>, input_status - <span class="number">1</span>);</span><br><span class="line">                        updateGui(lcdbuf_main);</span><br><span class="line">                        input_status--;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;input_status %d\n&quot;</span>, input_status);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (input_status &gt; <span class="number">7</span> &amp;&amp; input_status &lt;= <span class="number">13</span>)</span><br><span class="line">                    &#123;</span><br><span class="line"></span><br><span class="line">                        delete (lcdbuf_main, <span class="number">1</span>, input_status - <span class="number">7</span>);</span><br><span class="line">                        updateGui(lcdbuf_main);</span><br><span class="line">                        input_status--;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;input_status %d\n&quot;</span>, input_status);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> K_OK:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;您按下了OK\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;inputAccount %s\n&quot;</span>, inputAccount);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;inputPasswd %s\n&quot;</span>, inputPasswd);</span><br><span class="line">                <span class="keyword">if</span> (input_status != <span class="number">13</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;haha\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    login_fd = fopen(<span class="string">&quot;login.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">                    fgets(login_Account, <span class="number">50</span>, login_fd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, login_Account);</span><br><span class="line">                    <span class="type">char</span> *str1 = <span class="built_in">strstr</span>(login_Account, <span class="string">&quot;account&quot;</span>);</span><br><span class="line">                    <span class="type">char</span> *str2 = <span class="built_in">strstr</span>(login_Account, <span class="string">&quot;password&quot;</span>);</span><br><span class="line">                    str1 = str1 + <span class="number">8</span>;</span><br><span class="line">                    str2 = str2 + <span class="number">9</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;str1 %s\n&quot;</span>, str1);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;str2 %s\n&quot;</span>, str2);</span><br><span class="line">                    <span class="built_in">strncpy</span>(account, str1, <span class="number">6</span>);</span><br><span class="line">                    <span class="built_in">strncpy</span>(passwd, str2, <span class="number">6</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;account %s\n&quot;</span>, account);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;password %s\n&quot;</span>, passwd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;inputAccount %s\n&quot;</span>, inputAccount);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;inputPasswd %s\n&quot;</span>, inputPasswd);</span><br><span class="line">                    fclose(login_fd);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(account, inputAccount) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>(passwd, inputPasswd) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;登录成功！！\n&quot;</span>);</span><br><span class="line">                        updateGui(lcdbuf_dl);</span><br><span class="line">                        sleep(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;登录失败！！\n&quot;</span>);</span><br><span class="line">                        updateGui(lcdbuf_sb);</span><br><span class="line">                        sleep(<span class="number">5</span>);</span><br><span class="line">                        updateGui(lcdbuf_main);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    login_fd = fopen(<span class="string">&quot;login.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (login_fd == <span class="literal">NULL</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        perror(<span class="string">&quot;创建文件失败\n&quot;</span>);</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;account:%s password:%s\n&quot;</span>, inputAccount, inputPasswd);</span><br><span class="line">                    <span class="built_in">fprintf</span>(login_fd, <span class="string">&quot;account:%s password:%s\n&quot;</span>, inputAccount, inputPasswd);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;注册成功！\n&quot;</span>);</span><br><span class="line">                    updateGui(lcdbuf_lo);</span><br><span class="line">                    sleep(<span class="number">1</span>);</span><br><span class="line">                    updateGui(lcdbuf_main);</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    fclose(login_fd);</span><br><span class="line">                    <span class="keyword">goto</span> login_begin;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    destroy_framebuffer_device(fb_fd, fb_addr); <span class="comment">// 销毁显存设备</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-音乐播放模块"><a href="#3-2-音乐播放模块" class="headerlink" title="3.2 音乐播放模块"></a>3.2 音乐播放模块</h3><p>音乐播放模块实现音乐播放、暂停、继续、上一首、下一首等功能，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;framebuffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;touchscreen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;font.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linklist_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ts_fd;             <span class="comment">// 触摸屏文件描述符</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> fb_fd;             <span class="comment">// 帧缓冲区文件描述符</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> *fb_addr; <span class="comment">// 帧缓冲区地址</span></span><br><span class="line"><span class="type">int</span> play_flag = <span class="number">0</span>, first_flag = <span class="number">0</span>;<span class="comment">//播放标志位，第一次播放标志位</span></span><br><span class="line">Node *node_mp3;<span class="comment">//mp3链表头指针</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化音乐播放器界面函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_music</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/music_bg.jpg&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/exit.jpg&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/pre.jpg&quot;</span>, <span class="number">150</span>, <span class="number">390</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/callback.jpg&quot;</span>, <span class="number">278</span>, <span class="number">390</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/stop.jpg&quot;</span>, <span class="number">390</span>, <span class="number">390</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/quick_next.jpg&quot;</span>, <span class="number">482</span>, <span class="number">390</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/next.jpg&quot;</span>, <span class="number">602</span>, <span class="number">390</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取音乐文件路径</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_music_url</span><span class="params">(Linklist *linklist_mp3)</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dirp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">direntp</span>;</span></span><br><span class="line">    <span class="comment">// 添加寻找路径</span></span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;../music&quot;</span>;</span><br><span class="line">    <span class="comment">// 存储图片路径</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> music_number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((dirp = opendir(path)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录 %s 失败: %s\n&quot;</span>, path, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((direntp = readdir(dirp)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 给文件或目录名添加路径:argv[1]+&quot;/&quot;+direntp-&gt;d_name */</span></span><br><span class="line">        <span class="type">char</span> dirbuf[<span class="number">512</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dirbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(dirbuf));</span><br><span class="line">        <span class="built_in">strcpy</span>(dirbuf, path);</span><br><span class="line">        <span class="built_in">strcat</span>(dirbuf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(dirbuf, direntp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(dirbuf, <span class="string">&quot;mp3&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The file path is:%s\n&quot;</span>, dirbuf);</span><br><span class="line">            insert_linklist(linklist_mp3, dirbuf);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dirp);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停音乐</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">stop_music</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/play.jpg&quot;</span>, <span class="number">240</span> + <span class="number">150</span>, <span class="number">390</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;暂停\n&quot;</span>);</span><br><span class="line">    play_flag = <span class="number">1</span>;</span><br><span class="line">    system(<span class="string">&quot;killall -STOP madplay &amp;&quot;</span>); <span class="comment">// 利用system函数调用killall命令将madplay终止掉</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音乐已被终止\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//播放音乐</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">play_music</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> command[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;播放\n&quot;</span>);</span><br><span class="line">    display_jpeg_picture_to_framebuffer(<span class="string">&quot;../music_img/stop.jpg&quot;</span>, <span class="number">240</span> + <span class="number">150</span>, <span class="number">390</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    play_flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (first_flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(command, <span class="string">&quot;madplay %s  -a -30 &amp;&quot;</span>, node_mp3-&gt;data);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, command);</span><br><span class="line">        system(command);</span><br><span class="line">        <span class="comment">// 把首次播放标志置1</span></span><br><span class="line">        first_flag = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;开始播放\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则就恢复播放</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;killall -CONT madplay &amp;&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;恢复播放\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// system(&quot;killall -9 madplay&quot;);//利用system函数调用killall命令将madplay终止掉</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;音乐已播放\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上一首</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prev_music</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;killall -9 madplay&quot;</span>);</span><br><span class="line">    first_flag = <span class="number">0</span>;</span><br><span class="line">    node_mp3 = node_mp3-&gt;prev;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, node_mp3-&gt;data);</span><br><span class="line">    <span class="type">char</span> command[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(command, <span class="string">&quot;madplay %s -a -30 &amp;&quot;</span>, node_mp3-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, command);</span><br><span class="line">    system(command);</span><br><span class="line">    <span class="comment">// 把首次播放标志置1</span></span><br><span class="line">    first_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始播放\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;上一首\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下一首</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">next_music</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;killall -9 madplay&quot;</span>);</span><br><span class="line">    first_flag = <span class="number">0</span>;</span><br><span class="line">    node_mp3 = node_mp3-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, node_mp3-&gt;data);</span><br><span class="line">    <span class="type">char</span> command[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sprintf</span>(command, <span class="string">&quot;madplay %s -a -30 &amp;&quot;</span>, node_mp3-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, command);</span><br><span class="line">    system(command);</span><br><span class="line">    <span class="comment">// 把首次播放标志置1</span></span><br><span class="line">    first_flag = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;下一首\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">music</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    init_music(); <span class="comment">// 初始化音乐播放器界面</span></span><br><span class="line">    Linklist *linklist_mp3 = create_linklist(); <span class="comment">// 创建链表</span></span><br><span class="line">    len = get_music_url(linklist_mp3);          <span class="comment">// 获取音乐文件路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;music_num:%d\n&quot;</span>, len);</span><br><span class="line">    <span class="type">int</span> ts_x, ts_y;<span class="comment">//触摸屏坐标</span></span><br><span class="line">    <span class="type">int</span> press_x, press_y;<span class="comment">//触摸屏按下坐标</span></span><br><span class="line">    <span class="type">int</span> release_x, release_y;<span class="comment">//触摸屏松开坐标</span></span><br><span class="line">    ts_fd = init_touchscreen_device(); <span class="comment">// 初始化触摸屏设备</span></span><br><span class="line">    <span class="type">int</span> status;<span class="comment">//触摸屏状态</span></span><br><span class="line">    node_mp3 = linklist_mp3-&gt;first;<span class="comment">//音乐</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        status = get_touchscreen_status(ts_fd, &amp;ts_x, &amp;ts_y);</span><br><span class="line">        <span class="keyword">switch</span> (status)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> TOUCH_COORDINATE_STATUS:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TOUCH_PRESS_STATUS:</span><br><span class="line">            <span class="comment">// 记录按下的触摸屏坐标</span></span><br><span class="line">            press_x = ts_x;</span><br><span class="line">            press_y = ts_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TOUCH_RELEASE_STATUS:</span><br><span class="line">            <span class="comment">// 记录松开的触摸屏坐标</span></span><br><span class="line">            release_x = ts_x;</span><br><span class="line">            release_y = ts_y;</span><br><span class="line">            <span class="comment">// 判断按键范围//</span></span><br><span class="line">            <span class="comment">// 暂停播放音乐按键</span></span><br><span class="line">            <span class="keyword">if</span> (press_x &gt;= <span class="number">390</span> &amp;&amp; release_x &lt;= <span class="number">390</span> + <span class="number">92</span> &amp;&amp; press_y &gt;= <span class="number">380</span> &amp;&amp; release_y &lt;= <span class="number">380</span> + <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 暂停音乐</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (play_flag == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    stop_music();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 播放音乐按键</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    play_music();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回退</span></span><br><span class="line">            <span class="keyword">if</span> (press_x &gt;= <span class="number">278</span> &amp;&amp; release_x &lt;= <span class="number">278</span> + <span class="number">112</span> &amp;&amp; press_y &gt;= <span class="number">380</span> &amp;&amp; release_y &lt;= <span class="number">380</span> + <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;回退\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 快进</span></span><br><span class="line">            <span class="keyword">if</span> (press_x &gt;= <span class="number">482</span> &amp;&amp; release_x &lt;= <span class="number">482</span> + <span class="number">120</span> &amp;&amp; press_y &gt;= <span class="number">380</span> &amp;&amp; release_y &lt;= <span class="number">380</span> + <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;快进\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 退出音乐播放器界面</span></span><br><span class="line">            <span class="keyword">if</span> (press_x &gt;= <span class="number">0</span> &amp;&amp; release_x &lt;= <span class="number">80</span> &amp;&amp; press_y &gt;= <span class="number">0</span> &amp;&amp; release_y &lt;= <span class="number">50</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;返回\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上一首播放</span></span><br><span class="line">            <span class="keyword">if</span> (press_x &gt;= <span class="number">150</span> &amp;&amp; release_x &lt;= <span class="number">150</span> + <span class="number">128</span> &amp;&amp; press_y &gt;= <span class="number">380</span> &amp;&amp; release_y &lt;= <span class="number">380</span> + <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 prev_music();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下一首播放</span></span><br><span class="line">            <span class="keyword">if</span> (press_x &gt;= <span class="number">602</span> &amp;&amp; release_x &lt;= <span class="number">602</span> + <span class="number">120</span> &amp;&amp; press_y &gt;= <span class="number">380</span> &amp;&amp; release_y &lt;= <span class="number">380</span> + <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                 next_music();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3-游戏模块"><a href="#3-3-游戏模块" class="headerlink" title="3.3 游戏模块"></a>3.3 游戏模块</h3><p>游戏模块实现2048、扫雷等游戏功能，具体实现如下：</p><h3 id="3-4-图片显示模块"><a href="#3-4-图片显示模块" class="headerlink" title="3.4 图片显示模块"></a>3.4 图片显示模块</h3><p>图片显示模块实现图片显示、切换等功能，具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;framebuffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;touchscreen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bmp.h&gt;</span>            <span class="comment">// bmp图片操作头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linklist_file.h&gt;</span>    <span class="comment">// 链表文件操作头文件</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ts_fd;             <span class="comment">// 触摸屏文件描述符</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> fb_fd;             <span class="comment">// 帧缓冲区文件描述符</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> *fb_addr; <span class="comment">// 帧缓冲区地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myclear</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">0</span>; y &lt; <span class="number">480</span>; y++)</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">0</span>; x &lt; <span class="number">800</span>; x++)</span><br><span class="line">            display_point_to_framebuffer(x, y, <span class="number">0</span>, fb_addr); <span class="comment">// 清屏</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">get_picture_url</span><span class="params">(Linklist *jpg_pic)</span></span><br><span class="line">&#123;</span><br><span class="line">    DIR *dirp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">direntp</span>;</span></span><br><span class="line">    <span class="comment">// 添加寻找路径</span></span><br><span class="line">    <span class="type">char</span> *path = <span class="string">&quot;../crame&quot;</span>;</span><br><span class="line">    <span class="comment">// 存储图片路径</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> music_number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((dirp = opendir(path)) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开目录 %s 失败: %s\n&quot;</span>, path, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((direntp = readdir(dirp)) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 给文件或目录名添加路径:argv[1]+&quot;/&quot;+direntp-&gt;d_name */</span></span><br><span class="line">        <span class="type">char</span> dirbuf[<span class="number">512</span>];</span><br><span class="line">        <span class="built_in">memset</span>(dirbuf, <span class="number">0</span>, <span class="keyword">sizeof</span>(dirbuf));</span><br><span class="line">        <span class="built_in">strcpy</span>(dirbuf, path);</span><br><span class="line">        <span class="built_in">strcat</span>(dirbuf, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="built_in">strcat</span>(dirbuf, direntp-&gt;d_name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(dirbuf, <span class="string">&quot;bmp&quot;</span>) || <span class="built_in">strstr</span>(dirbuf, <span class="string">&quot;jpg&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;The file path is:%s\n&quot;</span>, dirbuf);</span><br><span class="line">            insert_linklist(jpg_pic, dirbuf);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closedir(dirp);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">crame</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    myclear(); <span class="comment">// 清屏</span></span><br><span class="line">    <span class="type">int</span> pic_len;</span><br><span class="line">    Linklist *jpg_pic = create_linklist();     <span class="comment">// 创建图片链表</span></span><br><span class="line">    pic_len = get_picture_url(jpg_pic); <span class="comment">// 获取图片文件路径</span></span><br><span class="line">    Node *node_pic = jpg_pic-&gt;first;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The number of pic is:%d\n&quot;</span>, pic_len); <span class="comment">// 输出图片文件数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控触摸屏</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> ts_x, ts_y;</span><br><span class="line">    <span class="type">int</span> press_x, press_y;</span><br><span class="line">    <span class="type">int</span> release_x, release_y;</span><br><span class="line">    ts_fd = init_touchscreen_device(); <span class="comment">// 初始化触摸屏设备</span></span><br><span class="line">    display_jpeg_picture_to_framebuffer((<span class="type">char</span> *)node_pic-&gt;data, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        status = get_touchscreen_status(ts_fd, &amp;ts_x, &amp;ts_y);</span><br><span class="line">        <span class="keyword">switch</span> (status)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TOUCH_PRESS_STATUS:</span><br><span class="line">            <span class="comment">// printf(&quot;触摸屏被按下x=%d, y=%d\n&quot;, x, y);</span></span><br><span class="line">            <span class="comment">// 记录按下的触摸屏坐标</span></span><br><span class="line">            press_x = ts_x;</span><br><span class="line">            press_y = ts_y;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TOUCH_RELEASE_STATUS:</span><br><span class="line">            <span class="comment">// printf(&quot;触摸屏被松开x=%d, y=%d\n&quot;, ts_x, ts_x);</span></span><br><span class="line">            release_x = ts_x;</span><br><span class="line">            release_y = ts_y;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(release_x - press_x) &lt;= <span class="number">30</span> &amp;&amp; <span class="built_in">abs</span>(release_y - press_y) &lt;= <span class="number">30</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strstr</span>(node_pic-&gt;data, <span class="string">&quot;jpg&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    display_jpeg_picture_to_framebuffer((<span class="type">char</span> *)node_pic-&gt;data, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1.5</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断滑动方向</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(release_x - press_x) &gt; <span class="built_in">abs</span>(release_y - press_y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (release_x - press_x &gt; <span class="number">30</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;右滑动\n&quot;</span>);</span><br><span class="line">                    </span><br><span class="line">                    node_pic = node_pic-&gt;prev;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strstr</span>(node_pic-&gt;data, <span class="string">&quot;bmp&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        pic_circular_spread(node_pic-&gt;data, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        myclear();</span><br><span class="line">                        display_jpeg_picture_to_framebuffer((<span class="type">char</span> *)node_pic-&gt;data, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (press_x - release_x &gt; <span class="number">30</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;左滑动\n&quot;</span>);</span><br><span class="line">                    node_pic = node_pic-&gt;next;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strstr</span>(node_pic-&gt;data, <span class="string">&quot;bmp&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        pic_circular_spread(node_pic-&gt;data, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        myclear();</span><br><span class="line">                        display_jpeg_picture_to_framebuffer((<span class="type">char</span> *)node_pic-&gt;data, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (release_y - press_y &gt; <span class="number">30</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;下滑动\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (press_y - release_y &gt; <span class="number">30</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;上滑动\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strstr</span>(node_pic-&gt;data, <span class="string">&quot;jpg&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        myclear();</span><br><span class="line">                        display_jpeg_picture_to_framebuffer((<span class="type">char</span> *)node_pic-&gt;data, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-主界面模块"><a href="#3-5-主界面模块" class="headerlink" title="3.5 主界面模块"></a>3.5 主界面模块</h3><p>主界面模块实现主界面显示、菜单选择等功能，具体实现如下：</p><pre><code>    主界面：显示菜单，用户选择菜单项，进入相应功能。</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;framebuffer.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;touchscreen.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;font.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linklist_file.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;login.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;music.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;crame.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> ts_fd;             <span class="comment">// 触摸屏文件描述符</span></span><br><span class="line"><span class="type">int</span> fb_fd;             <span class="comment">// 帧缓冲区文件描述符</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *fb_addr; <span class="comment">// 帧缓冲区地址</span></span><br><span class="line">bitmap bm;             <span class="comment">// 位图结构体</span></span><br><span class="line">font *f;               <span class="comment">// 字体结构体</span></span><br><span class="line"><span class="comment">// 全局变量用于指示线程是否应该停止</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> should_stop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按键控件</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">button</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> hight;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> color;       <span class="comment">// 没有点击的颜色</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> press_color; <span class="comment">// 点击的颜色</span></span><br><span class="line">    <span class="type">void</span> (*handler)(<span class="type">void</span> *);  <span class="comment">// 按键的响应函数指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">void</span> *(*start_routine)(<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">button</span> *<span class="title">bt</span>[4];</span> <span class="comment">// 按钮结构体数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">clear_time_display</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_addr, <span class="type">unsigned</span> <span class="type">int</span> bg_color)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (y = <span class="number">18</span>; y &lt; <span class="number">18</span> + <span class="number">30</span>; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = <span class="number">570</span>; x &lt; <span class="number">570</span> + <span class="number">220</span>; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            display_point_to_framebuffer(x, y, bg_color, fb_addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">display_time_thread</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">time_t</span> t;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">64</span>];</span><br><span class="line">    font *<span class="type">f_t</span> = fontLoad(<span class="string">&quot;/usr/share/fonts/DroidSansFallback.ttf&quot;</span>);</span><br><span class="line">    fontSetSize(<span class="type">f_t</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>); <span class="comment">// 每秒更新一次时间</span></span><br><span class="line">        <span class="keyword">if</span> (should_stop)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">        time(&amp;t);</span><br><span class="line">        tmp = localtime(&amp;t);</span><br><span class="line"></span><br><span class="line">        strftime(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, tmp);</span><br><span class="line"></span><br><span class="line">        clear_time_display(fb_addr, <span class="number">0x005a9bd5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显示新时间</span></span><br><span class="line">        fontPrint(<span class="type">f_t</span>, &amp;bm, <span class="number">580</span>, <span class="number">20</span>, buffer, getColor(<span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化桌面</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_Desktop</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> *fb_addr, <span class="keyword">struct</span> button *bt[], <span class="type">char</span> *url[<span class="number">4</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> reval;</span><br><span class="line">    should_stop = <span class="number">0</span>;</span><br><span class="line">    reval = display_jpeg_picture_to_framebuffer(<span class="string">&quot;../img/1.jpg&quot;</span>, <span class="number">0</span>, <span class="number">0</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (reval == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;display picture success\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    reval = display_jpeg_picture_to_framebuffer(<span class="string">&quot;../img/2.jpg&quot;</span>, <span class="number">0</span>, <span class="number">415</span>, fb_addr, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (reval == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;display picture success\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        display_jpeg_picture_to_framebuffer(url[i], bt[i]-&gt;x, bt[i]-&gt;y, fb_addr, <span class="number">1.2</span>);</span><br><span class="line">    <span class="comment">//  //打开字体</span></span><br><span class="line">    font *f = fontLoad(<span class="string">&quot;/usr/share/fonts/DroidSansFallback.ttf&quot;</span>);</span><br><span class="line">    <span class="comment">// //字体大小的设置</span></span><br><span class="line">    fontSetSize(f, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    bm.height = <span class="number">480</span>;</span><br><span class="line">    bm.width = <span class="number">800</span>;</span><br><span class="line">    bm.byteperpixel = <span class="number">4</span>;</span><br><span class="line">    bm.<span class="built_in">map</span> = (<span class="type">void</span> *)fb_addr; <span class="comment">// 指定画板是显存地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// //将字体写到点阵图上node.name    iller.name for (i=0; i&lt;4; i++)  &#123;fontPrint; pos =pos-&gt;next;&#125;</span></span><br><span class="line">    fontPrint(f, &amp;bm, <span class="number">15</span>, <span class="number">60</span>, <span class="string">&quot;2048&quot;</span>,  getColor(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">0</span>); <span class="comment">// fontPrint(字体资源， 显存资源， x坐标，y坐标，显示的字符串, 字体颜色, 默认写0);</span></span><br><span class="line">    fontPrint(f, &amp;bm, <span class="number">110</span>, <span class="number">60</span>, <span class="string">&quot;音乐&quot;</span>, getColor(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">0</span>);</span><br><span class="line">    fontPrint(f, &amp;bm, <span class="number">175</span>, <span class="number">60</span>, <span class="string">&quot;相册&quot;</span>, getColor(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">0</span>);</span><br><span class="line">    fontPrint(f, &amp;bm, <span class="number">245</span>, <span class="number">60</span>, <span class="string">&quot;扫雷&quot;</span>, getColor(<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> time_pthread;</span><br><span class="line">    <span class="keyword">if</span> (pthread_create(&amp;time_pthread, <span class="literal">NULL</span>, display_time_thread, (<span class="type">void</span> *)fb_addr) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;创建时间线程失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fontUnload(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2048游戏的按键事件处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">game1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> reval;</span><br><span class="line">    reval = system(<span class="string">&quot;cd ../2048game/src &amp;&amp; ./2048&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pid_t</span> pid = getpid(); <span class="comment">// 调用 getpid() 获取当前进程的 PID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The Process ID (PID) is: %d\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  扫雷游戏的按键事件处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">game2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> reval;</span><br><span class="line">    reval = system(<span class="string">&quot;cd ../saolei &amp;&amp; ./saolei&quot;</span>);</span><br><span class="line">    <span class="type">pid_t</span> pid = getpid(); <span class="comment">// 调用 getpid() 获取当前进程的 PID</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The Process ID (PID) is: %d\n&quot;</span>, pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示按键</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_button</span><span class="params">(<span class="keyword">struct</span> button *bt, <span class="type">unsigned</span> <span class="type">int</span> *fb_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="comment">// 显示一个按键</span></span><br><span class="line">    <span class="keyword">for</span> (y = bt-&gt;y; y &lt; bt-&gt;y + bt-&gt;hight; y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (x = bt-&gt;x; x &lt; bt-&gt;x + bt-&gt;width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            display_point_to_framebuffer(x, y, bt-&gt;color, fb_addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 申请按键</span></span><br><span class="line"><span class="keyword">struct</span> button *<span class="title function_">request_button</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> width, <span class="type">int</span> hight, <span class="type">unsigned</span> <span class="type">int</span> color, <span class="type">unsigned</span> <span class="type">int</span> pcolor, <span class="type">void</span> (*handler)(<span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">button</span> *<span class="title">bt</span>;</span></span><br><span class="line">    bt = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> button)); <span class="comment">// 申请1个按键结构体内存</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按键初始化</span></span><br><span class="line">    bt[<span class="number">0</span>].x = x;</span><br><span class="line">    bt[<span class="number">0</span>].y = y;</span><br><span class="line">    bt[<span class="number">0</span>].width = width;</span><br><span class="line">    bt[<span class="number">0</span>].hight = hight;</span><br><span class="line">    bt[<span class="number">0</span>].color = color;        <span class="comment">// 记录按下的颜色</span></span><br><span class="line">    bt[<span class="number">0</span>].press_color = pcolor; <span class="comment">// 记录松开的颜色</span></span><br><span class="line">    bt[<span class="number">0</span>].handler = handler;    <span class="comment">// 记录以后按倒这个按键之后做什么动作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 按键按下事件</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_press_button</span><span class="params">(<span class="keyword">struct</span> button *bt, <span class="type">unsigned</span> <span class="type">int</span> *fb_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="comment">// 显示一个按键</span></span><br><span class="line">    <span class="keyword">for</span> (y = bt-&gt;y; y &lt; bt-&gt;y + bt-&gt;hight; y++)</span><br><span class="line">        <span class="keyword">for</span> (x = bt-&gt;x; x &lt; bt-&gt;x + bt-&gt;width; x++)</span><br><span class="line">            display_point_to_framebuffer(x, y, bt-&gt;press_color, fb_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">init_procedure</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// system(&quot;mplayer -speed 2  ../vedio/2.mp4   -x  800  -y  480  -Zoom  -geometry 0:0   0  -quiet &quot;);</span></span><br><span class="line">    <span class="comment">//login();</span></span><br><span class="line">    bt[<span class="number">0</span>] = request_button(<span class="number">10</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0x00ff0000</span>, <span class="number">0x00ffffff</span>, game1);</span><br><span class="line">    bt[<span class="number">1</span>] = request_button(<span class="number">100</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0x0000ff00</span>, <span class="number">0x00ffffff</span>, music);</span><br><span class="line">    bt[<span class="number">2</span>] = request_button(<span class="number">170</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0x000000ff</span>, <span class="number">0x00ffffff</span>, crame);</span><br><span class="line">    bt[<span class="number">3</span>] = request_button(<span class="number">240</span>, <span class="number">0</span>, <span class="number">60</span>, <span class="number">60</span>, <span class="number">0x00ffff00</span>, <span class="number">0x00ffffff</span>, game2);</span><br><span class="line">    <span class="type">char</span> *url[<span class="number">4</span>] = &#123;<span class="string">&quot;../img/2048.jpg&quot;</span>, <span class="string">&quot;../img/kg.jpg&quot;</span>, <span class="string">&quot;../img/crame.jpg&quot;</span>, <span class="string">&quot;../img/saolei.jpg&quot;</span>&#125;;</span><br><span class="line">    fb_addr = init_framebuffer_device(&amp;fb_fd); <span class="comment">// 初始化显存设备</span></span><br><span class="line">    init_Desktop(fb_addr, bt, url);            <span class="comment">// 初始化桌面</span></span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">int</span> ts_x, ts_y;</span><br><span class="line">    <span class="type">int</span> press_x, press_y;</span><br><span class="line">    <span class="type">int</span> release_x, release_y;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ts_fd = init_touchscreen_device(); <span class="comment">// 初始化触摸屏设备</span></span><br><span class="line">    <span class="comment">// 监控触摸屏</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        status = get_touchscreen_status(ts_fd, &amp;ts_x, &amp;ts_y);</span><br><span class="line">        <span class="keyword">switch</span> (status)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> TOUCH_PRESS_STATUS:</span><br><span class="line">            <span class="comment">// 记录按下的触摸屏坐标</span></span><br><span class="line">            press_x = ts_x;</span><br><span class="line">            press_y = ts_y;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 判断是否按倒了按键范围内</span></span><br><span class="line">                <span class="keyword">if</span> (press_x &gt; bt[i]-&gt;x &amp;&amp; press_x &lt; bt[i]-&gt;x + bt[i]-&gt;width &amp;&amp; press_y &gt; bt[i]-&gt;y &amp;&amp; press_y &lt; bt[i]-&gt;y + bt[i]-&gt;hight) <span class="comment">// 判断松开的坐标是否在范围内</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 显示按下来按键内容</span></span><br><span class="line">                    display_press_button(bt[i], fb_addr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TOUCH_RELEASE_STATUS:</span><br><span class="line">            <span class="comment">// printf(&quot;触摸屏被松开x=%d, y=%d\n&quot;, ts_x, ts_x);</span></span><br><span class="line">            release_x = ts_x;</span><br><span class="line">            release_y = ts_y;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 循环显示4个按键</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (press_x &gt; bt[i]-&gt;x &amp;&amp; press_x &lt; bt[i]-&gt;x + bt[i]-&gt;width &amp;&amp; press_y &gt; bt[i]-&gt;y &amp;&amp; press_y &lt; bt[i]-&gt;y + bt[i]-&gt;hight) <span class="comment">// 判断松开的位置在是否在我们的按键范围内</span></span><br><span class="line">                &#123;</span><br><span class="line">                    display_jpeg_picture_to_framebuffer(url[i], bt[i]-&gt;x, bt[i]-&gt;y, fb_addr, <span class="number">1.2</span>); <span class="comment">// 显示按键</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断松开来的位置是否在按键范围内容</span></span><br><span class="line">                    <span class="keyword">if</span> (release_x &gt; bt[i]-&gt;x &amp;&amp; release_x &lt; bt[i]-&gt;x + bt[i]-&gt;width &amp;&amp; release_y &gt; bt[i]-&gt;y &amp;&amp; release_y &lt; bt[i]-&gt;y + bt[i]-&gt;hight) <span class="comment">// 判断松开的坐标是否在范围内</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        should_stop = <span class="number">1</span>;                <span class="comment">// 调用停止线程的函数</span></span><br><span class="line">                        bt[i]-&gt;handler(bt[i]);          <span class="comment">// 执行响应函数</span></span><br><span class="line">                        init_Desktop(fb_addr, bt, url); <span class="comment">// 重新初始化桌面</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy_procedure</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁界面</span></span><br><span class="line"></span><br><span class="line">    destroy_framebuffer_device(fb_fd, fb_addr); <span class="comment">// 销毁显存设备</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(bt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;finish %p\n&quot;</span>, fb_addr);</span><br><span class="line"></span><br><span class="line">    destroy_framebuffer_device(fb_fd, fb_addr); <span class="comment">// 销毁显存设备</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c语言 </tag>
            
            <tag> 双向循环链表 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> linuxIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux IO 编程</title>
      <link href="/2024/07/23/linux%20IO%20%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/07/23/linux%20IO%20%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="系统IO"><a href="#系统IO" class="headerlink" title="系统IO"></a>系统IO</h1><h2 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h2><p>在Linux系统语境下，文件（file）一般有两个基本含义：</p><p>狭义：指普通的文本文件，或二进制文件。包括日常所见的源代码、word文档、压缩包、图片、视频文件等等。<br>广义：除了狭义上的文件外，几乎所有可操作的设备或接口都可视为文件。包括键盘、鼠标、硬盘、串口、触摸屏、显示器等，也包括网络通讯端口、进程间通讯管道等抽象概念。</p><h3 id="Linux系统中文件的分类"><a href="#Linux系统中文件的分类" class="headerlink" title="Linux系统中文件的分类"></a>Linux系统中文件的分类</h3><p>在Linux中，文件总共被分成了7种，他们分别是：</p><p>   普通文件：存在于外部存储器中，用于存储普通数据。<br>   目录文件：用于存放目录项，是文件系统管理的重要文件类型。<br>   管道文件：一种用于进程间通信的特殊文件，也称为命名管道FIFO。<br>   套接字文件：一种用于网络间通信的特殊文件。<br>   链接文件：用于间接访问另外一个目标文件，相当于Windows快捷方式。<br>   字符设备文件：字符设备在应用层的访问接口。<br>   块设备文件：块设备在应用层的访问接口。</p><pre><code> gec@ubuntu:~$ ls -l    -rw-r--r-- 1 gec gec  345  Sep  12:38 a.zip    drwxr-xr-x 2 gec gec 1024  Sep  12:38 dir/    prw-r--r-- 1 gec gec    0  Sep  12:38 pipe     srw-r--r-- 1 gec gec    0  Sep  12:38 socket    lrw-r--r-- 1 gec gec    4  Sep  12:38 link -&gt; a.zip    crw-r--r-- 1 gec gec 1, 3  Sep  12:38 character    brw-r--r-- 1 gec gec 5, 1  Sep  12:38 block</code></pre><p>注意到，每个文件信息的最左边一栏，是各种文件类型的缩写，从上到下依次是：<br>   -（regular）普通文件<br>   d（directory）目录文件<br>   p（pipe）管道文件（命名管道）<br>   s（socket）套接字文件（Unix域&#x2F;本地域套接字）<br>   l（link）链接文件（软链接）<br>   c（character）字符设备文件<br>   b（block）块设备文件</p><h3 id="系统IO与标准IO"><a href="#系统IO与标准IO" class="headerlink" title="系统IO与标准IO"></a>系统IO与标准IO</h3><p>对文件的操作，基本上就是输入输出，因此也一般称为IO接口。在操作系统的层面上，这一组专门针对文件的IO接口就被称为系统IO；在标准库的层面上，这一组专门针对文件的IO接口就被称为标准IO<br>&lt;img src&#x3D;”&#x2F;linux_io_img&#x2F;系统io和标准io.png&gt;</img></p><p>系统IO：是众多系统调用当中专用于文件操作的一部分接口。<br>标准IO：是众多标准函数当中专用于文件操作的一部分接口。<br>从图中还能看到，标准IO实际上是对系统IO的封装，系统IO是更接近底层的接口。如果把系统IO比喻为菜市场，提供各式肉蛋菜果蔬，那么标准IO就是对这些基本原来的进一步封装，是品类和功能更加丰富的各类酒庄饭店。</p><h3 id="系统IO与标准IO的区别"><a href="#系统IO与标准IO的区别" class="headerlink" title="系统IO与标准IO的区别"></a>系统IO与标准IO的区别</h3><p>   系统IO是操作系统内核提供的接口，而标准IO是C标准库提供的接口。<br>   系统IO的接口函数名以“read”和“write”开头，而标准IO的接口函数名以“fread”和“fwrite”开头。<br>   系统IO的接口函数以“int”为返回值类型，而标准IO的接口函数以“size_t”为返回值类型。<br>   系统IO的接口函数以“文件描述符”为第一个参数，而标准IO的接口函数以“文件指针”为第一个参数。<br>   系统IO的接口函数以“文件偏移量”为第三个参数，而标准IO的接口函数以“文件指针位置”为第三个参数。<br>   系统IO的接口函数以“文件描述符”为第一个参数，而标准IO的接口函数以“文件指针”为第一个参数。<br>   系统IO的接口函数以“文件偏移量”为第三个参数，而标准IO的接口函数以“文件指针位置”为第三个参数。</p><h3 id="如何选择系统IO与标准IO"><a href="#如何选择系统IO与标准IO" class="headerlink" title="如何选择系统IO与标准IO"></a>如何选择系统IO与标准IO</h3><p>系统IO</p><p>   由操作系统直接提供的函数接口，特点是简洁，功能单一<br>   没有提供缓冲区，因此对海量数据的操作效率较低<br>   套接字Socket、设备文件的访问只能使用系统IO</p><p>标准IO</p><p>   由标准C库提供的函数接口，特点是功能丰富<br>   有提供缓冲区，因此对海量数据的操作效率高<br>   编程开发中尽量选择标准IO，但许多场合只能用系统IO</p><h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><h3 id="open-打开文件："><a href="#open-打开文件：" class="headerlink" title="open() 打开文件："></a>open() 打开文件：</h3><p><img src="/linux_io_img/open.png"></img><br>关键点：</p><p>open函数有两个版本，一个有两个参数，一个有三个参数。<br>当打开一个已存在的文件时，指定两个参数即可。<br>当创建一个新文件时，需要用第三个参数指定新文件的权限，否则新文件的权限是随机值。<br>模式flags，可以使用位或的方式，来同时指定多个模式。<br>模式flags中，O_NOCTTY主要用在后台精灵进程，阻止这些精灵进程拥有控制终端。<br>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下三种打开方式，都要求文件已存在，否则失败返回</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);   <span class="comment">// 以可读可写方式打开</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY); <span class="comment">// 以只读方式打开</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_WRONLY); <span class="comment">// 以只写方式打开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果文件不存在，则创建该文件，并设置其权限为0644</span></span><br><span class="line">    <span class="comment">// 2. 如果文件已存在，则失败返回</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR|O_CREAT|O_EXCL, <span class="number">0644</span>);   <span class="comment">// 以可读可写方式打开</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY|O_CREAT|O_EXCL, <span class="number">0644</span>); <span class="comment">// 以只读方式打开</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_WRONLY|O_CREAT|O_EXCL, <span class="number">0644</span>); <span class="comment">// 以只写方式打开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 如果文件不存在，则创建该文件，并设置其权限为0644</span></span><br><span class="line">    <span class="comment">// 2. 如果文件已存在，则清空该文件的原有内容</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR|O_CREAT|O_TRUNC, <span class="number">0644</span>);   <span class="comment">// 以可读可写方式打开</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDONLY|O_CREAT|O_TRUNC, <span class="number">0644</span>); <span class="comment">// 以只读方式打开</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC, <span class="number">0644</span>); <span class="comment">// 以只写方式打开</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下三种打开方式，都要求文件已存在，否则失败返回</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR|O_APPEND, <span class="number">0644</span>);   <span class="comment">// 以可读可写方式追加文件内容</span></span><br><span class="line">    fd = open(<span class="string">&quot;a.txt&quot;</span>, O_WRONLY|O_APPEND, <span class="number">0644</span>); <span class="comment">// 以只写方式追加文件内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p><img src="/linux_io_img/close.png"></img></p><p>close() 函数关闭文件描述符 fd。关闭一个文件描述符会释放该文件描述符占用的资源，并确保所有对文件的未决写操作都已完成。如果关闭成功，则返回 0；如果发生错误，则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><h3 id="标准库函数的错误处理"><a href="#标准库函数的错误处理" class="headerlink" title="标准库函数的错误处理"></a>标准库函数的错误处理</h3><p>在所有的库函数中，如果调用过程出错了，那么该函数除了会返回一个特定的数据来告诉用户调用失效之外，还都会去修改一个大家共同的全局错误码errno，我们可以通过这个错误码，来进一步确认究竟是什么错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> <span class="comment">// 全局错误码声明所在的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 以下两条语句效果完全一致：输出函数出错的原因</span></span><br><span class="line">        perror(<span class="string">&quot;打开a.txt失败&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;打开a.txt失败:%s\n&quot;</span>, strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点：<br>如果库函数、系统调用出错了，全局错误码 errno 会随之改变<br>如果库函数、系统调用没出错，全局错误码 errno 不会改变<br>一个库函数、系统调用出错后，若未及时处理错误码，则错误码可能会被随后的其他函数修改<br>提取错误码信息的两种办法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 使用perror()，直接输出用户信息和错误信息：</span></span><br><span class="line"><span class="keyword">if</span>(open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    perror(<span class="string">&quot;打开a.txt失败&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用strerror()，返回错误信息交给用户自行处理：</span></span><br><span class="line"><span class="keyword">if</span>(open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开a.txt失败:%s\n&quot;</span>, strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出的结果是完全一样的：<br>  打开a.txt失败: No such file or directory<br>  打开a.txt失败: No such file or directory</p><p>一般而言，perror()用起来更加方便，但有时候需要使用strerror()来输出一些更加灵活的信息，比如以上代码，如果打开文件的名字不是固定a.txt，而是取决于外部参数，那么就应该写错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;打开%s失败:%s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码输出的结果是：</p><p>  打开a.txt失败: No such file or directory<br>  打开ELF-V4.tar.gz失败: No such file or directory</p><h3 id="文件描述符本质"><a href="#文件描述符本质" class="headerlink" title="文件描述符本质"></a>文件描述符本质</h3><p>函数 open() 的返回值，是一个整型 int 数据。这个整型数据，实际上是内核中的一个称为 fd_array 的数组的下标：<br><img src="/linux_io_img/fd.png"></img><br>打开文件时，内核产生一个指向 file{} 的指针，并将该指针放入一个位于 file_struct{} 中的数组 fd_array[] 中，而该指针所在数组的下标，就被 open() 返回给用户，用户把这个数组下标称为文件描述符，如上图所示。</p><p>结论：</p><p>文件描述符从0开始，每打开一个文件，就产生一个新的文件描述符。<br>可以重复打开同一个文件，每次打开文件都会使内核产生系列结构体，并得到不同的文件描述符<br>由于系统在每个进程开始运行时，都默认打开了一次键盘、两次屏幕，因此0、1、2描述符分别代表标准输入、标准输出和标准出错三个文件（两个硬件）。<br><img src="/linux_io_img/fd2.png"></img></p><h3 id="文件的读写操作"><a href="#文件的读写操作" class="headerlink" title="文件的读写操作"></a>文件的读写操作</h3><p><img src="/linux_io_img/rw.png"></img><br>关键点：</p><p>参数count是读写字节数的愿望值，实际读写成功的字节数由返回值决定。<br>读取普通文件时，如果当读到了文件尾，read()会返回0。<br>读取管道文件时，如果管道中没有数据，read()默认会阻塞。<br>读取文件内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 将文件 a.txt 中的内容读出来，并显示到屏幕上</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    bzero(buf, <span class="number">100</span>);</span><br><span class="line">    n = read(fd, buf, <span class="number">100</span>); <span class="comment">// 每次最多读取100个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="comment">// 读完退出</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><p>写入文件内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 将键盘输入的内容，写入文件 a.txt</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">bzero(buf, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从键盘输入数据</span></span><br><span class="line">fgets(buf, <span class="number">100</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将输入的数据写入文件</span></span><br><span class="line">write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure><h3 id="文件的读写位置"><a href="#文件的读写位置" class="headerlink" title="文件的读写位置"></a>文件的读写位置</h3><p>当我们对文件进行读写操作时，系统会为我们记录操作的位置，以便于下次继续进行读写操作的时候，从适当的地方开始。</p><p>有几点需要注意：</p><p>每当open一个文件，系统就会维护一套包括文件操作位置在内的相关信息。<br>对同一个文件描述符进行读写操作时，使用的同一套文件信息，影响的是同一个位置参数。<br>对同一个文件的多个不同的文件描述符进行读写操作时，使用的是不同的文件信息，影响的是不同的位置参数，彼此互相之间独立，这往往会导致文件信息的错乱。<br>示例代码1：读写作用于同一个文件位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> <span class="comment">// ./main a.txt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读出1个字节，读完后读写操作位置是第2个字节</span></span><br><span class="line">    bzero(buf, <span class="number">100</span>);</span><br><span class="line">    read(fd, buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入2个字节，写完后读写操作位置是第4个字节</span></span><br><span class="line">    bzero(buf, <span class="number">100</span>);</span><br><span class="line">    write(fd, <span class="string">&quot;xx&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读出3个字节，读完后读写操作位置是第7个字节</span></span><br><span class="line">    bzero(buf, <span class="number">100</span>);</span><br><span class="line">    read(fd, buf, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码2：多次打开得到不同的文件描述符，各自读写操作位置独立</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> <span class="comment">// ./main a.txt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 假设文件中的原始内容是：abcdefghijk</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="type">int</span> fd2 = open(argv[<span class="number">1</span>], O_RDWR);</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读出1个字节，读完后读写操作位置是第2个字节</span></span><br><span class="line">    <span class="comment">// 此时影响的是fd1，对fd2没有影响</span></span><br><span class="line">    bzero(buf, <span class="number">100</span>);</span><br><span class="line">    read(fd1, buf, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf); <span class="comment">// 输出a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入2个字节，读完后读写操作位置是第3个字节</span></span><br><span class="line">    <span class="comment">// 与上述读操作没有关系</span></span><br><span class="line">    bzero(buf, <span class="number">100</span>);</span><br><span class="line">    write(fd2, <span class="string">&quot;xy&quot;</span>, <span class="number">2</span>); <span class="comment">// ab被覆盖，原文件变成xycdefghijk</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读出3个字节，读完后读写操作位置是第5个字节</span></span><br><span class="line">    <span class="comment">// 此时影响的是fd1，对fd2没有影响</span></span><br><span class="line">    bzero(buf, <span class="number">100</span>);</span><br><span class="line">    read(fd1, buf, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, buf); <span class="comment">// 输出ycd</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写位置的设置"><a href="#读写位置的设置" class="headerlink" title="读写位置的设置"></a>读写位置的设置</h3><p>对文件进行常规的读写操作的时候，系统会自动调整读写位置，以便于让我们顺利地顺序读写文件，但如果有需要，文件的读写位置是可以任意调整的，调整函数接口如下：<br><img src="/linux_io_img/lseek.png"></p><p>关键点：<br>lseek函数可以将文件位置调整到任意的位置，可以是已有数据的地方，也可以是未有数据的地方，假设调整到文件末尾之后的某个地方，那么文件将会形成所谓“空洞”。<br>lseek函数只能对普通文件调整文件位置，不能对管道文件调整。<br>lseek函数的返回值是调整后的文件位置距离文件开头的偏移量，单位是字节。<br>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 假设文件 a.txt 只有一行</span></span><br><span class="line">    <span class="comment">// 内容如下：</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 1234567890abcde </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取前面10个阿拉伯数字:</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    read(fd, buf, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件位置调整到&#x27;c&#x27;</span></span><br><span class="line">    lseek(fd, <span class="number">2</span>, SEEK_CUR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件位置调整到&#x27;1&#x27;</span></span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件位置调整到&#x27;a&#x27;</span></span><br><span class="line">    lseek(fd, <span class="number">-5</span>, SEEK_END);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="ioctl"><a href="#ioctl" class="headerlink" title="ioctl()"></a>ioctl()</h3><p>该函数是沟通应用层和驱动层的有力武器，底层开发人员在为硬件设备编写驱动的时候，常常将某些操作封装为一个函数，并为这些接口提供一个所谓的命令字，应用层开发者可以通过 ioctl() 函数配合命令字，非常迅捷地绕过操作系统中间层层机构直达驱动层，调用对应的功能。</p><p>从这个意义上讲，函数 ioctl() 像是一个通道，只提供函数调用路径，具体的功能由所谓命令字决定，下面是函数的接口规范说明：</p><p><img src="/linux_io_img/ioctl.png"></img></p><p>关键点：<br>    request 就是所谓的命令字。<br>    底层驱动开发者可以自定义命令字。<br>    对于某些常见的硬件设备的常见功能，系统提供了规范的命令字。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开一盏LED灯</span></span><br><span class="line">    <span class="type">int</span> led = open(<span class="string">&quot;/dev/Led&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过命令字 LEDOP 及其携带的0/1参数，控制LED灯的亮灭</span></span><br><span class="line">    <span class="comment">// 此处，LEDOP 是底层开发者自定义的命令字</span></span><br><span class="line">    ioctl(led, LEDOP, <span class="number">1</span>);</span><br><span class="line">    ioctl(led, LEDOP, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个摄像头</span></span><br><span class="line">    <span class="type">int</span> cam = open(<span class="string">&quot;/dev/video0&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过命令字 VIDIC_STREAMON 及其携带参数 vtype 启动摄像头</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">v4l2_buf_type</span> <span class="title">vtype</span>=</span> V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">    ioctl(cam, VIDIOC_STREAMON, &amp;vtype);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dup-与-dup2"><a href="#dup-与-dup2" class="headerlink" title="dup() 与 dup2()"></a>dup() 与 dup2()</h3><p>up 是英语单词 duplicate 的缩写，意即“复制”。<br>这两个函数功能类似，都是用来“复制”文件描述符，接口规范如下：<br><img src="/linux_io_img/dup.png"></img></p><p>dup()会将指定的旧文件描述符 oldfd 复制一份，并返回一个系统当前未用的最小的新文件描述符。注意，此时这新旧两个文件描述符是可以互换的，因为它们本质上指涉的是同一个文件，因此它们共享文件的读写偏移量和文件的状态标签，比如使用lseek()对新文件描述符修改文件偏移量，这个操作会同时影响旧文件描述符oldfd，再如，使用read()对新文件描述符读取文件部分内容后，可以继续对旧文件描述符读取后续内容。</p><p>dup2()跟dup()几乎完全一样，不同的地方在于前者可以指定新文件描述符的具体数值，而不局限于系统当前未用描述符的最小值。这样一来，就可以通过dup2()指定一个已用的描述符，来达到重定向文件流的作用。</p><p>实例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开文件 a.txt ，获得其文件描述符 fd1</span></span><br><span class="line">    <span class="comment">// 此处 fd1 就代表了这个文件及其配套的系统资源</span></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;a.txt&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制文件描述符 fd1，默认得到最小未用的文件描述符</span></span><br><span class="line">    dup(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制文件描述符 fd1，并指派为 100</span></span><br><span class="line">    dup2(fd1, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：<br>使用dup函数时，会自动分配当前未用的最小的文件描述符，如上述代码，由于进程默认打开了0、1、2作为标准输入输出，于是 fd1 就是3，新产生的文件描述符就是4，而 dup2 函数可以任意指定文件描述符的数值，如果指定的文件描述符已经有所指代，那么原先指代关系将会被替换。这种情况被称为“重定向”。</p><p><img src="/linux_io_img/dup2.png"></img></p><h3 id="fcntl"><a href="#fcntl" class="headerlink" title="fcntl()"></a>fcntl()</h3><p>该函数的名字是 file control 的缩写，顾名思义，它可以用来“控制”文件，与 ioctl 类似，此处的 “控制” 含义广泛，具体内容由其第二个参数命令字来决定，fcntl 的接口规范如下：<br><img src="/linux_io_img/fcntl1.png"></img></p><p>关键点：<br>fcntl 是个变参函数，前两个参数是固定的，后续的参数个数和类型取决于 cmd 的具体数值。<br>第二个参数 cmd，称为命令字。<br>命令字有很多，常用的如下:</p><p><img src="/linux_io_img/fcntl2.png"></img><br>从上表可以看出：</p><p>  1.F_DUPFD的功能与dup( )&#x2F;dup2( )类似。<br>  2.通过F_SETSL&#x2F;F_GETFL来获取和设置文件status，经常拿来设置文件的阻塞特性。<br>  3.通过F_SETOWN&#x2F;F_GETOWN来获取和设置套接字触发的信号的属主，网络编程中常见。</p><p>示例代码①：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取指定文件fd的标签属性</span></span><br><span class="line"><span class="type">int</span> flag = fcntl(fd, F_GETFL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其原有属性上，增添非阻塞属性</span></span><br><span class="line">flag |= O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, flag);</span><br></pre></td></tr></table></figure><p>示例代码②：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将套接字sockfd的信号属主设置为本进程</span></span><br><span class="line">fcntl(sockfd, F_SETOWN, getpid());</span><br></pre></td></tr></table></figure><p>在网络编程中，当一个套接字处于异步通信状态并收到一个远端的数据时，就会使得内核产生一个信号SIGIO，此时我们可以通过上述fcntl()技巧告诉内核这个信号的接收者。一般而言，接收者收到该信号后，就知道套接字上有数据等待处理了。</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap()"></a>mmap()</h3><p>该函数全称是 memory map，意为内存映射，即将某个文件与某块内存关联起来，达到通过操作这块内存来间接操作其所对应的文件的效果。</p><p><img src="/linux_io_img/mmap.png"></img><br>关键点：<br>mmap函数的flags参数是有很多的，上表只罗列了最简单的几个，详细信息请使用 man 手册进行查阅。<br>mmap函数理论上可以对任意文件进行内存映射，但通常用来映射一些比较特别的设备文件，比如液晶屏LCD。<br>注意：</p><p>在较旧的Linux内核（如2.6内核）中，可以直接使用mmap()来给LCD设备映射内存，但在较新Linux内核（如4.4内核）中，则需要经由DRM统一管理，不可直接mmap映射显存。<br>示例代码1，映射普通文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将文件file映射到内存</span></span><br><span class="line"><span class="type">char</span> *file = <span class="string">&quot;test.txt&quot;</span>;</span><br><span class="line"><span class="type">int</span> fd = open(file, O_RDWR);</span><br><span class="line"><span class="type">char</span> *mem = mmap(<span class="literal">NULL</span>, <span class="number">1024</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>注意几点：</p><p>使用 mmap 映射内存时，指定的读写权限必须是打开模式的子集。<br>映射模式为 MAP_SHARED 时，修改的内容会影响文件。<br>映射模式为 MAP_PRIVATE 时，修改的内容不会影响文件。<br>示例代码2，映射LCD设备：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打开液晶屏文件</span></span><br><span class="line">    <span class="type">int</span> lcd = open(<span class="string">&quot;/dev/fb0&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给LCD设备映射一块内存（或称显存）</span></span><br><span class="line">    <span class="type">char</span> *p = mmap(<span class="literal">NULL</span>, <span class="number">800</span>*<span class="number">480</span>*<span class="number">4</span>, PROT_WRITE,</span><br><span class="line">                   MAP_SHARED, lcd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过映射内存，将LCD屏幕的每一个像素点涂成红色</span></span><br><span class="line">    <span class="type">int</span> red = <span class="number">0x00FF0000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">800</span>*<span class="number">480</span>; i++)</span><br><span class="line">        <span class="built_in">memcpy</span>(p+i*<span class="number">4</span>, &amp;red, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解除映射</span></span><br><span class="line">    munmap(p, <span class="number">800</span>*<span class="number">480</span>*<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/linux_io_img/mmap2.png"></img></p><h1 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h1><h2 id="标准IO基本API"><a href="#标准IO基本API" class="headerlink" title="标准IO基本API"></a>标准IO基本API</h2><h3 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h3><p>不管用系统IO函数还是标准IO函数，操作文件的第一步，都是“打开（open&#x2F;fopen）”文件，需要注意：</p><p>系统IO：打开文件得到的是一个整数，称为文件描述符。<br>标准IO：打开文件得到的是一个指针，称为文件指针。<br>文件指针指向结构体 FILE，该结构体内部包含了文件描述符，如下图：<br><img src="/linux_io_img/fopen.png"></img><br>标准IO打开文件：<br><img src="/linux_io_img/fopen_agr.png"></img><br>注意：<br>  总共有6中打开模式，不能自创别的模式，比如 “rw” 是非法的。<br>标准IO关闭文件：<br><img src="/linux_io_img/fclose.png"></img><br>注意：<br>  fclose函数涉及内存释放，不可对同一个文件多次关闭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 以可读可写的方式打开文件，且要求文件必须存在</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件指针，并释放文件所关联的缓冲区内存</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件内容的读写操作"><a href="#文件内容的读写操作" class="headerlink" title="文件内容的读写操作"></a>文件内容的读写操作</h3><p>标准IO跟系统IO不同的地方在于，标准IO的读写操作提供了很多不同的函数接口，以满足不同的需求：</p><h4 id="按数据块读写文件："><a href="#按数据块读写文件：" class="headerlink" title="按数据块读写文件："></a>按数据块读写文件：</h4><p><img src="/linux_io_img/fread.png"></img><br>注意：</p><p>  以上两个函数既能处理文本，也能处理二进制文件。<br>  返回值均是成功读写的“块”数，而非字节数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件 fp 中读取5块连续的数据，每块20个字节</span></span><br><span class="line"><span class="comment">// 返回值 n 代表成功读取到的块数</span></span><br><span class="line"><span class="type">int</span> n = fread(buf, <span class="number">20</span>, <span class="number">5</span>, fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 成功读取到所需的数据块</span></span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">5</span>)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 成功读取到的数据块小于指定的块数：</span></span><br><span class="line"><span class="comment">//    这可能出错了，也可能是读到文件尾了</span></span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ferror(fp)) <span class="comment">// 出错了</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">if</span>(feof(fp)) <span class="comment">// 到文件尾了</span></span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按字节读写文本文件："><a href="#按字节读写文本文件：" class="headerlink" title="按字节读写文本文件："></a>按字节读写文本文件：</h4><p><img src="/linux_io_img/fget.png"></img><br>注意：</p><ol><li>读取到文件尾时，fgetc返回EOF，EOF是一个宏定义，代表-1</li><li>读取到文件尾时，fgets返回NULL</li><li>读取到文件尾时，fputs返回0</li><li>读取到文件尾时，fputc返回EOF</li></ol><p>关键点：<br>fgetc()与getc()功能完全一样，区别是fgetc是函数，而getc是宏。<br>fputc()与putc()功能完全一样，区别是fputc是函数，而putc是宏。<br>getchar()和putchar()只能针对键盘输入和屏幕输出，不能指定别的文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件 fp 中读取一个字符</span></span><br><span class="line"><span class="type">int</span> c = fgetc(fp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 成功读取到字符</span></span><br><span class="line"><span class="keyword">if</span>(c != EOF)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 到文件尾了</span></span><br><span class="line"><span class="keyword">if</span>(c == EOF)</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从文件 fp 中读取一行字符</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">fgets(buf, <span class="keyword">sizeof</span>(buf), fp);</span><br></pre></td></tr></table></figure><h4 id="按行读写文本文件："><a href="#按行读写文本文件：" class="headerlink" title="按行读写文本文件："></a>按行读写文本文件：</h4><p><img src="/linux_io_img/fgets.png"></img><br>注意：</p><ol><li>读取到文件尾时，fputs返回0</li><li>读取到文件尾时，fputc返回EOF</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从文件 fp 中读取一行字符</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">fgets(buf, <span class="keyword">sizeof</span>(buf), fp);</span><br></pre></td></tr></table></figure><p>关键点：</p><p>对于读操作而言，返回 EOF 意味着读操作失败，这有两种情况：<br>如果 feof(fp) 为真，此时意味着读到了文件末尾，没有数据可读了。<br>如果 ferror(fp) 为真，此时意味着遇到了错误。<br>读操作函数接口的返回值是 int ，而不是 char ，原因是当读操作失败是返回的 EOF 的数值是 -1，而 char 型数据可能无法表达 -1。<br>对于读操作失败而返回的 EOF，一般由以下函数进一步加以判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((ch=fgetc(fp)) == EOF)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(feof(fp))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;文件内容已读完.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ferror(fp))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;读操作遇到错误.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fgets() 和 gets() 都是按行读取文件数据，他们的区别是：</p><p>fgets() 可以读取指定的任意文件，而 gets() 只能从键盘读取。<br>fgets() 有内存边界判断，而 gets() 没有，因此后者是不安全的，不建议使用。<br>fgets() 在任何情形下都按原样读取数据，但 gets() 会自动去除数据末尾的 ‘\n’<br>fputs() 和 puts() 都是按行将数据写入文件，他们的区别是：</p><p>fputs() 可以将数据写入指定的任意文件，而 puts() 只能将数据输出到屏幕。<br>fputs() 在任何情形下都按原样写入数据，但 puts() 会自动给写入数据的末尾加上 ‘\n’</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以可读可写方式打开文件（且要求文件已存在）</span></span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;a.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件 a.txt 读取最多不超过99个字节的一行数据</span></span><br><span class="line">    <span class="comment">// 读取的数据按原样存储在 buf 中。</span></span><br><span class="line">    fgets(buf, <span class="number">100</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从键盘读取一行数据（可能发生内存越界，此函数不安全）</span></span><br><span class="line">    <span class="comment">// 读取的数据如果有换行符&#x27;\n&#x27;，会被自动清除掉。</span></span><br><span class="line">    gets(buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将&quot;abcd&quot;按原样写入到文件 a.txt 中</span></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;abcd&quot;</span>, fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 &quot;abcd\n&quot; 输出到屏幕</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="按行写入文本文件："><a href="#按行写入文本文件：" class="headerlink" title="按行写入文本文件："></a>按行写入文本文件：</h4><p><img src="/linux_io_img/fprintf.png"></img><br>注意：<br>   fprintf() 函数的返回值是 int 类型，表示成功写入的字符个数。<br>   fprintf( )不仅可以像printf( )一样向标准输出设备输出信息，也可以向由stream指定的任何有相应权限的文件写入数据。<br>   sprintf()和snprintf()都是向一块自定义缓冲区写入数据，不同的是后者第二个参数提供了这块缓冲区的大小，避免缓冲区溢出，因此应尽量使用后者，放弃使用前者。<br>   fscanf( )不仅可以像scanf( )一样从标准输入设备读入信息，也可以从由stream指定的任何有相应权限的文件读入数据。<br>   scanf( )从一块由s指定的自定义缓冲区中读入数据。<br>   这些函数的读写都是带格式的，格式由下表规定：<br><img src="/linux_io_img/fprintf_must.png"></img></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 将数据按格式输出到文件指针 fp 所指定的文件中去</span></span><br><span class="line">    <span class="built_in">fprintf</span>(fp, <span class="string">&quot;%d%f%s&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据按格式输出到屏幕（即文件指针stdout所指向的文件）</span></span><br><span class="line">    <span class="comment">// 以下两条语句是等价的</span></span><br><span class="line">     <span class="built_in">printf</span>(        <span class="string">&quot;%d%f%s&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%d%f%s&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据按格式输出到指定的内存 buf 中</span></span><br><span class="line">    <span class="comment">// 由于内存的容量是有限的，因此一般使用 snprintf() 来保证不发生内存越界</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">5</span>];</span><br><span class="line">     <span class="built_in">sprintf</span>(buf,    <span class="string">&quot;%d%f%s&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>, <span class="string">&quot;abc&quot;</span>); <span class="comment">// 不安全版本</span></span><br><span class="line">    <span class="built_in">snprintf</span>(buf, <span class="number">5</span>, <span class="string">&quot;%d%f%s&quot;</span>, <span class="number">100</span>, <span class="number">3.14</span>, <span class="string">&quot;abc&quot;</span>); <span class="comment">// 安全版本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从文件 fp 按格式读入到指定变量 i 中</span></span><br><span class="line">    <span class="comment">// 以下两条语句是等价的</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">scanf</span>(    <span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">    <span class="built_in">fscanf</span>(fp, <span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从内存buf中按格式读入到指定变量 i 中</span></span><br><span class="line">    <span class="type">char</span> buf[] = <span class="string">&quot;100&quot;</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件位置的获取与设定"><a href="#文件位置的获取与设定" class="headerlink" title="文件位置的获取与设定"></a>文件位置的获取与设定</h3><p>与系统IO接口类似，标准IO也可以设置文件的读写位置、获取读写位置，只不过对于标准IO而言，这两个功能是分开实现的：一个用于设置文件读写位置，另一个用于获取文件读写位置。这两个函数的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">ftell</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fseek</span><span class="params">(FILE *stream, <span class="type">long</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><p>其中，ftell()用于获取文件读写位置，fseek()用于设置文件读写位置。这两个函数的参数及返回值含义如下：</p><ul><li>stream：文件指针，指向需要进行操作的文件。</li><li>offset：偏移量，表示相对于whence的偏移量。</li><li>whence：起始位置，表示从哪个位置开始进行偏移，取值如下：<ul><li>SEEK_SET：文件开头。</li><li>SEEK_CUR：当前位置。</li><li>SEEK_END：文件末尾。</li></ul></li><li>ftell()：返回值表示文件读写位置相对于文件开头的偏移量，如果出错，则返回-1L。</li><li>fseek()：返回值表示是否成功，成功返回0，出错返回-1。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE *fp = fopen(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        perror(<span class="string">&quot;fopen()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="type">long</span> pos = ftell(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current position: %ld\n&quot;</span>, pos);</span><br><span class="line">    fseek(fp, <span class="number">10</span>, SEEK_SET);</span><br><span class="line">    pos = ftell(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Current position: %ld\n&quot;</span>, pos);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环链表</title>
      <link href="/2024/07/22/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2024/07/22/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h1><p>  循环单链表（Circular Singly Linked List）是链表的一种，与普通的单链表不同的是，循环单链表的最后一个节点指向链表的第一个节点，形成一个环状结构。这种结构在某些情况下非常有用，比如在需要遍历整个链表而不必检查空指针的场景下。</p><h2 id="循环单链表的定义"><a href="#循环单链表的定义" class="headerlink" title="循环单链表的定义"></a>循环单链表的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义循环单链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h2 id="循环单链表的初始化"><a href="#循环单链表的初始化" class="headerlink" title="循环单链表的初始化"></a>循环单链表的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建循环单链表</span></span><br><span class="line">Node* <span class="title function_">createList</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">    Node *head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node *tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;data = rand() % <span class="number">100</span>;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail-&gt;next = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Node **head, <span class="type">int</span> position, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *current = *head;</span><br><span class="line">    <span class="type">int</span> currentPosition = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; currentPosition &lt; position) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        currentPosition++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Position %d out of range\n&quot;</span>, position);</span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next = current;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next == *head) &#123; <span class="comment">// 插入到表尾</span></span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current-&gt;next-&gt;prior = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(Node **head, <span class="type">int</span> position)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    Node *current = *head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;next != *head) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Position %d out of range\n&quot;</span>, position);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    current-&gt;next = current-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next == *head) &#123; <span class="comment">// 删除的是表头节点</span></span><br><span class="line">        *head = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    current-&gt;next-&gt;prior = current;</span><br><span class="line">    <span class="built_in">free</span>(current-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverse</span><span class="params">(Node *head)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (current != *head) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;data);</span><br><span class="line">    current = current-&gt;next;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modify</span><span class="params">(Node **head, <span class="type">int</span> position, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">    Node *current = *head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;next != *head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == position) &#123;</span><br><span class="line">            current-&gt;data = newData;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Position %d not found\n&quot;</span>, position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(Node *head, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != target) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data == target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销毁循环单链表"><a href="#销毁循环单链表" class="headerlink" title="销毁循环单链表"></a>销毁循环单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁循环单链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroy</span><span class="params">(Node **head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (*head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        deleteNode(head, (*head)-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line">    *head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;循环单链表已销毁\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h1><h2 id="定义循环双链表结构体"><a href="#定义循环双链表结构体" class="headerlink" title="定义循环双链表结构体"></a>定义循环双链表结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;Node;</span><br></pre></td></tr></table></figure><h2 id="创建循环双链表"><a href="#创建循环双链表" class="headerlink" title="创建循环双链表"></a>创建循环双链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建循环双链表</span></span><br><span class="line">Node *<span class="title function_">create</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Node *head = <span class="literal">NULL</span>, *tail = <span class="literal">NULL</span>, *current = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        current = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        current-&gt;data = i;</span><br><span class="line">        current-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            head = current;</span><br><span class="line">            tail = current;</span><br><span class="line">            current-&gt;next = head;</span><br><span class="line">            current-&gt;prev = head;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tail-&gt;next = current;</span><br><span class="line">            current-&gt;prev = tail;</span><br><span class="line">            tail = current;</span><br><span class="line">            tail-&gt;next = head;</span><br><span class="line">            head-&gt;prev = tail;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入节点-1"><a href="#插入节点-1" class="headerlink" title="插入节点"></a>插入节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Node **head, <span class="type">int</span> position, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *current = *head;</span><br><span class="line">    <span class="type">int</span> currentPosition = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; currentPosition &lt; position) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        currentPosition++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Position %d out of range\n&quot;</span>, position);</span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next = current;</span><br><span class="line">    newNode-&gt;prior = current-&gt;prior;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;prior == *head) &#123; <span class="comment">// 插入到表头</span></span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current-&gt;prior-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点-1"><a href="#删除节点-1" class="headerlink" title="删除节点"></a>删除节点</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"> 复制</span><br><span class="line"> 插入</span><br><span class="line"> 更多</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义循环双链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建循环双链表</span></span><br><span class="line">Node* <span class="title function_">createList</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">    Node *head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node *tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;data = rand() % <span class="number">100</span>;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        newNode-&gt;prior = tail;</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tail-&gt;next = head;</span><br><span class="line">    head-&gt;prior = tail;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Node **head, <span class="type">int</span> position, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *current = *head;</span><br><span class="line">    <span class="type">int</span> currentPosition = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; currentPosition &lt; position) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        currentPosition++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Position %d out of range\n&quot;</span>, position);</span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next = current;</span><br><span class="line">    newNode-&gt;prior = current-&gt;prior;</span><br><span class="line">    <span class="keyword">if</span> (current-&gt;prior == *head) &#123; <span class="comment">// 插入到表头</span></span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current-&gt;prior-&gt;next = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;prior = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(Node **head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *current = *head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != data) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node with data %d not found\n&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next == *head) &#123; <span class="comment">// 删除头节点</span></span><br><span class="line">        *head = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (*head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            (*head)-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current-&gt;prior-&gt;next = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;prior == *head) &#123; <span class="comment">// 删除尾节点</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;next != *head) &#123;</span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current-&gt;next-&gt;prior = current-&gt;prior;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找节点</span></span><br><span class="line">Node* <span class="title function_">findNode</span><span class="params">(Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == data) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改节点数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyNode</span><span class="params">(Node *head, <span class="type">int</span> oldData, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">    Node *node = findNode(head, oldData);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node with data %d not found\n&quot;</span>, oldData);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = newData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">traverseList</span><span class="params">(Node *head)</span> &#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销毁循环双链表"><a href="#销毁循环双链表" class="headerlink" title="销毁循环双链表"></a>销毁循环双链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁循环双链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyList</span><span class="params">(Node *head)</span> &#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node *temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 循环链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列</title>
      <link href="/2024/07/20/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2024/07/20/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h1><p>栈是一种特殊的线性数据结构，它只能在某一端（顶端）进行插入或删除操作。栈内的元素进栈出栈都遵循“后进先出”（LIFO，Last In First Out）的原则。</p><h2 id="栈的初始化"><a href="#栈的初始化" class="headerlink" title="栈的初始化"></a>栈的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> items[<span class="number">100</span>]; <span class="comment">// 栈空间</span></span><br><span class="line">    <span class="type">int</span> top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeStack</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断空栈和满栈"><a href="#判断空栈和满栈" class="headerlink" title="判断空栈和满栈"></a>判断空栈和满栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈和出栈"><a href="#入栈和出栈" class="headerlink" title="入栈和出栈"></a>入栈和出栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">stack</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈已满，无法入栈\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;items[++<span class="built_in">stack</span>-&gt;top] = value;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 已入栈\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法出栈\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;items[<span class="built_in">stack</span>-&gt;top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看栈顶元素"><a href="#查看栈顶元素" class="headerlink" title="查看栈顶元素"></a>查看栈顶元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;items[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><p>共享栈是一种特殊的栈，它允许多个进程共享一个栈空间。在操作系统中，进程的栈是独立的，当栈空间不足时，可能会导致栈溢出错误。为了解决这个问题，可以采用共享栈的方式，将多个进程的栈空间共享，以提高内存利用率和减少栈溢出的风险。</p><p>共享栈的基本思想是将多个进程的栈空间组织成一个数组，每个进程的栈空间分配一段连续的内存空间。这样，多个进程的栈空间就可以在同一个数组中连续存储，从而实现共享。</p><p>共享栈的基本操作包括入栈、出栈、查看栈顶元素和判断栈是否为空。</p><h2 id="共享栈的定义和初始化"><a href="#共享栈的定义和初始化" class="headerlink" title="共享栈的定义和初始化"></a>共享栈的定义和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;   <span class="comment">//ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top0;<span class="comment">//栈0栈顶指针</span></span><br><span class="line"><span class="type">int</span> top1;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br></pre></td></tr></table></figure><h2 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqDoubleStack *S, Elemtype e, <span class="type">int</span> stackNumber)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top0+<span class="number">1</span> == S-&gt;top1)&#123;   <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">0</span>)&#123;   <span class="comment">//栈0有元素进栈</span></span><br><span class="line">        S-&gt;data[++S-&gt;top0] = e; <span class="comment">//若栈0则先top0+1后给数组元素赋值</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(satckNumber == <span class="number">1</span>)&#123; <span class="comment">//栈1有元素进栈</span></span><br><span class="line">        S-&gt;data[--S-&gt;top1] = e; <span class="comment">//若栈1则先top1-1后给数组元素赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqDoubleStack *S, ElemType *e, <span class="type">int</span> stackNumber)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top0 == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;   <span class="comment">//说明栈0已经是空栈，溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top0--]; <span class="comment">//将栈0的栈顶元素出栈，随后栈顶指针减1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stackNumber == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top1 == MAXSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ERROR;   <span class="comment">//说明栈1是空栈，溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top1++];    <span class="comment">//将栈1的栈顶元素出栈，随后栈顶指针加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h1><p>采用链式存储的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都是在单链表的表头进行的。<br>这里规定链栈没有头节点，Lhead指向栈顶元素，如下图<br><img src="/data_structure_img/链栈.png"></img><br>对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top&#x3D;NULL的时候。<br>链栈的基本操作包括入栈、出栈、查看栈顶元素和判断栈是否为空。</p><h2 id="链栈的定义和初始化"><a href="#链栈的定义和初始化" class="headerlink" title="链栈的定义和初始化"></a>链栈的定义和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 用于存储栈内元素的整型变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Node* top; <span class="comment">// 栈顶指针，指向栈顶元素所在的节点</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeStack</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>; <span class="comment">// 初始化时栈为空，栈顶指针设为NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="literal">NULL</span>; <span class="comment">// 如果栈为空，返回1，否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入栈-1"><a href="#入栈-1" class="headerlink" title="入栈"></a>入栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入栈</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack* <span class="built_in">stack</span>, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node)); <span class="comment">// 分配新节点的内存</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value; <span class="comment">// 将新节点的data成员设置为要入栈的值</span></span><br><span class="line">    newNode-&gt;next = <span class="built_in">stack</span>-&gt;top; <span class="comment">// 将新节点的next成员指向原栈顶元素</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = newNode; <span class="comment">// 将栈顶指针指向新节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 已入栈\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空，无法出栈\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = <span class="built_in">stack</span>-&gt;top; <span class="comment">// 保存栈顶元素所在的节点</span></span><br><span class="line">    <span class="type">int</span> value = temp-&gt;data; <span class="comment">// 获取栈顶元素的值</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = temp-&gt;next; <span class="comment">// 将栈顶指针指向下一个元素</span></span><br><span class="line">    <span class="built_in">free</span>(temp); <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出栈元素：%d\n&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看栈顶元素-1"><a href="#查看栈顶元素-1" class="headerlink" title="查看栈顶元素"></a>查看栈顶元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看栈顶元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data; <span class="comment">// 返回栈顶元素的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>队列是一种特殊的线性数据结构，它只能在某一端（队尾）进行插入操作，在另一端（队首）进行删除操作。队列内的元素进队出队都遵循“先进先出”（FIFO，First In First Out）的原则。</p><h2 id="队列的定义和初始化"><a href="#队列的定义和初始化" class="headerlink" title="队列的定义和初始化"></a>队列的定义和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100 <span class="comment">// 队列的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> items[MAX]; <span class="comment">// 用于存储队列内元素的数组</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队首指针，指向队首元素在数组中的位置</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾指针，指向队尾元素在数组中的位置</span></span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeQueue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>; <span class="comment">// 初始化时队列为空，队首指针设为-1</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>; <span class="comment">// 初始化时队列为空，队尾指针设为-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断空队列或满队列"><a href="#判断空队列或满队列" class="headerlink" title="判断空队列或满队列"></a>判断空队列或满队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="number">-1</span>; <span class="comment">// 如果队列为空，返回1，否则返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % MAX == <span class="built_in">queue</span>-&gt;front; <span class="comment">// 如果队列满，返回1，否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(Queue* <span class="built_in">queue</span>, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满，无法入队\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>; <span class="comment">// 如果队列为空，设置队首指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % MAX; <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;items[<span class="built_in">queue</span>-&gt;rear] = value; <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 已入队\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已空，无法出队\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> item = <span class="built_in">queue</span>-&gt;items[<span class="built_in">queue</span>-&gt;front]; <span class="comment">// 保存队首元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>; <span class="comment">// 如果队列只有一个元素，出队后队列为空，设置队首指针为-1</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>; <span class="comment">// 如果队列只有一个元素，出队后队列为空，设置队尾指针为-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % MAX; <span class="comment">// 删除队首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item; <span class="comment">// 返回队首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看队首元素"><a href="#查看队首元素" class="headerlink" title="查看队首元素"></a>查看队首元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Queue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;items[<span class="built_in">queue</span>-&gt;front]; <span class="comment">// 返回队首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><p>循环队列是一种特殊的队列，它的队首和队尾可以循环地使用队列空间。循环队列可以在队列满时高效地处理元素，因为它不需要像普通队列那样重新分配内存。<br><img src="/data_structure_img/循环队列.png"></img></p><h2 id="循环队列的定义和初始化"><a href="#循环队列的定义和初始化" class="headerlink" title="循环队列的定义和初始化"></a>循环队列的定义和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100 <span class="comment">// 队列的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> items[MAX]; <span class="comment">// 用于存储队列内元素的数组</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队首指针，指向队首元素在数组中的位置</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾指针，指向队尾元素在数组中的位置</span></span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 队列当前大小</span></span><br><span class="line">&#125; CircularQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeQueue</span><span class="params">(CircularQueue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>; <span class="comment">// 初始化时队列为空，队首指针设为-1</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>; <span class="comment">// 初始化时队列为空，队尾指针设为-1</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;size = <span class="number">0</span>; <span class="comment">// 初始化时队列大小设为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断队列是否为空和是否已满"><a href="#判断队列是否为空和是否已满" class="headerlink" title="判断队列是否为空和是否已满"></a>判断队列是否为空和是否已满</h2><p>牺牲一个单元来区分队空和队满，入队时少用一个队列单元，这是种较为普遍的做法，约定以“队头指针在队尾指针的下一位置作为队满的标志”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="comment">/*判队空*/</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isEmpty</span><span class="params">(CircularQueue <span class="built_in">queue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>.rear == <span class="built_in">queue</span>.front)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(CircularQueue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;size == MAX; <span class="comment">// 如果队列大小等于最大容量，返回1，否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入队和出队操作"><a href="#入队和出队操作" class="headerlink" title="入队和出队操作"></a>入队和出队操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(CircularQueue* <span class="built_in">queue</span>, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满，无法入队\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>; <span class="comment">// 如果队列为空，设置队首指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % MAX; <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;items[<span class="built_in">queue</span>-&gt;rear] = value; <span class="comment">// 插入元素到队尾</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;size++; <span class="comment">// 队列大小加1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 已入队\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(CircularQueue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已空，无法出队\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> item = <span class="built_in">queue</span>-&gt;items[<span class="built_in">queue</span>-&gt;front]; <span class="comment">// 保存队首元素</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="number">-1</span>; <span class="comment">// 如果队列只有一个元素，出队后队列为空，设置队首指针为-1</span></span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = <span class="number">-1</span>; <span class="comment">// 如果队列只有一个元素，出队后队列为空，设置队尾指针为-1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % MAX; <span class="comment">// 删除队首元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;size--; <span class="comment">// 队列大小减1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队元素：%d\n&quot;</span>, item);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看队首元素-1"><a href="#查看队首元素-1" class="headerlink" title="查看队首元素"></a>查看队首元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(CircularQueue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;items[<span class="built_in">queue</span>-&gt;front]; <span class="comment">// 返回队首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h1><p>链队列是一种线性数据结构，它使用链表来存储队列中的元素。在这种结构中，队列的元素被存储在节点中，每个节点包含一个元素和一个指向下一个节点的指针。链队列有两个指针，一个指向队头元素，另一个指向队尾元素。</p><p>当元素被插入到队列中时，它被添加到链表的末尾，这个过程被称为入队。当元素从队列中取出时，它从链表的头部被删除，这个过程被称为出队。因此，链队列遵循先进先出（FIFO）的原则。</p><p>在链队列中，如果队列为空，头指针和尾指针都指向一个空节点。当新元素被插入时，它被添加到尾节点之后，然后尾指针被移动到新添加的节点。当元素被删除时，头指针被移动到下一个节点。</p><p>链队列的优点是它可以根据需要动态地增长和缩小，不需要像数组队列那样事先确定大小。然而，链队列的缺点是它在某些操作（如获取队头元素）中可能需要遍历整个链表，这使得其效率不如数组队列。</p><h2 id="链队列的定义和初始化"><a href="#链队列的定义和初始化" class="headerlink" title="链队列的定义和初始化"></a>链队列的定义和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Node* front;</span><br><span class="line">    Node* rear;</span><br><span class="line">&#125; LinkedQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeQueue</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enqueue</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear-&gt;next = newNode;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 已入队\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="出队-2"><a href="#出队-2" class="headerlink" title="出队"></a>出队</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dequeue</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已空，无法出队\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* temp = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="type">int</span> value = temp-&gt;data;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">queue</span>-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队元素：%d\n&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看队头元素"><a href="#查看队头元素" class="headerlink" title="查看队头元素"></a>查看队头元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队头元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(LinkedQueue* <span class="built_in">queue</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><p>双端队列是指允许两端都可以进行入队和出队操作的队列，如下图所示。其元素的逻辑结构仍是线性结构。将队列的两端分别称为前端和后端，两端都可以入队和出队。</p><h2 id="双端队列的定义和初始化"><a href="#双端队列的定义和初始化" class="headerlink" title="双端队列的定义和初始化"></a>双端队列的定义和初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100 <span class="comment">// 双端队列的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> items[MAX]; <span class="comment">// 用于存储双端队列内元素的数组</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">// 队首指针，指向队首元素在数组中的位置</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">// 队尾指针，指向队尾元素在数组中的位置</span></span><br><span class="line">    <span class="type">int</span> size; <span class="comment">// 双端队列当前大小</span></span><br><span class="line">&#125; Deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化双端队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">initializeDeque</span><span class="params">(Deque* <span class="built_in">deque</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;front = <span class="number">-1</span>; <span class="comment">// 初始化时双端队列空，队首指针设为-1</span></span><br><span class="line">    <span class="built_in">deque</span>-&gt;rear = <span class="number">0</span>; <span class="comment">// 初始化时双端队列只有一个元素，队尾指针设为0</span></span><br><span class="line">    <span class="built_in">deque</span>-&gt;size = <span class="number">1</span>; <span class="comment">// 初始化时双端队列大小设为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断双端队列是否为空或已满"><a href="#判断双端队列是否为空或已满" class="headerlink" title="判断双端队列是否为空或已满"></a>判断双端队列是否为空或已满</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断双端队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isEmpty</span><span class="params">(Deque* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size == <span class="number">0</span>; <span class="comment">// 如果双端队列大小为0，返回1，否则返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断双端队列是否已满</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">isFull</span><span class="params">(Deque* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;size == MAX; <span class="comment">// 如果双端队列大小等于最大容量，返回1，否则返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在队首插入元素"><a href="#在队首插入元素" class="headerlink" title="在队首插入元素"></a>在队首插入元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在队首插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertFront</span><span class="params">(Deque* <span class="built_in">deque</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双端队列已满，无法在队首插入元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="number">0</span>; <span class="comment">// 如果双端队列空，设置队首指针</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;items[--<span class="built_in">deque</span>-&gt;front] = value; <span class="comment">// 在队首插入元素</span></span><br><span class="line">    <span class="built_in">deque</span>-&gt;size++; <span class="comment">// 双端队列大小加1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 已插入队首\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在队尾插入元素"><a href="#在队尾插入元素" class="headerlink" title="在队尾插入元素"></a>在队尾插入元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在队尾插入元素</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertRear</span><span class="params">(Deque* <span class="built_in">deque</span>, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双端队列已满，无法在队尾插入元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>-&gt;items[<span class="built_in">deque</span>-&gt;rear++] = value; <span class="comment">// 在队尾插入元素</span></span><br><span class="line">    <span class="built_in">deque</span>-&gt;size++; <span class="comment">// 双端队列大小加1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;元素 %d 已插入队尾\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从队首删除元素"><a href="#从队首删除元素" class="headerlink" title="从队首删除元素"></a>从队首删除元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队首删除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteFront</span><span class="params">(Deque* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双端队列已空，无法从队首删除元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">deque</span>-&gt;items[<span class="built_in">deque</span>-&gt;front++]; <span class="comment">// 从队首删除元素</span></span><br><span class="line">    <span class="built_in">deque</span>-&gt;size--; <span class="comment">// 双端队列大小减1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;front == <span class="built_in">deque</span>-&gt;rear) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="number">-1</span>; <span class="comment">// 如果双端队列只有一个元素，删除后队列为空，设置队首指针为-1</span></span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = <span class="number">0</span>; <span class="comment">// 如果双端队列只有一个元素，删除后队列为空，设置队尾指针为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从队首删除元素：%d\n&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="从队尾删除元素"><a href="#从队尾删除元素" class="headerlink" title="从队尾删除元素"></a>从队尾删除元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从队尾删除元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteRear</span><span class="params">(Deque* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双端队列已空，无法从队尾删除元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> value = <span class="built_in">deque</span>-&gt;items[--<span class="built_in">deque</span>-&gt;rear]; <span class="comment">// 从队尾删除元素</span></span><br><span class="line">    <span class="built_in">deque</span>-&gt;size--; <span class="comment">// 双端队列大小减1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">deque</span>-&gt;front == <span class="built_in">deque</span>-&gt;rear) &#123;</span><br><span class="line">        <span class="built_in">deque</span>-&gt;front = <span class="number">-1</span>; <span class="comment">// 如果双端队列只有一个元素，删除后队列为空，设置队首指针为-1</span></span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = <span class="number">0</span>; <span class="comment">//</span></span><br><span class="line">        <span class="built_in">deque</span>-&gt;rear = <span class="number">0</span>; <span class="comment">// 如果双端队列只有一个元素，删除后队列为空，设置队尾指针为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;从队尾删除元素：%d\n&quot;</span>, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看队首元素-2"><a href="#查看队首元素-2" class="headerlink" title="查看队首元素"></a>查看队首元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队首元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekFront</span><span class="params">(Deque* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双端队列已空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;items[<span class="built_in">deque</span>-&gt;front]; <span class="comment">// 查看队首元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查看队尾元素"><a href="#查看队尾元素" class="headerlink" title="查看队尾元素"></a>查看队尾元素</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看队尾元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekRear</span><span class="params">(Deque* <span class="built_in">deque</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">deque</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;双端队列已空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">deque</span>-&gt;items[<span class="built_in">deque</span>-&gt;rear - <span class="number">1</span>]; <span class="comment">// 查看队尾元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双链表的基本操作</title>
      <link href="/2024/07/18/%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/18/%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>双链表的基本操作包括创建、插入、删除、更改节点数据、查找和打印。</p><h1 id="创建双链表："><a href="#创建双链表：" class="headerlink" title="创建双链表："></a>创建双链表：</h1><p>在给定长度和随机数范围的情况下，创建一个双链表。每个节点包含一个指向前驱节点的指针、一个存储数据元素的指针和一个指向后继节点的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义双向链表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="双向链表的初始化"><a href="#双向链表的初始化" class="headerlink" title="双向链表的初始化"></a>双向链表的初始化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建双向链表</span></span><br><span class="line">Node* <span class="title function_">createList</span><span class="params">(<span class="type">int</span> length)</span> &#123;</span><br><span class="line">    Node *head = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    head-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    head-&gt;data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Node *tail = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        newNode-&gt;prior = tail;</span><br><span class="line">        newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        newNode-&gt;data = rand() % <span class="number">100</span>;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插入节点："><a href="#插入节点：" class="headerlink" title="插入节点："></a>插入节点：</h1><p>在双链表中插入新节点可以发生在表头、表的中间位置或表尾。如果发生在表头，只需要将新节点与表头元素建立双层逻辑关系。如果发生在表的中间位置，需要先将新节点与它的直接后继节点建立双层逻辑关系，然后将新节点的直接前驱节点与它建立双层逻辑关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insertNode</span><span class="params">(Node **head, <span class="type">int</span> position, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node *newNode = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    newNode-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head = newNode;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *current = *head;</span><br><span class="line">    <span class="type">int</span> currentPosition = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; currentPosition &lt; position) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        currentPosition++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Position %d out of range\n&quot;</span>, position);</span><br><span class="line">        <span class="built_in">free</span>(newNode);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;prior == <span class="literal">NULL</span>) &#123; <span class="comment">// 插入到表头</span></span><br><span class="line">        newNode-&gt;next = *head;</span><br><span class="line">        (*head)-&gt;prior = newNode;</span><br><span class="line">        *head = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newNode-&gt;next = current;</span><br><span class="line">        newNode-&gt;prior = current-&gt;prior;</span><br><span class="line">        current-&gt;prior-&gt;next = newNode;</span><br><span class="line">        current-&gt;prior = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="删除节点："><a href="#删除节点：" class="headerlink" title="删除节点："></a>删除节点：</h1><p>在双链表中删除节点时，只需遍历链表找到要删除的节点，然后将该节点从表中摘除。如果被删除的节点是头节点、尾节点还是普通节点，需要分别处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteNode</span><span class="params">(Node **head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;List is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node *current = *head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> &amp;&amp; current-&gt;data != data) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node with data %d not found\n&quot;</span>, data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;prior == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除头节点</span></span><br><span class="line">        *head = current-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (*head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            (*head)-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current-&gt;prior-&gt;next = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">// 删除尾节点</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;prior != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            current = current-&gt;prior;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        current-&gt;next-&gt;prior = current-&gt;prior;</span><br><span class="line">        <span class="built_in">free</span>(current);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="更改节点数据："><a href="#更改节点数据：" class="headerlink" title="更改节点数据："></a>更改节点数据：</h1><p>在双链表中更改指定节点的数据域，是在查找的基础上完成的。通过遍历找到存储有该数据元素的节点，直接更改其数据域即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">modifyNode</span><span class="params">(Node *head, <span class="type">int</span> oldData, <span class="type">int</span> newData)</span> &#123;</span><br><span class="line">    Node *node = findNode(head, oldData);</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Node with data %d not found\n&quot;</span>, oldData);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;data = newData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查找节点："><a href="#查找节点：" class="headerlink" title="查找节点："></a>查找节点：</h1><p>在双链表中查找指定元素的实现，同单链表类似，都是从表头依次遍历表中元素，直到找到指定元素或者遍历完整个链表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">findNode</span><span class="params">(Node *head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == data) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><h1 id="打印双链表："><a href="#打印双链表：" class="headerlink" title="打印双链表："></a>打印双链表：</h1><p>遍历双链表，打印每个节点的数据元素。如果当前节点是尾节点，打印后需要换行；如果不是尾节点，打印后需要打印一个“-&gt;”</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="type">void</span> <span class="title function_">traverseList</span><span class="params">(Node *head)</span> &#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="销毁链表："><a href="#销毁链表：" class="headerlink" title="销毁链表："></a>销毁链表：</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁双向链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">destroyList</span><span class="params">(Node *head)</span> &#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Node *temp = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 双链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的基本操作</title>
      <link href="/2024/07/13/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/13/%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>单链表是一种常用的数据结构，它通过节点（Node）的形式存储数据，每个节点包含数据部分和指向下一个节点的指针。本文将介绍单链表的基本操作，包括初始化、打印、长度计算、头插法、尾插法、查找、按位置获取节点、按位置插入节点和按位置删除节点。</p><p>通常使用头指针来标识一个单链表，如单链表L，头指针为NULL时表示一个空表。为了操作上的方便，可以在单链表的第一个结点之前附加一个头结点。头结点一般不存储数据，它的数据域可以不设任何信息，或记录表长等信息；头结点的指针域指向线性表的第一个元素结点。</p><p>带头节点的好处：</p><ol><li>统一操作<br> 简化插入和删除操作：在带头节点的单链表中，所有的节点（包括第一个实际存储数据的节点）的插入和删除操作都可以统一处理，无需特别考虑链表为空的情况。因为头节点始终存在，所以所有操作都可以从头节点开始，从而简化了逻辑处理。</li><li>方便空链表的处理<br> 避免空指针异常：在不带头节点的单链表中，如果链表为空，则头指针为NULL。在进行任何操作之前，都需要先检查链表是否为空，以避免空指针异常。而带头节点的单链表则不需要这种检查，因为头节点始终存在，只是头节点的下一个节点（即第一个实际存储数据的节点）可能为NULL。</li><li>简化遍历逻辑<br>一致的遍历起点：在带头节点的单链表中，遍历链表时总是从头节点的下一个节点开始，这提供了一种统一的遍历起点，使得遍历逻辑更加清晰和一致。</li><li>易于理解和实现<br>直观的数据结构：从数据结构的角度来看，带头节点的单链表更加直观和易于理解。它清晰地表示了链表的开始和结束（虽然结束是通过尾节点的next指针为NULL来表示的），并且使得链表的操作更加符合人们的直觉。</li><li>便于扩展和维护<br>灵活的扩展性：在某些情况下，可能需要在链表的前端添加额外的信息（如链表长度、类型标识等），这时带头节点的单链表就显得尤为方便。因为头节点可以作为   这些额外信息的载体，而无需修改其他节点的结构。<br>减少错误：由于带头节点的单链表简化了空链表的处理和插入删除操作的逻辑，因此在编写代码时减少了出错的可能性，使得链表的维护更加容易。</li></ol><h1 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a>初始化链表</h1><p>初始化链表主要是为链表分配一个头节点，并将头节点的next指针设置为NULL，表示链表为空。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(LinkList *L)</span></span><br><span class="line"> &#123;  </span><br><span class="line">    *L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 分配头节点内存  </span></span><br><span class="line">    <span class="keyword">if</span> (*L == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;分配头节点失败&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    (*L)-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 初始化头节点的next为null  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打印链表"><a href="#打印链表" class="headerlink" title="打印链表"></a>打印链表</h1><p>遍历链表并打印每个节点的数据。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printList</span><span class="params">(LinkList L)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// 从头节点的下一个节点开始遍历  </span></span><br><span class="line">    <span class="keyword">while</span> (p) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data); <span class="comment">// 打印当前节点数据  </span></span><br><span class="line">        p = p-&gt;next; <span class="comment">// 移动到下一个节点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="计算链表长度"><a href="#计算链表长度" class="headerlink" title="计算链表长度"></a>计算链表长度</h1><p>遍历链表并计算节点的数量。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// 从头节点开始遍历  </span></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>; <span class="comment">// 定义统计长度的变量  </span></span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">     &#123;  </span><br><span class="line">        len++; <span class="comment">// 长度++  </span></span><br><span class="line">        p = p-&gt;next; <span class="comment">// 指向下一个节点  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> len;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h1><p>查找链表中值为x的节点，并返回该节点的指针。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L, <span class="type">int</span> x)</span></span><br><span class="line"> &#123;  </span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// 从头节点的下一个节点开始遍历  </span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != x) </span><br><span class="line">    &#123; <span class="comment">// 当未遍历完且当前节点数据不为x时继续  </span></span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回找到的节点或NULL  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="按位置获取节点"><a href="#按位置获取节点" class="headerlink" title="按位置获取节点"></a>按位置获取节点</h1><p>获取链表中第i个位置的节点（头节点为第0个）<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;  </span><br><span class="line">    LNode *p = L-&gt;next; <span class="comment">// 从头节点的下一个节点开始遍历  </span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> L; <span class="comment">// 如果i为0，则返回头节点（这里假设头节点不是数据节点）  </span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 如果i小于1，返回NULL  </span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i)</span><br><span class="line">     &#123;  </span><br><span class="line">        p = p-&gt;next;  </span><br><span class="line">        j++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">// 返回找到的节点或NULL  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="头插法插入元素"><a href="#头插法插入元素" class="headerlink" title="头插法插入元素"></a>头插法插入元素</h1><p>在链表的头部插入新元素。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">headInsert</span><span class="params">(LinkList *L)</span></span><br><span class="line"> &#123;  </span><br><span class="line">    InitList(L); <span class="comment">// 初始化链表  </span></span><br><span class="line">    <span class="type">int</span> x;  </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);  </span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) </span><br><span class="line">    &#123; <span class="comment">// 当输入9999作为结束输入的标志  </span></span><br><span class="line">        LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 声明一个新的节点  </span></span><br><span class="line">        s-&gt;data = x; <span class="comment">// 将当前输入的数据存入节点data中  </span></span><br><span class="line">        s-&gt;next = (*L)-&gt;next; <span class="comment">// 将新的节点的next指针指向当前头节点的下一个节点  </span></span><br><span class="line">        (*L)-&gt;next = s; <span class="comment">// 将头节点的next指针指向新节点  </span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x); <span class="comment">// 继续读取下一个数据  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> *L; <span class="comment">// 返回链表的头节点指针  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="尾插法插入元素"><a href="#尾插法插入元素" class="headerlink" title="尾插法插入元素"></a>尾插法插入元素</h1><p>在链表的尾部插入新元素。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">TailInsert</span><span class="params">(LinkList *L)</span></span><br><span class="line"> &#123;  </span><br><span class="line">    InitList(L);  <span class="comment">// 初始化链表，创建一个空链表</span></span><br><span class="line">    LNode *s, *r = *L;  <span class="comment">// 定义两个指针s和r，都指向链表L的头节点</span></span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 定义一个整型变量x，用于存储输入的数值</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);  <span class="comment">// 从标准输入读取一个整数，存储在变量x中</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>)</span><br><span class="line">     &#123; <span class="comment">// 当输入的数值x不等于9999时，执行循环操作</span></span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">// 为新节点s分配内存空间</span></span><br><span class="line">        s-&gt;data = x;  <span class="comment">// 将变量x的值赋给新节点s的数据域</span></span><br><span class="line">        r-&gt;next = s;  <span class="comment">// 将链表L中最后一个节点的next指针指向新节点s</span></span><br><span class="line">        r = s;  <span class="comment">// 将指针r指向新节点s</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);  <span class="comment">// 从标准输入读取一个整数，存储在变量x中</span></span><br><span class="line">    &#125;  </span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 将链表L中最后一个节点的next指针设置为NULL</span></span><br><span class="line">    <span class="keyword">return</span> *L;  <span class="comment">// 返回链表L的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="按位置插入节点"><a href="#按位置插入节点" class="headerlink" title="按位置插入节点"></a>按位置插入节点</h1><p>在链表的第i个位置插入值为x的新节点。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert</span><span class="params">(LinkList *L, <span class="type">int</span> i, <span class="type">int</span> x)</span> </span><br><span class="line">&#123;  </span><br><span class="line">    LNode *p = GetElem(*L, i - <span class="number">1</span>); <span class="comment">// 获取第i-1个位置的节点  </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 如果p为NULL，则i位置不合法  </span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode)); <span class="comment">// 分配新节点的内存  </span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed.\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    s-&gt;data = x; <span class="comment">// 设置新节点的数据  </span></span><br><span class="line">    s-&gt;next = p-&gt;next; <span class="comment">// 新节点指向原i位置的节点  </span></span><br><span class="line">    p-&gt;next = s; <span class="comment">// 第i-1个节点的next指向新节点  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="按位置删除节点"><a href="#按位置删除节点" class="headerlink" title="按位置删除节点"></a>按位置删除节点</h1><p>删除链表中第i个位置的节点。<br>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(LinkList *L, <span class="type">int</span> i)</span></span><br><span class="line"> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; Length(*L)) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Delete failed: index is wrong.\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    LNode *p = GetElem(*L, i - <span class="number">1</span>); <span class="comment">// 获取第i-1个位置的节点  </span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || p-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Delete failed: index is out of bounds or empty node.\n&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    LNode *q = p-&gt;next; <span class="comment">// q指向要删除的节点  </span></span><br><span class="line">    p-&gt;next = q-&gt;next; <span class="comment">// p的next指向q的下一个节点，从而删除q  </span></span><br><span class="line">    <span class="built_in">free</span>(q); <span class="comment">// 释放q的内存  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2024/07/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2024/07/11/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>常见的排序算法</p><p>各个算法的对比：<br><img src="/sort_img/sort1.png"></img><br><img src="/sort_img/sort2.png"></img></p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p> 冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>简单易实现：冒泡排序的实现逻辑简单，易于理解和实现，适用于教学和初学者学习排序算法。<br>稳定性：冒泡排序是一种稳定的排序算法，即相同元素的相对位置在排序前后不会改变。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p>效率低：冒泡排序的时间复杂度为O(n^2)，在数量较大的情况下，排序效率较低，不适用于大规模数据的排序。<br>不适合大规模数据：由于冒泡排序需要进行多次扫描和交换操作，因此在数据量较大时，排序速度较慢。<br>最好情况下的效率低：即使在数组已经有序的情况下，冒泡排序仍需要进行完整的比较和交换操作，造成了时间浪费。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>针对所有的元素重复以上的步骤，除了最后一个。</p><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p><h2 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h2><p><img src="/sort_img/bubbleSort.gif"></img></p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="comment">// 外层循环控制比较次数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line"><span class="comment">// 内层循环执行相邻元素比较与交换</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line"><span class="comment">// 如果前面的元素大于后面的元素，交换它们的位置</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) </span><br><span class="line">&#123;</span><br><span class="line">temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 初始化数组</span></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">22</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">89</span>, <span class="number">50</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">64</span>, <span class="number">35</span>, <span class="number">9</span>, <span class="number">70</span> &#125;;</span><br><span class="line"><span class="comment">// 计算数组长度</span></span><br><span class="line"><span class="type">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// 调用冒泡排序函数对数组进行排序</span></span><br><span class="line">bubble_sort(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">// 打印排序后的数组</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。<br>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。<br>     快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p><h2 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h2><p>高效性能：在平均情况下，快速排序的时间复杂度为O(nlogn)，具有较高的排序效率，适用于大规模数据的排序。<br>原地排序：快速排序是一种原地排序算法，不需要额外的存储空间，只需要少量的辅助空间存储递归调用所需的栈空间。<br>分治思想：快速排序采用分治的思想，将原问题分解为若干个子问题并分别解决，易于理解和实现。</p><h2 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h2><p>不稳定性：快速排序是一种不稳定的排序算法，可能破坏相同元素的相对位置。<br>最坏情况下效率低：在最坏情况下，快速排序的时间复杂度为O(n^2)，当原数组已经有序或逆序时，递归深度会很大，性能会受到影响。<br>对于小规模数据效率低：当数据规模较小的时候，快速排序可能不如简单的插入排序等算法高效。</p><h2 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>从数列中挑出一个元素，称为 “基准”（pivot）;</p><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</p><p>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br>3动图演示：<br><img src="/sort_img/quickSort.gif"></img></p><h2 id="具体代码-1"><a href="#具体代码-1" class="headerlink" title="具体代码"></a>具体代码</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 划分函数，用于快速排序中确定基准元素的位置</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Paritition1</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pivot = A[low]; <span class="comment">// 选取第一个元素作为基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从数组右侧向左查找第一个小于基准元素的值</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) </span><br><span class="line">        &#123;</span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将找到的小于基准元素的值移到低端</span></span><br><span class="line">        A[low] = A[high];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从数组左侧向右查找第一个大于基准元素的值</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) </span><br><span class="line">        &#123;</span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将找到的大于基准元素的值移到高端</span></span><br><span class="line">        A[high] = A[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将基准元素放置到最终位置</span></span><br><span class="line">    A[low] = pivot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> low; <span class="comment">// 返回基准元素最终的位置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> <span class="comment">// 快排母函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 划分数组并获取基准元素的位置</span></span><br><span class="line">        <span class="type">int</span> pivot = Paritition1(A, low, high);</span><br><span class="line">        <span class="comment">// 递归对基准元素左侧的数组进行快速排序</span></span><br><span class="line">        QuickSort(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归对基准元素右侧的数组进行快速排序</span></span><br><span class="line">        QuickSort(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p> 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>     插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br>     但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录”基本有序”时，再对全体记录进行依次直接插入排序。</p><h2 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h2><p>高效性能：希尔排序的时间复杂度为O(n log^2 n)，比普通的插入排序效率更高，适用于中等规模的数据排序。<br>不稳定性：希尔排序是一种不稳定的排序算法，可能破坏相同元素的相对位置。<br>原地排序：希尔排序是一种原地排序算法，不需要额外的存储空间，节省内存开销。</p><h2 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h2><p>不稳定性：由于希尔排序是一种不稳定的排序算法，可能导致相同元素的相对位置变化。<br>难以调试和理解：希尔排序的增量序列的选择和性能分析相对复杂，可能增加代码的调试难度和理解成本。<br>不适合对大规模数据进行排序：虽然希尔排序比插入排序效率更高，但在大规模数据的排序任务中，性能仍然不及快速排序等高效排序算法。</p><h2 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk &#x3D; 1；</p><p>按增量序列个数 k，对序列进行 k 趟排序；</p><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br>动图演示：<br><img src="/sort_img/Sorting_shellsort_anim.gif"></img></p><h2 id="具体代码-2"><a href="#具体代码-2" class="headerlink" title="具体代码"></a>具体代码</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shell_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> gap, i, j;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="keyword">for</span> (gap = len &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</span><br><span class="line">                        temp = arr[i];</span><br><span class="line">                        <span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</span><br><span class="line">                                arr[j + gap] = arr[j];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><pre><code>            大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；            小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；    堆排序的平均时间复杂度为 Ο(nlogn)。</code></pre><h2 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h2><p>高效性能：堆排序的时间复杂度为O(nlogn)，在最坏情况下也能保持稳定的时间复杂度，适用于大规模数据的排序。<br>原地排序：堆排序是一种原地排序算法，不需要额外的存储空间，只需要少量的辅助空间来存储堆结构，节省内存开销。<br>不稳定性：堆排序是一种不稳定的排序算法，不会改变相同元素的相对位置，适用于对排序稳定性没有要求的场景。</p><h2 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h2><p>不适合小规模数据排序：堆排序对数据元素的随机访问要求较高，不适用于小规模数据的排序，因为建堆操作的时间复杂度较高。<br>难以理解和实现：堆排序涉及到堆的概念以及维护堆的操作，相对于其他简单的排序算法，实现和理解上可能稍显复杂。<br>不稳定性：由于堆排序是一种不稳定的排序算法，可能破坏相同元素的相对位置。</p><h2 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h2><pre><code>            1.创建一个堆 H[0……n-1]；            2.把堆首（最大值）和堆尾互换；            3.把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；            4.重复步骤 2，直到堆的尺寸为 1。</code></pre><h2 id="动图演示："><a href="#动图演示：" class="headerlink" title="动图演示："></a>动图演示：</h2><p><img src="/sort_img/heapSort.gif"></img><br><img src="/sort_img/Sorting_heapsort_anim.gif"></img></p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="comment">// 建立父节点指标和子节点指标</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">// 若子节点指标在范围內才做比较</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比较两个子节点大小，选择最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">//如果父节点&gt;子节点代表调整完毕，直接跳出函數</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否則交換父子內容再继续子节点和孙节点比较</span></span><br><span class="line">            swap(&amp;arr[dad], &amp;arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始化，i从最后一个父节点开始</span></span><br><span class="line">    <span class="keyword">for</span> (i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        max_heapify(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先將第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕</span></span><br><span class="line">    <span class="keyword">for</span> (i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>], &amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>桶排序是一种排序算法，它将待排序数据分到有限数量的桶中，然后对每个桶中的数据再进行单独排序，最后按照顺序把所有非空桶中的数据合并起来。</p><h2 id="优点：-4"><a href="#优点：-4" class="headerlink" title="优点："></a>优点：</h2><p>高效的时间复杂度：当数据分布比较均匀时，桶排序的平均时间复杂度接近O(n)，具有较高的排序效率。<br>稳定性：桶排序是一种稳定的排序算法，不会改变相同元素的相对位置。<br>易于实现：桶排序的实现相对简单直观，逻辑清晰，容易理解。</p><h2 id="缺点：-4"><a href="#缺点：-4" class="headerlink" title="缺点："></a>缺点：</h2><p>需要额外的空间：桶排序需要额外的空间来存储桶，其空间复杂度较高，当数据量较大时可能造成空间浪费。<br>对数据分布要求高：桶排序对数据的分布要求比较高，如果数据分布不均匀或范围较大，可能导致排序效率下降。<br>不适用于大规模数据：由于需要根据数据范围确定桶的数量，在数据范围较大或数据量较大时，桶排序可能并不适用。</p><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>            1初始化桶：根据待排序数据的范围和分布情况，确定需要的桶的数量，并创建相应数量的空桶。            2分配数据到桶：遍历待排序数据，根据数据的大小将每个数据分配到相应的桶中。            3对每个桶进行排序：对每个非空桶中的数据进行排序，可以选择使用其他排序算法（如插入排序）。            4合并桶中数据：最后，按照桶的顺序和每个桶中数据的顺序依次将数据合并起来，得到有序的结果。</code></pre><h2 id="动图演示：-1"><a href="#动图演示：-1" class="headerlink" title="动图演示："></a>动图演示：</h2><p><img src="/sort_img/bucketSort.gif"></img></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n, <span class="type">int</span> max_val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *bucket = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (max_val + <span class="number">1</span>)); <span class="comment">// 创建桶数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化桶数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max_val; i++) &#123;</span><br><span class="line">        bucket[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据分配到桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将桶中数据按顺序输出到原数组中</span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= max_val; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[index] = i;</span><br><span class="line">            index++;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放桶数组</span></span><br><span class="line">    <span class="built_in">free</span>(bucket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> max_val = <span class="number">8</span>; <span class="comment">// 最大值假设为8</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original array: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    bucketSort(arr, n, max_val);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>计数排序是一个非基于比较的排序算法，该算法于1954年由 Harold H. Seward 提出。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。 当然这是一种牺牲空间换取时间的做法，而且当O(k)&gt;O(n<em>log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n</em>log(n)), 如归并排序，堆排序）</p><h2 id="优点：-5"><a href="#优点：-5" class="headerlink" title="优点："></a>优点：</h2><pre><code>            时间复杂度低： 计数排序的时间复杂度为O(n+k)，效率较高，适用于一定范围内的整数排序。            稳定性： 计数排序是稳定的排序算法，相同大小的元素在排序后相对位置不变。            适用范围： 计数排序适用于待排序元素为非负整数且取值范围较小的情况，适用性广泛。</code></pre><h2 id="缺点：-5"><a href="#缺点：-5" class="headerlink" title="缺点："></a>缺点：</h2><pre><code>            空间复杂度高：“ 计数排序需要额外的计数数组来存储中间计数结果，如果待排序范围较大，会消耗大量内存。            不适用于一般情况： 计数排序只适用于整数排序，且要求元素的取值范围不宜过大。            不稳定的情况下效率不高： 在元素取值范围较大、元素较为分散时，计数排序效率可能不如其他高效的排序算法。            总的来说，计数排序在某些特定情况下具有较高的效率和稳定性，但也存在一定的局限性，需要根据具体问题来选择是否使用计数排序算法。</code></pre><h2 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h2><pre><code>            1确定待排序整数的取值范围： 遍历待排序数组，找到最大值和最小值，确定取值范围。            2创建计数数组： 创建一个长度为最大值和最小值之差加一的计数数组，用于存储每个元素出现的次数。            3计数： 遍历待排序数组，将每个元素的值作为计数数组的索引，并统计相同元素出现的次数。            4累加计数： 对计数数组进行累加操作，将每个位置的值更新为其本身与前一位置之和。            5排序： 遍历待排序数组，根据元素的值在计数数组中的位置找到其在排序后的位置，将其放置在输出数组中。            6更新计数数组： 排序完一个元素后，将计数数组中对应位置的计数值减一。            7输出排序结果： 将输出数组中的元素复制回原数组，得到有序的待排序数组。</code></pre><h2 id="动图演示：-2"><a href="#动图演示：-2" class="headerlink" title="动图演示："></a>动图演示：</h2><p><img src="/sort_img/countingSort.gif"></img></p><h2 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印整型数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_arr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序算法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">counting_sort</span><span class="params">(<span class="type">int</span> *ini_arr, <span class="type">int</span> *sorted_arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建计数数组，假设元素范围在0到99之间</span></span><br><span class="line">    <span class="type">int</span> *count_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化计数数组为0</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">        count_arr[k] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个元素出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count_arr[ini_arr[i]]++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 累加计数数组，得到每个元素在排序后的数组中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">        count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据计数数组将元素放置到正确的位置</span></span><br><span class="line">    <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放计数数组的内存</span></span><br><span class="line">    <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    <span class="type">int</span> *sorted_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成随机数组</span></span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        arr[i] = rand() % <span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印原始数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ini_array: &quot;</span>);</span><br><span class="line">    print_arr(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进行计数排序</span></span><br><span class="line">    counting_sort(arr, sorted_arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印排序后的数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sorted_array: &quot;</span>);</span><br><span class="line">    print_arr(sorted_arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>基数排序（Radix Sort）是一种非比较性整数排序算法，它将数字按照各个位上的数字进行排序。具体做法是，先按照个位数进行排序，然后按照十位数排序，依次进行下去，直到最高位排序完成</p><h2 id="优点：-6"><a href="#优点：-6" class="headerlink" title="优点："></a>优点：</h2><p>相对其他排序算法，基数排序是稳定排序算法，能够保持相同元素的顺序。<br>当排序对象在一定范围内，且位数较小时，基数排序的性能较高，时间复杂度为O(d*(n+k))，其中d为数字的最大位数，n为数组长度，k为每一位的取值范围。</p><h2 id="缺点：-6"><a href="#缺点：-6" class="headerlink" title="缺点："></a>缺点：</h2><p>需要额外的空间用于存储中间结果，可能会消耗较大的内存空间。<br>对于位数较长的数字或字符串时，可能耗费较多的时间进行排序。<br>确定最大位数：</p><h2 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h2><pre><code>            1找到待排序数组中的最大值，并确定其位数，作为基数排序的轮数。            2按位排序：从最低位开始，对待排序数组进行按位排序，可以使用稳定的排序算法（如计数排序、桶排序等）。            3重复排序：按照上一轮排序结果的顺序，对下一高位继续进行排序，直至排序完成所有位数。            4合并结果：将所有轮排序完成后的结果合并为最终的有序数组。</code></pre><h2 id="动图演示：-3"><a href="#动图演示：-3" class="headerlink" title="动图演示："></a>动图演示：</h2><p><img src="/sort_img/radixSort.gif"></img></p><h2 id="实现代码："><a href="#实现代码：" class="headerlink" title="实现代码："></a>实现代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max_num = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max_num) &#123;</span><br><span class="line">            max_num = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="built_in">exp</span> = <span class="number">1</span>; max_num / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>) &#123;</span><br><span class="line">        countingSort(arr, n, <span class="built_in">exp</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">170</span>, <span class="number">45</span>, <span class="number">75</span>, <span class="number">90</span>, <span class="number">802</span>, <span class="number">24</span>, <span class="number">2</span>, <span class="number">66</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    radixSort(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sorted array using Radix Sort: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p> 选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h2 id="优点：-7"><a href="#优点：-7" class="headerlink" title="优点："></a>优点：</h2><p>简单易实现：选择排序是一种直观易懂的排序算法，实现简单，适合初学者理解和实现。<br>原地排序：选择排序是一种原地排序算法，不需要额外的存储空间，节省内存开销。<br>稳定性：选择排序是一种稳定的排序算法，不会改变相同元素的相对位置。</p><h2 id="缺点：-7"><a href="#缺点：-7" class="headerlink" title="缺点："></a>缺点：</h2><p>效率低：选择排序的时间复杂度为O(n^2)，在处理大规模数据时效率较低，不适用于对执行效率要求较高的场景。<br>无法利用输入数据的部分有序性：选择排序无法利用输入数据的部分有序性，其时间复杂度始终为O(n^2)，无法进行优化。<br>对相同元素的处理：选择排序在处理相同元素时可能会破坏它们的相对位置，不适用于对稳定性有要求的场景。</p><h2 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</p><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>重复第二步，直到所有元素均排序完毕。</p><h2 id="动图演示：-4"><a href="#动图演示：-4" class="headerlink" title="动图演示："></a>动图演示：</h2><p><img src="/sort_img/selectionSort.gif"></img></p><h2 id="具体代码-3"><a href="#具体代码-3" class="headerlink" title="具体代码"></a>具体代码</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, min; <span class="comment">// 定义循环变量i, j和记录最小元素位置的min变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层循环遍历数组，从第一个元素到倒数第二个元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        min = i; <span class="comment">// 假设当前下标i的元素为最小元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内层循环找出从i+1到最后一个元素中的最小元素的下标</span></span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[min]) &#123;</span><br><span class="line">                min = j; <span class="comment">// 更新最小元素位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果最小元素位置不是当前i，则交换当前位置i和最小元素位置的元素</span></span><br><span class="line">        <span class="keyword">if</span>(min != i) &#123;</span><br><span class="line">            swap(A[i], A[min]); <span class="comment">// 交换A[i]和A[min]的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p> 归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><pre><code>     自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；    自下而上的迭代；</code></pre><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h2 id="优点：-8"><a href="#优点：-8" class="headerlink" title="优点："></a>优点：</h2><p>高效稳定：归并排序的时间复杂度为O(nlogn)，效率高，适用于大规模数据的排序。同时，归并排序是一种稳定的排序算法，不会改变相同元素的相对位置。<br>分治思想：归并排序采用分治思想，将问题分解成小问题进行解决，使得算法易于理解和实现。<br>适用于链表排序：归并排序适用于链表结构的排序，不需要额外的存储空间。</p><h2 id="缺点：-8"><a href="#缺点：-8" class="headerlink" title="缺点："></a>缺点：</h2><p>需要额外空间：归并排序需要额外的空间来存储临时数组，空间复杂度为O(n)。<br>不适用于原地排序：由于归并排序需要额外空间，因此不适用于原地排序，可能在内存使用上有一定开销。<br>常数因子较大：虽然归并排序的时间复杂度较低，但由于常数因子较大，可能在实际应用中效率略低。</p><h2 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h2><pre><code>    1.申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；    2.设定两个指针，最初位置分别为两个已经排序序列的起始位置；    3.比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；    4.重复步骤 3 直到某一指针达到序列尾；    5.将另一序列剩下的所有元素直接复制到合并序列尾。</code></pre><h2 id="动图演示：-5"><a href="#动图演示：-5" class="headerlink" title="动图演示："></a>动图演示：</h2><p><img src="/sort_img/mergeSort.gif"></img></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> *a = arr; <span class="comment">// 指针a指向传入的数组arr</span></span><br><span class="line">    <span class="type">int</span> *b = (<span class="type">int</span> *) <span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配内存，b用于临时存储排序后的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> seg, start;</span><br><span class="line">    <span class="keyword">for</span> (seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123; <span class="comment">// seg为归并的步长，每次翻倍</span></span><br><span class="line">        <span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; len; start += seg * <span class="number">2</span>) &#123; <span class="comment">// 每次归并的起始位置</span></span><br><span class="line">            <span class="type">int</span> low = start, mid = min(start + seg, len), high = min(start + seg * <span class="number">2</span>, len); <span class="comment">// 划分要归并的两个子数组</span></span><br><span class="line">            <span class="type">int</span> k = low; <span class="comment">// k为合并后的数组起始位置</span></span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid; <span class="comment">// 第一个子数组的起始和结束位置</span></span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high; <span class="comment">// 第二个子数组的起始和结束位置</span></span><br><span class="line">            <span class="comment">// 合并两个有序子数组</span></span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果a不指向原数组arr，则将排序后的结果复制回arr</span></span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(b); <span class="comment">// 释放动态分配的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p> 插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><h2 id="算法步骤-7"><a href="#算法步骤-7" class="headerlink" title="算法步骤"></a>算法步骤</h2><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。</p><h2 id="优点：-9"><a href="#优点：-9" class="headerlink" title="优点："></a>优点：</h2><p>简单易实现：插入排序是一种直观易懂的排序算法，实现简单，适合初学者学习和实现。<br>原地排序：插入排序是一种原地排序算法，不需要额外的存储空间，节省内存开销。<br>对部分有序数据表现好：插入排序对部分有序的数据排序表现良好，时间复杂度可以达到O(n)。</p><h2 id="缺点：-9"><a href="#缺点：-9" class="headerlink" title="缺点："></a>缺点：</h2><p>效率低：插入排序的时间复杂度为O(n^2)，在处理大规模数据时效率较低，不适用于对执行效率要求较高的场景。<br>对大规模数据表现差：当数据规模较大时，插入排序的性能会下降，不如快速排序等高效排序算法。<br>不稳定性：插入排序是一种稳定的排序算法，但在处理相同元素时可能会破坏它们的相对位置，不适用于对稳定性要求较高的场景。</p><h2 id="动图演示：-6"><a href="#动图演示：-6" class="headerlink" title="动图演示："></a>动图演示：</h2><p><img src="/sort_img/insertionSort.gif"></img></p><h2 id="具体代码-4"><a href="#具体代码-4" class="headerlink" title="具体代码"></a>具体代码</h2> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=n;i++)<span class="comment">//依次将A2~An插入到前面已排序序列</span></span><br><span class="line"><span class="keyword">if</span>(A[i]&lt;A[i<span class="number">-1</span>])&#123; <span class="comment">//若Ai关键码小于前驱，将Ai插到前面</span></span><br><span class="line">A[<span class="number">0</span>]=A[i];<span class="comment">//复制为哨兵，A0不存放元素</span></span><br><span class="line"><span class="keyword">for</span>(j=i<span class="number">-1</span>;A[<span class="number">0</span>]&lt;A[j];--j)<span class="comment">//从后往前查找待插入位置</span></span><br><span class="line">A[j+<span class="number">1</span>]=A[j]; <span class="comment">//向后挪位</span></span><br><span class="line">A[j+<span class="number">1</span>]=A[<span class="number">0</span>]; <span class="comment">//复制到插入位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言基础</title>
      <link href="/2024/07/08/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/07/08/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p> C语言基础</p><h1 id="变量及常量"><a href="#变量及常量" class="headerlink" title="变量及常量"></a>变量及常量</h1><p>1，C语言当中的变量种类：</p><h2 id="局部变量-x2F-临时变量："><a href="#局部变量-x2F-临时变量：" class="headerlink" title="局部变量&#x2F;临时变量："></a>局部变量&#x2F;临时变量：</h2><pre><code>        特点：            1，在函数里面去定义的变量或者是在&#123;&#125;定义的变量            2，只能够在当前函数内部使用            3，函数一旦结束，该变量也对应的会被销毁（释放内存）            4，如果变量没有赋予初值，里面数值将会是乱码</code></pre><h2 id="全局变量："><a href="#全局变量：" class="headerlink" title="全局变量："></a>全局变量：</h2><pre><code>        特点：            1，定义在函数之外的变量            2，能够在整个程序中使用            3，一旦声明，在整个程序的运行过程中都会存在，不会销毁            4，如果变量没有赋予初值，里面的数值将会是0            </code></pre><h2 id="两者相结合的对比："><a href="#两者相结合的对比：" class="headerlink" title="两者相结合的对比："></a>两者相结合的对比：</h2><p>1，如果在函数外面定义了一个全局变量，刚好在函数里面有定义一个跟全局变量一样名字的局部变量，会优先使用局部变量（就近原则）<br>2，变量的命名方式<br>    1，严格区分大小写（一般在linux的变量命名，我们采用的是小写结合_的方式）<br>    2，不能以数字开头，其名字当中不允许出现出_之外的特殊符号<br>    3，在同一个层次中，是不允许变量重名的</p><p>3，变量各种声明的方式<br>    例如：<br>            int var；<br>            var &#x3D; 10；<br>            int var1&#x3D;10；<br>            int var2, var3;<br>            int var4&#x3D;10, *var5, var6[10];</p><h2 id="变量的声明分析："><a href="#变量的声明分析：" class="headerlink" title="变量的声明分析："></a>变量的声明分析：</h2><pre><code>        int i;            1，申请一片内存，以后i就是这片内存的别名            2，这片内存是一片int的内存，决定了两件事情：                    1，决定了申请的内存大小                    2，决定了以后用何种方式来分析这一片内存        i=10；            通过i这个别名访问到对应的内存，往里面赋值10            </code></pre><h2 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h2><pre><code>整型常量：    123：十进制整型常量，计算类场景引用    0123：八进制的常量，权限类场景引用，一位代表三位二进制    0x123, 0X123：十六进制的常量，底层场景引用，一位代表四位二进制    123U：常量声明类型的方式，默认123是整型，但是123U就变成了无符号的整型浮点常量：    3.14:普通的浮点数    3.14e2：科学计数法的浮点数    3.14E-2:科学计数法的浮点数    字符常量：    依照国际的ASCII码来去存放一个字符        原理是：一个对应的数字来代表一个字符        ps：系统当中如何打开ascii表格：man ascii            &#39;a&#39;：普通的字符常量，其实他就是数字  97    ‘\n’：转义序列，他代表换行动作    ‘\144’：转义字符，默认将后面的数值以八进制的方式找到对应的ascii的字符表示出来    &#39;\x45&#39;：转义字符，默认将后面的数值以十六进制的方式找到对应的ascii的字符表示出来    &#39;\\&#39;：这个一个\的字符        字符常量一般除了转义序列跟转义字符之外，一般是不允许有多个字符在&#39;&#39;里面的    字符串型常量：    &quot;abc&quot;：里面随便放        特点：            字符串其实是首个字符的地址            字符串默认会在其后面的结束位置自动补充一个&#39;\0&#39;字符                    所有&quot;abc&quot;虽然看上去是3个字符，但其实他的大小是4个字符的大小            类型char *        </code></pre><h2 id="变量类型："><a href="#变量类型：" class="headerlink" title="变量类型："></a>变量类型：</h2><pre><code>    int：整型        大小：一般32位        分析方式：            最高位为符号位，剩下的31位为数据位            正数：符号位为0，剩下的31位按照原码的方式分析：            负数：符号位为1，剩下的31位按照原码的补码方式来进行分析；                                    原码：原本的数据解释出来是怎么样子的就是哪个样子            反码：原码按位取反            补码：反码+1                short：短整型        大小：一般16位        分析方式：            最高位为符号位，剩下的15位为数据位            正数：符号位为0，剩下的15位按照原码的方式分析：            负数：符号位为1，剩下的15位按照原码的补码方式来进行分析；                                    原码：原本的数据解释出来是怎么样子的就是哪个样子            反码：原码按位取反            补码：反码+1                long：长整型        大小：一般64位（在32位系统中是32位）        分析方式：            最高位为符号位，剩下的63位为数据位            正数：符号位为0，剩下的63位按照原码的方式分析：            负数：符号位为1，剩下的63位按照原码的补码方式来进行分析；                                    原码：原本的数据解释出来是怎么样子的就是哪个样子            反码：原码按位取反            补码：反码+1                    char：超级小整型（8位单片机里面使用），大小为8位数据        ascii最大值是127（用到7位数据）                    unsigned：无符号的整型：        没有符号位，全部都是数据位，全部都按照原码的方式去分析                            常量修饰符：        4294967295U：声明这个数值按照无符号的整型来去分析（如果是系统帮我们分析，他将会分析成为long型）                        char：用来存放字符类型        大小：8位        分析方式：按照ascii的方式去分析内存                赋值方式：            char  ch=&#39;a&#39;;            char  ch = 97;            char  ch = &#39;\141&#39;;</code></pre><h2 id="字符串存放形式："><a href="#字符串存放形式：" class="headerlink" title="字符串存放形式："></a>字符串存放形式：</h2><pre><code>        1，char *string = &quot;hello&quot;;            意思：                将&quot;hello&quot;字符串赋值给string这个指针变量                    h的地址给了string这个指针变量        2，char string[100] = &quot;hello&quot;;            意思：                将&quot;hello&quot;字符串的内容复制到数组string当中                </code></pre><h2 id="C语言当中的点缀："><a href="#C语言当中的点缀：" class="headerlink" title="C语言当中的点缀："></a>C语言当中的点缀：</h2><pre><code>            bool类型：                bool的值有两个true，false，用于判断条件            备注：                1，bool类型在上层语言他是判断的标准，在C语言当中被当成透明了，因为我们判断的条件是：                    C语言当中判断一个条件是真还是假，用非0或者0来判断的                2，在C语言中，用bool类型需要导入头文件&lt;stdbool.h&gt;                    </code></pre><h2 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h2><pre><code>    float：单精度浮点        大小：32位        保证小数点后6位精准            double：双精度浮点        大小：64位        保证小数点后15位        long double：多精度浮点        大小：128位        保证小数点后18位            判断浮点数是否相等，不能够按照常理出牌        float f=3.14；                if(f == 3.14)//这种判断将会得不出我们想要结果                只能按照约等于的思想来去操作数值</code></pre><p>if(f &gt;&#x3D; 3.14 &amp;&amp; f&lt;3.140001)  &#x2F;&#x2F;用约等的方式判断</p><h2 id="void型"><a href="#void型" class="headerlink" title="void型"></a>void型</h2><p>用来修饰函数返回值，参数列表及指针，其他不能修饰</p><h2 id="bool型"><a href="#bool型" class="headerlink" title="bool型"></a>bool型</h2><p>用来代表真或者假（true：真  false：假），是C99引入进来的一种类型，在我们代码中如需使用，需要导入stdbool.h这个头文件<br>图示：<br> <img src="\img\基础变量类型与分析.jpg"></img></p><h2 id="格式化输入输出"><a href="#格式化输入输出" class="headerlink" title="格式化输入输出"></a>格式化输入输出</h2><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><h3 id="函数格式："><a href="#函数格式：" class="headerlink" title="函数格式："></a>函数格式：</h3><p> int printf(const char *format, …);</p><h3 id="函数功能："><a href="#函数功能：" class="headerlink" title="函数功能："></a>函数功能：</h3><p>将format所指定的数据打印到标准输出设备（终端）<br>参数：<br>Format：指定要打印的东西，可以编写字符串进去里面<br>例如：printf(“hello world\n”);<br>也可已指定格式的输出：<br>Printf(“数字位%d\n”, 123);</p><p>…：代表是一个变参函数，参数根据format里面的内容来填充</p><p>综合描述过程：<br>            1，printf不是将数据直接输出，需要经过输出缓冲区<br>            2，printf的缓冲区具备行缓冲特性，如果打印的数据没有添加换行符，则不会立即打印，将会一直等到遇到’\n’或者是缓冲区满了才会输出（强制清除缓冲区）</p><h2 id="format的格式可以有哪些："><a href="#format的格式可以有哪些：" class="headerlink" title="format的格式可以有哪些："></a>format的格式可以有哪些：</h2><p>%d：打印一个int数据<br>%o：八进制打印一个int数据<br>%x：十六进制打印一个int数据<br>%hd：打印short数据<br>%hhd：打印char型的整数数据<br>%c：打印一个字符<br>%f：打印一个float<br>%lf：打印一个double<br>%llf：打印一个long double<br>%u：打印一个unsinged int<br>%hu：打印一个unsigned short<br>%s：打印一个字符串<br>%.2f：打印到小数点后2位<br>%10s：打印长度位10的字符串（如果未满10则用空格补齐）<br>%-10s：打印长度位10的字符串（如果未满10则用空格补齐）<br>%%：打印一个%号</p><p>printf(“\033[1;33m Hello World. \033[0m \n”);    \033[0m–清除颜色格式<br>颜色如下:<br>none         &#x3D; “\033[0m”<br>black        &#x3D; “\033[0;30m”<br>dark_gray    &#x3D; “\033[1;30m”<br>blue         &#x3D; “\033[0;34m”<br>light_blue   &#x3D; “\033[1;34m”<br>green        &#x3D; “\033[0;32m”<br>light_green -&#x3D; “\033[1;32m”<br>cyan         &#x3D; “\033[0;36m”<br>light_cyan   &#x3D; “\033[1;36m”<br>red          &#x3D; “\033[0;31m”<br>light_red    &#x3D; “\033[1;31m”<br>purple       &#x3D; “\033[0;35m”<br>light_purple &#x3D; “\033[1;35m”<br>brown        &#x3D; “\033[0;33m”<br>yellow       &#x3D; “\033[1;33m”<br>light_gray   &#x3D; “\033[0;37m”<br>white        &#x3D; “\033[1;37m”  </p><p>字背景颜色范围: 40–49<br>字颜色: 30–39<br>40: 黑                         30: 黑<br>41:红                          31: 红<br>42:绿                          32: 绿<br>43:黄                          33: 黄<br>44:蓝                          34: 蓝<br>45:紫                          35: 紫<br>46:深绿                        36: 深绿<br>47:白色                        37: 白色  </p><p>输出特效格式控制：<br>\033[0m  关闭所有属性<br>\033[1m   设置高亮度<br>\03[4m   下划线<br>\033[5m   闪烁<br>\033[7m   反显<br>\033[8m   消隐<br>\033[30m   –   \033[37m   设置前景色<br>\033[40m   –   \033[47m   设置背景色  </p><p>printf(“\033[2J”);</p><p>光标位置等的格式控制：<br>\033[nA  光标上移n行<br>\03[nB   光标下移n行<br>\033[nC   光标右移n行<br>\033[nD   光标左移n行<br>\033[y;xH设置光标位置<br>\033[2J   清屏<br>\033[K   清除从光标到行尾的内容<br>\033[s   保存光标位置<br>\033[u   恢复光标位置<br>\033[?25l   隐藏光标<br>\33[?25h   显示光标  </p><h2 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h2><p>1，scanf这个函数是用来从键盘中获取数据到指定的内存中的<br>格式：<br>int scanf(const char *format, …);<br>函数返回值：<br>成功通过scanf获取到多少个数据<br>他的引用方式例如：<br>scanf(“%d”, &amp;number);<br>从键盘中获取一个整型数放到number中，他中间经历了以下逻辑：<br> <img src="\img\scanf.png"></img><br>         1，scanf一经调用，便会将”开关”合上，也就是键盘可以开始向缓冲区中输入数据了，但是scanf并不是键盘输入什么东西马上就获取什么东西，他会等待一个’\n’（键盘敲下回车）<br>        2，一旦键盘敲下回车，他就会检查缓冲区当中的数据（如果缓冲区里面一开始是个’\n’，它会自动清除），会跟自己的””里面所声明的格式进行匹配，看看格式是否正确，如果格式是符合的，就将数据获取出来，并且记录scanf已经获取到了一个数据，并且看看是否””后面是否需要继续获取数据，如果需要则继续查看缓冲区是否有数据，按照1步骤重新监控数据，如果没有立即返回函数，返回成功获取到多少个数据。<br>        3，如果缓冲区的数据格式不符合，则scanf立即返回，不会将缓冲区里面的数据拿出来<br> <img src="source\img\输入输出函数的用法.jpg"></img></p><h2 id="类型转换："><a href="#类型转换：" class="headerlink" title="类型转换："></a>类型转换：</h2><h3 id="隐式类型转换："><a href="#隐式类型转换：" class="headerlink" title="隐式类型转换："></a>隐式类型转换：</h3><p>1，赋值时，如果左边的精度比右边的精度高，右边会隐式类型转换配合左边的数据<br>例如：float fl &#x3D; 123;<br>2，赋值时，如果右边的精度比左边的精度高，有可能会出现数据丢失，只保留左边的数据存储得下的数据。（编译器严格的情况下会给你报警告），一般这种操作为了消除警告，在有把握的情况下会进行强制类型转换<br>例如：short sh &#x3D; 100000000;<br>3，运算的时候，当低精度数据类型与高精度数据进行运算的时候也会进行转换，将低精度转化为高精度<br>例如：1.0&#x2F;2的时候，会先将2转化为浮点型数据，然后计算出结果，得出0.5。<br>但是如果是大家的类型是一样的，就不会出现隐式类型转换<br>例如：3&#x2F;2的时候，是不会转化任何类型的，得出的数据还是整型，得出结果为1</p><h3 id="强制类型转化："><a href="#强制类型转化：" class="headerlink" title="强制类型转化："></a>强制类型转化：</h3><p>强制类型转换时什么：<br>int a &#x3D; -1;<br>(unsigned int )a;<br>本质就是强制改变变量或者是内存的分析方式。</p><p>将高精度往低精度转换我们可以用强制类型转换，这个时候就不会报警告<br>首先应该明确一点，我们应该要极少的使用这种转换方式，因为他有可能会给你带来数据的丢失，或者是数据解释异常<br>一般拿强制类型转换去做地址转换：<br>例如：某寄存器地址为0x12345678，但是这个值默认会解释为整型数，为了让他当做内存地址来使用，我们会给他强制类型转换一下（unsigned long *）0x12345678;</p><h1 id="循环和分支语句"><a href="#循环和分支语句" class="headerlink" title="循环和分支语句"></a>循环和分支语句</h1><h2 id="控制流："><a href="#控制流：" class="headerlink" title="控制流："></a>控制流：</h2><h3 id="分支跳转语句："><a href="#分支跳转语句：" class="headerlink" title="分支跳转语句："></a>分支跳转语句：</h3><pre><code>if：分支语句格式1：    if(表达式语句（判断语句）)    &#123;        执行表达式;        ...    &#125;        逻辑过程：        会先来判断括号当中的 表达式语句 是真还是假，如果是真则执行花括号里面的内容，如果假则不执行            特点：        如果“执行表达式;”只有一条，那我们可以不加花括号        if语句里面可以嵌套自己        一般情况下我们都会使用花括号将代码括起来，并且花括号独占一行，if及else语句也独占一行，这样有助于我们的逻辑缜密清晰        else总是跟最近的if配对        格式2：    if(表达式语句（判断语句(条件)）)    &#123;            如果条件为真的表达式;        ...    &#125;    else    &#123;        如果条件为假的表达式语句        ...    &#125;        逻辑过程：        会先来判断括号当中的表达式语句是真还是假，如果是真则执行if下面的花括号里面的内容，如果假则执行else下面的花括号的内容                        switch：多路分支语句    格式：        switch(整型变量)        &#123;            case 值1:                    执行语句;                    break;            case 值2：                    执行语句;                    break;            default:                    执行语句;        &#125;                值可以是一个区间：            case 某个值 ... 另外一个值：            这种方式规定区间                                逻辑过程：            判断switch括号中的&quot;整型变量&quot;的值是多少，然后从下面的case中找到有没有相等的值，有则直接进入对应语句运行，没有则运行default里面的语句        特点：            default语句可以不加，default语句不管放在哪里都可以，但是所有的判断照旧，不会default的位置改变而改变            break：在这里面叫做跳出switch语句，如果没有遇到break语句，程序会按照顺序从入口一直执行到遇到break或者是switch语句结束                        整型变量：            switch当中的小括号的内容必须得是一个整型数据(int long short char enum等)，不能够是浮点型或者字符串等非整型数据                        goto：跳转语句    格式：    goto  标签;        标签名:        执行语句        ...                从程序的某处调用goto可以跳过去标签所在地的代码中运行；                注意：            1，goto语句一般会直接跳转到函数的出口（一般都是出错处理）            2，标签一旦运行他会一直往下面走，直到函数退出或者goto到别的地方            3，在出错退出的时候定义一套动作，多个接口            4，慎用goto（不要乱来），因为它会破坏C语言的面向过程性</code></pre><p>逻辑思维图：<br> <img src="source\img\循环与分支.jpg"></img></p><h2 id="循环控制："><a href="#循环控制：" class="headerlink" title="循环控制："></a>循环控制：</h2><pre><code>while    格式：    while(条件)    &#123;        表达式;    &#125;    逻辑过程：        1，先判断条件是否为真，如果为真则执行花括号中“表达式”的内容，如果为假，则直接跳出循环        2，如果执行完“表达式”的内容了，会重新回来判断条件是否成立，重复上面的1动作do while    格式：    do&#123;        表达式    &#125;while(条件);    逻辑过程：        先判断执行花括号“表达式”的内容，在过来判断条件是否为真，如果为真则再次执行花括号中“表达式”的内容，如果为假，则直接跳出循环        for：    格式：        for( 初始化表达式; 判断表达式; 补充表达式)        &#123;            执行语句；        &#125;        逻辑过程：            1，一开始执行for会先执行“初始化表达式”，而且是有且只有一次执行            2，接下来去判断&quot;判断表达式&quot;的内容是否为真，为真则开始执行“执行语句”，否则退出循环            3，当我们执行完“执行语句”，会先运行“补充表达式”的内容，在继续判断条件是否为真，以此循环</code></pre><p>break：<br>        作用：<br>            跳出循环体或者是switch语句，一个break跳出一个；<br>            逻辑过程，一旦遇到直接跳出，不会拖泥带水</p><p>continue：<br>        作用：<br>            continue只作用于循环体<br>            跳过continue下面的语句，直接进入下一次循环<br>            注意的地方：<br>                他作用在for的时候，进入下一次循环的时候还是会运行“补充表达式”的</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="赋值运算："><a href="#赋值运算：" class="headerlink" title="赋值运算："></a>赋值运算：</h2><pre><code>var = value；例如：    var = 100；    注意的地方:    等号坐标被我们称之为左值，左值必须是一个能够更改的内存        1，例如：                变量名 = 数据值;                    int a;                    a = 100;            注意：                    不能够出现左边是一个运算                    a+100 = 200；                                    具体的内存 = 数据值;                </code></pre><p>volatile：<br>    由该关键字修饰的内存或者变量具备实时访问特性（防止优化）<br>    广泛的用来去修饰寄存器的地址</p><h2 id="算术运算符："><a href="#算术运算符：" class="headerlink" title="算术运算符："></a>算术运算符：</h2><pre><code>    +：加法，一目取正    -：减法，一目取负    *：乘法    /：除法    %：取余，比较大的作用，将某个数据限制在指定的范围之内    ++：        ++a：            先将a+1重新赋值给a， ++a的表达式当做是新的a的值                    a++：            表达的值用a的旧值，然后再将a+1重新赋值给a            --：        --a：            先将a-1重新赋值给a， --a的表达式当做是新的a的值                    a--：            表达的值用a的旧值，然后再将a+1重新赋值给a                        </code></pre><h2 id="关系运算符："><a href="#关系运算符：" class="headerlink" title="关系运算符："></a>关系运算符：</h2><pre><code>    &gt;：大于    &gt;=：大于等于    &lt;：小于    &lt;=：小于等于    ==：等于    !=：不等于        以上判断关系如果成立返回1，不成立返回0            </code></pre><h2 id="逻辑运算符："><a href="#逻辑运算符：" class="headerlink" title="逻辑运算符："></a>逻辑运算符：</h2><pre><code>    &amp;&amp;：并且        在C语言中，如果&amp;&amp;的前面表达式为假，则接下来的判断语句全部都不会执行            ||：或者        在C语言中，如果||的前面表达式为真，则接下来的判断语句全部都不会执行            ！：逻辑取反（就是真变假，假变真）        非0数值逻辑取反变成0,0逻辑取反变成1        </code></pre><h2 id="位运算符：（按二进制级别的操作）"><a href="#位运算符：（按二进制级别的操作）" class="headerlink" title="位运算符：（按二进制级别的操作）"></a>位运算符：（按二进制级别的操作）</h2><pre><code>    ~：按位取反运算        不要跟逻辑取！反搞混了    &amp;：按位与运算        对比：            a&amp;b：位与运算            a&amp;&amp;b：逻辑判断a条件跟b条件是否同时成立            &amp;a：取a变量的内存地址    |：按位或运算        对比：            a|b：位或运算            a||b：逻辑判断a条件或者是b条件是否成立，有一个成立则成立                ^：按位异或运算        相同得0，不同得1        简单的加密：            特点：任意的两个值异或出来都可以得出第三个值                &lt;&lt;：左移运算        所有的二进制数据全部进对应的位数，溢出的直接丢掉，空余出来的位置，直接补0            &gt;&gt;：右移运算        所有的二进制数据全部退对应的位数，溢出的直接丢掉，空余出来的位置，直接补0</code></pre><p>逻辑思维图：<br> <img src="\img\运算符.JPG"></img></p><h2 id="复合赋值运算符："><a href="#复合赋值运算符：" class="headerlink" title="复合赋值运算符："></a>复合赋值运算符：</h2><pre><code>    += ,-=, /=, *=, %=, &gt;&gt;=, &lt;&lt;=, &amp;=, |=, ^=    例如：        a += 10；        等价于        a = a+10;        a*=2+3;//等价于a = a*(2+3)</code></pre><h2 id="三目运算："><a href="#三目运算：" class="headerlink" title="三目运算："></a>三目运算：</h2><pre><code>条件 ? 成立则返回这个 : 不成则返回这个;</code></pre><p>a&gt;b?a:b;<br>格式：<br>判断条件 ? 如果条件为真，这条表达式的值就是整个三目运算符的值 : 否则则是这条表达式;</p><h2 id="逗号表达式："><a href="#逗号表达式：" class="headerlink" title="逗号表达式："></a>逗号表达式：</h2><pre><code>整个表达式的值等于最后一个逗号表达式的值例如：    a=10, b=200, c=a+b;    这个表达式的值等于c=a+b这个表达式的值，也就是210    整条逗号表达式的值由最后一条表达式所决定用途：    在有限的表达式位置当中，为了更好的处理更多语句，我们才使用逗号表达式</code></pre><h1 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h1><pre><code>功能：将代码进行整体封装，方便后期调用的一种形式格式：    修饰关键字   函数的返回值类型   函数名(函数的形式参数列表)    &#123;        函数体;//执行代码            return   value;//函数的结束语句，其中value就是需要返回给调用者的返回值    &#125;        例子：        static int func_name(int arg1, char arg2)        &#123;            ...            return 0;        &#125;        修饰关键字：默认不加        常用的修饰关键字：static online ...        函数的返回值类型：代表该函数的调用会返回什么样的数据类型的数据        如果函数没有返回值：是什么情况呢：不成功便成仁的情况，我们会用void去修饰</code></pre><p>void 不成功便成仁的情况<br>int 调用是否成功<br>其他类型：返回了一个资源</p><pre><code>            return照样函数的出口，只是后面不需要写返回值        只能写一个类型        以后函数的调用的整条语句就等价于“函数返回值类型”这样的数据        函数名：该函数的名字，跟变量的命名规范是一样的        函数的命名要竟可能贴近函数所实现的功能        函数的参数列表：如果没有则写void，如果有则对应的声明各个参数的类型及名字        就是函数里面的变量，只是它比较特别：        他的初值由调用函数的人传给他，就是实参传输给形参        函数里面的变量特点在于：在函数被调用的时候生成，执行完函数之后会被销毁掉        如果函数不需要传入参数，一般我们都会写上void        一般函数的参数个数不会超过6个        函数体：你要执行的代码        return：作为函数的结束标志，并且将后面的数据返回给调用该函数的人        return 后面是允许各种表达式及变量及常量的数据，只要类型与“函数的返回值类型”一致，即可        return后面只允许返回一个值；        不要去返回一个临时变量的地址，因为临时变量（函数里面定义的变量）在函数结束的时候就会被销毁，返回其地址肯定是不切实际的                                        </code></pre><h2 id="函数如何调用："><a href="#函数如何调用：" class="headerlink" title="函数如何调用："></a>函数如何调用：</h2><pre><code>        函数名(传入参数)即可调用，函数调用的整个表达式会返回一个函数内部所返回的值        函数调用时所传入的数据被我们称之为实参        在函数的格式声明当中的参数列表被我们称之为形参    </code></pre><h2 id="函数诞生目的："><a href="#函数诞生目的：" class="headerlink" title="函数诞生目的："></a>函数诞生目的：</h2><pre><code>        1，合理的将代码集成在一起，降低代码的重复率        2，提高代码的可读性        3，提高代码的开发效率，实现一个接口实现一套动作，我们不用去分心了解函数里面的内容            温馨提示：        1，程序的入口永远都是main函数，不会因为main所在的位置靠后而影响及执行过程        2，main里面尽量不要定义太多变量</code></pre><h2 id="函数的声明："><a href="#函数的声明：" class="headerlink" title="函数的声明："></a>函数的声明：</h2><pre><code>        声明函数的格式如何使用，            1，函数的声明语句是为了你检查函数调用有没有语法格式问题提供依据            2，内部声明及外部声明                内部声明语句，只需要将函数头放过来，用分号结尾即可                    例如：                        void func(int);                        其中，里面的形式参数列表中的变量名可以不写                外部声明语句，只需要将函数头放过来，用分号结尾，以extern关键字开头即可                    例如：                        extern void func(int);                        声明这个函数不在当前.c文件中                </code></pre><h2 id="外部声明关键字："><a href="#外部声明关键字：" class="headerlink" title="外部声明关键字："></a>外部声明关键字：</h2><pre><code>        extern：修饰描述的声明语句是定义在外面的，不要在里面去寻找它的定义，给你一个引用的标准        作用：        1，提高编译的效率        2，提高了代码的可读性        </code></pre><h2 id="函数的经典应用："><a href="#函数的经典应用：" class="headerlink" title="函数的经典应用："></a>函数的经典应用：</h2><pre><code>    回调函数：在本程序当中封装了函数的主体，然后给其他函数内部调用的形式称之为回调            设计到一个概念：函数指针：函数名                递归函数：函数自己调用自己        本质上面来说，除非特殊情况，不然少用递归            什么情况下慎用呢：                1，递归层数过多的情况最好不要用递归                2，代码如果可以for来去搞定的事情也不要用递归，因为递归需要消耗各种内存跟指令                递归的调用窍门：            1，明确你的递归函数的功能是什么            2，在递归函数中只实现当前层数的功能，剩下的内容交给下一个调用自己的过程来做            3，递归函数一定要有出口</code></pre><p> <img src="\img\分析与递归函数.jpg"></img></p><pre><code>    指针函数：返回值是一种指针类型函数就是指针函数    函数指针：存放函数的名字（本身就是地址）的指针变量    </code></pre><h2 id="变参函数："><a href="#变参函数：" class="headerlink" title="变参函数："></a>变参函数：</h2><pre><code>        格式：            返回值类型  函数名( const char *format, ...)            &#123;                va_list list;//诞生一个用来装参数位置的变量，规定一定是va_list这种类型                                va_start(list, format);//获取接下来的参数位置，其中list是以后的参数位置会更新到这个变量中                    ，format是第一个变参函数的参数，起到参考位置的作用                                va_arg(list, 什么类型分析);//获取变参函数format参数之后的参数，每获取一次，位置自动偏移到下一个                    ，位置会更新到list这个参数中                                va_end(list);//销毁参数的缓冲区            &#125;            传入参数个数可以变的函数        1，参数的参数中，第一个参数必须得是字符串，有两个作用            1，在变参函数中，作为参数的起始位置来去寻找之后的参数用的            2，指明后面的参数按照什么格式去分析他，有点像printf函数这类的用途        2，用变参函数需要导入头文件&lt;stdarg.h&gt;    </code></pre><h2 id="字符串操作函数："><a href="#字符串操作函数：" class="headerlink" title="字符串操作函数："></a>字符串操作函数：</h2><pre><code>    这里面所有函数的字符串结束判断标志都是&#39;\0&#39;    strlen：用来测量字符串的长度（不包含&#39;\0&#39;）        size_t strlen(const char *s);        s：需要测量的字符串        返回值：返回字符串的长度            strcmp：        int strcmp(const char *s1, const char *s2);        用来比较s1及s2两个字符串是否一样        int strncmp(const char *s1, const char *s2, size_t n);        用来比较指定长度为n值的s1及s2两个字符串是否一样        返回值：            如果两个字符串相等则返回0，如果s1比s2要大，则返回正数，否则则返回负数                其比较的原理是将两个字符串一个一个字符相减，如果有字符不等，那肯定差值不为0，如果对应位的s1的字符比s2的字符大，则返回正数            ，否则则返回负数                    strcpy：将字符串拷贝到一片内存中        char *strcpy(char *dest, const char *src);            将src字符串的内容拷贝到dest的内存中            注意：                dest必须得是可以改变的内存（能够写入的合法的内存）        char *strncpy(char *dest, const char *src, size_t n);            指定长度n的字符串拷贝            注意：                n值是不包括&#39;\0&#39;，你拷贝的n值大小要预留&#39;\0&#39;的位置出来                    strcat：将两个字符串连接在一起        char *strcat(char *dest, const char *src);            将src字符串写到dest字符串的后面去，衔接在一起        char *strncat(char *dest, const char *src, size_t n);            指定src中的n个字符与dest衔接在一起</code></pre><h1 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h1><p>将多个同种类型的数据合并在一起的复合类型</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><pre><code>    1，一次性声明多个同种类型的内存出来，用一个名字来代表    2，里面的每一个单位我们把它称之为元素，每一个元素内存都是按照顺序连续在一起的    3，数组的特殊符号[]        </code></pre><h2 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h2><pre><code>    类型  数组名[数组的元素个数];            例如：        int array[3];                意思就是一次性申请了3个int的内存，然后以后通过array这个名字来统一操作                array[0] = 100;                        上面的意思是去引用数组的第0个元素，将其赋值为100        注意：            数组的第几个元素称之为数组的下标            数组的下标都是从第0个开始，最大的访问下标是该数组元素个数-1                                    </code></pre><h2 id="初始化方式："><a href="#初始化方式：" class="headerlink" title="初始化方式："></a>初始化方式：</h2><pre><code>    格式：        类型 数组名[数组元素的个数] = &#123;初始化的值&#125;;                例如：            int array[3] = &#123;100, 200, 300&#125;;                        </code></pre><h2 id="几种情况："><a href="#几种情况：" class="headerlink" title="几种情况："></a>几种情况：</h2><pre><code>            只要类型匹配，初始化的值可以是个变量            初始化越界：                例如：                int array[3] = &#123;100, 200, 300,400&#125;;//元素个数只有3个，你却给他4个值，这样直接语法错误                            初始化不全：                int array[3] = &#123;100&#125;;//他会按照顺序初始化从０下标开始一个一个赋值过去，如果后面的下标没有指定初值，则直接设置０            自动设置数组元素个数的情况                int array[] = &#123;100, 200&#125;;//他会根据后面的初始值个数，来去决定数组元素的个数                在多维数组中，其自动设置数组的大小只能不写最前面的一个数组元素个数，其他都不能不写                                        字符串数组的初始化形式：            char string[10] = &#123;&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;;//后面没有初始化的值还是置为０，而０就是&#39;\0&#39;            char string[] = &#123;&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;;//后面没有初始化的值还是置为０，而０就是&#39;\0&#39;            char string[100] = &quot;hello&quot;;//只允许字符串这样初始化赋值，将&quot;hello&quot;里面的内容拷贝到string这个数组中            char string[] = &quot;hello&quot;;//自动适应后面字符串的内容来决定数组的个数，当然是包含&#39;\0&#39;                    千万不要出现声明完数组之后，想要在下面的代码直接用字符串初始化其内部元素        例如：            char string[100];                        string = &quot;hello&quot;;//这就会语法错误，因为string是个数组名字（常量），不能直接给他赋值</code></pre><h2 id="数组元素的访问的形式："><a href="#数组元素的访问的形式：" class="headerlink" title="数组元素的访问的形式："></a>数组元素的访问的形式：</h2><pre><code>    数组名[下标]：                例如：array[0];    下标[数组名]：                例如：0[array];                                注意事项：数组的名字是个常量，不允许改变，只有访问到具体哪一个元素的时候才能往里面赋值数组名字的本质是其首个元素的地址，等明天解释究竟我们应该如何看待数组的声明语句：    int array[2];//这句话在编译器中的解释是：我要申请一片内存，这片内存的别名叫做array，分析到[]，决定他是个数组，数组里面有2个元素        ，每个元素是int类型（决定了每个元素大小为int这么大，解释方式用int来解释）        array[0] = 100;//解引用数组的第0个元素(其实就是数组的第0块内存)，往里面赋值为100；        </code></pre><h2 id="多维数组："><a href="#多维数组：" class="headerlink" title="多维数组："></a>多维数组：</h2><p>数组里面再嵌套数组：<br>            int array[2][3];&#x2F;&#x2F;这句话在编译器中的解释是：我要申请一片内存，这片内存的别名叫做array，接下来看到[2]决定他是一个数组，里面<br>                有2个元素，里面两个元素放什么呢？接下来看到[3]，代表里面的元素又是一个数组，数组里面有3个元素，然后再看到int，决定里面<br>                的元素放的是int型数据</p><pre><code>        多维数组的最小元素的个数由每一层数组下标所决定，例如这里面就是2*3等于6个                每层的数组都有自己对应的下标，下标最大值还是其声明的个数-1        </code></pre><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针的概念："><a href="#指针的概念：" class="headerlink" title="指针的概念："></a>指针的概念：</h2><pre><code>指针：专门用来存放地址的一种类型</code></pre><p> <img src="\img\指针.png"></img></p><h2 id="作用场景："><a href="#作用场景：" class="headerlink" title="作用场景："></a>作用场景：</h2><pre><code>1，在函数的调用的时候想要改变某片内存的值备注：指针最多只用到二维，而且二维只会在函数参数列表中出现，                注意，改变哪片内存就应该传入哪片内存的地址2，访问匿名内存        在代码里面直接定义指针变量的作用就是为了存放匿名内存    指针的偏移（偏移的大小由类型所决定）：    int in;    char ch;    in+1;//偏移一个int这么大的内存    ch+1;//偏移一个char这么大    还可以进行的运算：    int *point;    point+2;    point-2;    point++;    point--;    同等类型的指针可以用来相减：    Int *p = malloc(100);    Int *q = p+2;    q-p 用来测量两者相差多少个单位    同等类型的指针可以用来比较(可以引用关系运算符)    q&gt;p 用来判断q的内存地址是否在p之后    其他运算符通通不能使用3，优化内存        大类型数据传输我们一般采用指针，而且是const类型的指针（除非你想要给别人改变你这块内存）</code></pre><h2 id="内存地址："><a href="#内存地址：" class="headerlink" title="内存地址："></a>内存地址：</h2><p>所谓内存地址其实就是一个数字，代表其内存在我们所谓的“大楼”（内存映射）当中的第几楼<br>内存地址跟指针变量他跟平台的位数是一样的，例如你是32位系统你的地址就是32位，如果是64位系统，那就是64位<br>我们先阶段操作的内存地址都是虚拟内存地址</p><pre><code>特点：    指针变量我们是不会定义三维及以上的，二维只有函数参数列表中出现，其他我们也不用    二维的使用只有一个原因：想要在函数调用的时候改变指针变量的值        指针变量的大小永远等于系统位数大小    在声明语句当中的*是没有动作的，都是类型的修饰，只有在表达式语句中的*才代表解引用    分析多维指针的时候应该注意，只分析第一个*是个指针变量类型，用来存放地址，剩下来的所有东西都是修饰以后去到那块内存地址如何分析罢了    int *pp;    int **p;//我诞生一个变量p，分析到跟他最近的*号，决定了这个p变量是个指针变量，用来存放地址，剩下来的int *决定以后如何分析所登记的内存地址    p = &amp;pp;</code></pre><h2 id="野指针："><a href="#野指针：" class="headerlink" title="野指针："></a>野指针：</h2><pre><code>        没有赋予初值的指针，一定不要出现野指针，不要有野指针操作        有可能内存越界的风险，程序便有可能陷入异常</code></pre><h2 id="NULL指针："><a href="#NULL指针：" class="headerlink" title="NULL指针："></a>NULL指针：</h2><pre><code>        一旦访问马上崩溃的指针，为了有效的防止野指针，我们一般都会指针变量赋予初值，如果还没决定初值，则直接赋值为NULL                    什么时候会出现段错误Segmentation fault (core dumped)：        你去操作一片没有权限的内存            内存当中一般有三种权限：                可读                可写                可执行        内存越界/内存泄漏        非法访问内存（你的代码随意改变了一片不属于你的内存），最难解决的bug（逻辑出bug比较多）</code></pre><h2 id="通用型指针引用方式："><a href="#通用型指针引用方式：" class="headerlink" title="通用型指针引用方式："></a>通用型指针引用方式：</h2><pre><code>    type  i;//type代表任意类型        type *point = &amp;i;//type代表任意类型    *point = 数据；//等价于 i = 数据;        </code></pre><h2 id="指针的运算："><a href="#指针的运算：" class="headerlink" title="指针的运算："></a>指针的运算：</h2><pre><code>    加减运算：指针的偏移，单位由指针的类型所决定    point+1：地址向后偏移1个单位    point-2：地址向前偏移2个单位    point++：指针变量允许自加，圈起来，变量两个字    point--：指针变量允许自减    point2-point1：只允许两个同种类型的指针相减，代表相差多少个单位，单位由类型所决定    指针不能相加</code></pre><h2 id="指针跟数组的对比："><a href="#指针跟数组的对比：" class="headerlink" title="指针跟数组的对比："></a>指针跟数组的对比：</h2><pre><code>相同的地方：    指针跟数组的解引用可以互换    *(point+1)等价于point[1];        不同得地方：    数组名字不能自加自减，指针变量可以    </code></pre><p>思维图：<br> <img src="\img\指针的概念.jpg"></img></p><h1 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h1><h2 id="函数传参当中"><a href="#函数传参当中" class="headerlink" title="函数传参当中"></a>函数传参当中</h2><p>数组传输名字进去给函数作为形参，注意他是以地址的形式传输进去的，不管你的函数的形参怎么写：<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *arg)</span>  跟 <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arg[])</span>两者完全等价</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">func(<span class="built_in">array</span>);</span><br></pre></td></tr></table></figure><p>所以我们传输数组的时候记得一定要传输数组元素的个数，不然函数是无法得知数组的大小的，有一种比较特别：字符数组，字符数组一般都是用来放字符串的，而字符串自带结束标志’\0’</p><h2 id="指针数组的异同："><a href="#指针数组的异同：" class="headerlink" title="指针数组的异同："></a>指针数组的异同：</h2><h3 id="概念上的区别"><a href="#概念上的区别" class="headerlink" title="概念上的区别"></a>概念上的区别</h3><pre><code>    数组的概念是：    一片连续且相同类型的有效内存，你可以通过数组名结合下标的形式访问其内存    例如：int array[3];            array[1] = 100;    这个是数组给你带来的本质操作，你没有必要去指针操作        指针的概念是：用来存放地址的类型或者变量，但是我们的指针一开始是没有有效的指向内存的，你必须要给他一个有效内存的地址登记进去才能操作    例如：int *point;//野指针            *point = 100;//出错，指针没有有效的指向哪片内存，所以这步操作是不知道操作哪片内存的，很有可能出现段错误                        </code></pre><h3 id="权限上的区别"><a href="#权限上的区别" class="headerlink" title="权限上的区别"></a>权限上的区别</h3><pre><code>    数组的名字虽然是其首个元素的地址（经过编译之后转化），但是其名字是个固定的常量，不能更改，没有对名字更改的权限</code></pre><p>int array[3];<br>array &#x3D; malloc(100);&#x2F;&#x2F;错误，数组名字不能变</p><pre><code>        重点注意：数组需要引用到最底层的类型（最小的元素）才能够更改其内存；        例如：            int array[2][3];            array[1]  = 数据;//错误的，没有解引用到最后的元素            指针的名字就是变量，他可以任意的更改其地址</code></pre><p>int *p;</p><h3 id="从函数传参的特点："><a href="#从函数传参的特点：" class="headerlink" title="从函数传参的特点："></a>从函数传参的特点：</h3><pre><code>    数组的传参仅仅是将其数组名字的意义（所代表的地址传输进去），并没有将整个数组传输进去，不管参数列表当中是*还是[]，其代表的意义都是传输地址        例如：            void func(int array[]);            void func(int *array);    指针的传参跟普通变量的传参是一样的    </code></pre><h3 id="引用的特点："><a href="#引用的特点：" class="headerlink" title="引用的特点："></a>引用的特点：</h3><pre><code>    不一样的引用特点：        1，            sizeof去测量指针，得到的是系统位数的大小            sizeof去测量数组，得到的是整个数组的大小            例如：                int array[3];                int *point = array;                sizeof(array);//返回12                sizeof(point);//返回8，因为系统为64位                        2，上面第二点的注意事项中，让你没有办法更改数组名字的值                3，对于指针取地址，我们会得到二维指针类型            例如：                int *point;                &amp;point//他的类型就是int **            但是对数组进行取址操作，虽然这个名字是其首个元素的地址，但是他取出来的地址是对应数组地址的类型，不是二维指针                int array[3];//array的名字类型 int *</code></pre><p>int <em>point &#x3D; array;<br>                    &amp;array;&#x2F;&#x2F;他的类型是int (</em>)[3];<br>                    &amp;point;&#x2F;&#x2F;int **<br>        引用上面的相互转换：<br>            某某[2] 就等价于 <em>(某某+2)<br>                为什么呢：<br>                    []，</em>都是解引用的意思</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line"><span class="type">int</span> *point = <span class="built_in">array</span>;</span><br><span class="line"></span><br><span class="line">*point , <span class="built_in">array</span>[<span class="number">0</span>] , point[<span class="number">0</span>] , *<span class="built_in">array</span>;<span class="comment">//完全等价</span></span><br><span class="line"></span><br><span class="line">*(point+<span class="number">2</span>), point[<span class="number">2</span>], <span class="built_in">array</span>[<span class="number">2</span>], *(<span class="built_in">array</span>+<span class="number">2</span>)<span class="comment">//完全等价</span></span><br></pre></td></tr></table></figure><h2 id="数组跟指针的结合使用："><a href="#数组跟指针的结合使用：" class="headerlink" title="数组跟指针的结合使用："></a>数组跟指针的结合使用：</h2><pre><code>写声明语句及分析声明语句的特点：    从变量名字开始分析，然后就近原则解释其类型，一层一层剖析    </code></pre><h3 id="数组指针："><a href="#数组指针：" class="headerlink" title="数组指针："></a>数组指针：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*point)[<span class="number">3</span>];<span class="comment">//point是用来登记int [3]这种类型的数组的地址</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">point = &amp;<span class="built_in">array</span>;</span><br></pre></td></tr></table></figure><h3 id="指针数组："><a href="#指针数组：" class="headerlink" title="指针数组："></a>指针数组：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> *<span class="built_in">array</span>[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>] = &amp;i;</span><br></pre></td></tr></table></figure><h2 id="经典的指针："><a href="#经典的指针：" class="headerlink" title="经典的指针："></a>经典的指针：</h2><h3 id="函数指针："><a href="#函数指针：" class="headerlink" title="函数指针："></a>函数指针：</h3><pre><code>    系统给我们提供用来存放函数名字的类型（函数名字的本质经过编译之后，他会转化为一个地址，而且你对他进行取址操作，他还是等于自己）</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> (*point)(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">point = func;</span><br><span class="line"></span><br><span class="line">point(<span class="number">100</span>);<span class="comment">//以后指针名字可以充当函数名字用</span></span><br></pre></td></tr></table></figure><h3 id="指针函数："><a href="#指针函数：" class="headerlink" title="指针函数："></a>指针函数：</h3><pre><code>    返回值类型是一个指针类型的函数</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">func</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数指针数组：-x2F-x2F-用于传输一整套动作"><a href="#函数指针数组：-x2F-x2F-用于传输一整套动作" class="headerlink" title="函数指针数组：&#x2F;&#x2F;用于传输一整套动作"></a>函数指针数组：&#x2F;&#x2F;用于传输一整套动作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">func1</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="title function_">func2</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">。。。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> (*arr[<span class="number">2</span>])(<span class="type">int</span>);<span class="comment">//函数指针数组</span></span><br><span class="line">arr[<span class="number">0</span>] = func1;</span><br><span class="line">arr[<span class="number">1</span>] = func2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> a[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> (*<span class="built_in">array</span>[<span class="number">2</span>])[<span class="number">10</span>];<span class="comment">//数组指针数组</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">1</span>] = &amp;a;</span><br></pre></td></tr></table></figure><h3 id="void-指针："><a href="#void-指针：" class="headerlink" title="void *指针："></a>void *指针：</h3><pre><code>通配型指针：通配所有其他类型的指针void i;//不可以void *p;//可以，int a;p=&amp;a;//阔以，p兼容所有类型的指针*p = 100;//不阔以，p没有指定分析方式*(int *)p = 100;//阔以，你已经指定类型了</code></pre><p>应用场景：<br>经常作用于函数的返回值及函数的参数列表</p><p>const 指针：<br>限制权限：<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">array</span>[<span class="number">1023</span>];</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;;<span class="comment">//4k</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">display_a_memb_value</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> test *arg)</span><span class="comment">//在这里的作用是限制了这个指针的权限，只能读，不能改</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, arg-&gt;a);</span><br><span class="line">arg-&gt;a = <span class="number">250</span>;<span class="comment">//马上报语法错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">tt</span>;</span></span><br><span class="line">tt.a = <span class="number">100</span>;</span><br><span class="line">display_a_memb_value(&amp;tt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="关键字和作用域"><a href="#关键字和作用域" class="headerlink" title="关键字和作用域"></a>关键字和作用域</h1><h2 id="关键字："><a href="#关键字：" class="headerlink" title="关键字："></a>关键字：</h2><p>const：限制权限</p><p>volatile：易变的，由它修饰的变量或者内存拥有实时监测的特性，会实时留意其变动</p><p>static：静态的：<br>1，由static的临时变量，从原本应该从栈中分配的内存，变成了.bss或者是.data段里面去划分<br>2，由static修饰的临时变量不再随着函数的运行而申请内存，也不会随着函数的结束而释放内存，具备一次初始化特性<br>3，由static修饰的全局变量或者函数，变成文件作用域（只能够在当前文件访问，离开当前文件访问不了）<br>第三个作用是在大型代码中用的非常之多，为了防止命名冲突</p><p>注意：<br>以后我们定义的函数如果是要给别人调用的不用任何关键字修饰，如果只给自己用，要加static关键字</p><p>extern：外部声明：<br>可以声明一个在外定义的变量或者是函数在本文件中，这样我们在编译的时候就可以进行语法检验，用static修饰过的就不能用extern外部声明了</p><p>register：寄存器<br>他只能修饰临时变量，尝试申请CPU中的寄存器来作为变量，大大的提高数据读写效率与计算效率</p><h2 id="申请堆内存的函数："><a href="#申请堆内存的函数：" class="headerlink" title="申请堆内存的函数："></a>申请堆内存的函数：</h2><p>堆内存的操作：下面都是申请堆内存的函数<br>    堆内存有个特点，需要申请才会给你分配，需要调用free才能释放内存，其他怎么样都是释放不了的<br>        #include &lt;stdlib.h&gt;</p><pre><code>   void *malloc(size_t size);    申请一片大小位size的内存，返回其内存内存地址，失败返回NULL       void free(void *ptr);    释放申请的ptr所指向的堆的内存       void *calloc(size_t nmemb, size_t size);    申请nmemb这么多块内存，每块内存size这么大，成功返回地址，失败返回NULL       void *realloc(void *ptr, size_t size);    重置申请的ptr内存的大小为size，成功返回一个新的内存地址，会帮你继续保留原本内存的数据</code></pre><h1 id="内存段落分析"><a href="#内存段落分析" class="headerlink" title="内存段落分析"></a>内存段落分析</h1><p>程序段落说明：<br>几个特殊的sections说明：</p><h2 id="1-bss，该section包含了在内存中的程序的未初始化的数据，当程序开始运行时，系统将用0来初始化该区域。该section不占用文件空间，该section-type-x3D-SHT-NOBITS；"><a href="#1-bss，该section包含了在内存中的程序的未初始化的数据，当程序开始运行时，系统将用0来初始化该区域。该section不占用文件空间，该section-type-x3D-SHT-NOBITS；" class="headerlink" title="1..bss，该section包含了在内存中的程序的未初始化的数据，当程序开始运行时，系统将用0来初始化该区域。该section不占用文件空间，该section type &#x3D; SHT_NOBITS；"></a>1..bss，该section包含了在内存中的程序的未初始化的数据，当程序开始运行时，系统将用0来初始化该区域。该section不占用文件空间，该section type &#x3D; SHT_NOBITS；</h2><p>2..comment，该section包含了版本控制信息；</p><h2 id="3-data和-data1，该section包含了在内存中的程序的初始化数据；"><a href="#3-data和-data1，该section包含了在内存中的程序的初始化数据；" class="headerlink" title="3..data和.data1，该section包含了在内存中的程序的初始化数据；"></a>3..data和.data1，该section包含了在内存中的程序的初始化数据；</h2><p>4..debug，该section包含了符号调试信息，其中内容没有硬性规定；<br>5..dynamic，该section包含了动态链接信息，该section属性将包含SHF_ALLOC比特位，而SHF_WRITE比特位是否为1取决于处理器；<br>6..dynstr，该section包含了用于动态链接的字符串，通常是符号表项名称字符串；<br>7..dynsym，该section包含了动态链接符号表；<br>8..fini，该section包含了用于终止进程可执行指令代码；<br>9..got，该section包含了全局偏移表；<br>10..hash，该section包含了符号hash表；</p><h2 id="11-init，该section包含了用于初始化进程的可执行代码，也就是说，当一个程序开始运行的时候，系统将会执行在该section中的代码，然后才会调用程序的入口点（对于C程序而言就是main）；"><a href="#11-init，该section包含了用于初始化进程的可执行代码，也就是说，当一个程序开始运行的时候，系统将会执行在该section中的代码，然后才会调用程序的入口点（对于C程序而言就是main）；" class="headerlink" title="11..init，该section包含了用于初始化进程的可执行代码，也就是说，当一个程序开始运行的时候，系统将会执行在该section中的代码，然后才会调用程序的入口点（对于C程序而言就是main）；"></a>11..init，该section包含了用于初始化进程的可执行代码，也就是说，当一个程序开始运行的时候，系统将会执行在该section中的代码，然后才会调用程序的入口点（对于C程序而言就是main）；</h2><p>12..interp，该section包含了程序解释其的路径；<br>13..line，该section包含了符号调试信息的行号，其用于描述程序源代码和机器码之间的相应关系；<br>14..note，该section包含了供应商及程序兼容信息等；<br>15..plt，该section包含了程序链接表；<br>16..relname和.relaname，该section包含了relocation信息，该section的属性包括了SHF_ALLOC比特位，通常，name为将要被重组的section的名称，例如如果要重组.text，那么名称就为.rel.text或者.rela.text；</p><h2 id="17-rodata和-rodata1，该section包含了只读数据，通常进程中的不可写段，例如Program-Header；"><a href="#17-rodata和-rodata1，该section包含了只读数据，通常进程中的不可写段，例如Program-Header；" class="headerlink" title="17..rodata和.rodata1，该section包含了只读数据，通常进程中的不可写段，例如Program Header；"></a>17..rodata和.rodata1，该section包含了只读数据，通常进程中的不可写段，例如Program Header；</h2><p>18..shstrtab，该section包含了section名称；<br>19..strtab，该section包含了符号表项名称字符串，如果文件包含了一个可加载的并且包含了符号字符串表的segment，则section的SHF_ALLOC比特位属性将被设置；<br>20..symtab，该section包含了符号表，如果文件包含了一个可加载的并且包含了符号表的segment，则section的SHF_ALLOC比特位属性将被设置；</p><h2 id="21-text，该section包含了程序的可执行指令。"><a href="#21-text，该section包含了程序的可执行指令。" class="headerlink" title="21..text，该section包含了程序的可执行指令。"></a>21..text，该section包含了程序的可执行指令。</h2><p>虽然上面的例子文件中，对于text和data段而言，文件偏移和逻辑地址取模4KB后都是相等的。但是:<br>1.text的第一个页面包含了ELF header，program header table以及其他的信息；<br>2.text的最后一个页面包含了data的开始部分数据的拷贝；<br>3.data的第一个页面包含了text的末尾数据的拷贝；<br>4.data的最后一个页面也许包含了和运行进程不相关的文件信息；<br>理论上讲，系统对待每个段的内存权限都是相互独立的。段地址不得不调整来确保地址空间中的每个逻辑页面都有自己的权限；<br>在上面的例子中，包含了text结尾和data开始的区域将要被映射两次：一次就是包含了text和data开始部分，<br>另一个就是text末尾部分和data；data段的末尾还需要对为初始化数据的特殊处理，系统通常将其清零。</p><h1 id="复合结构："><a href="#复合结构：" class="headerlink" title="复合结构："></a>复合结构：</h1><h2 id="结构体："><a href="#结构体：" class="headerlink" title="结构体："></a>结构体：</h2><pre><code>    将多种数据类型合并成为一种总体结构类型的特殊体质    格式：</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> numb;</span><br><span class="line"><span class="type">short</span> age;</span><br><span class="line"><span class="type">char</span> name[<span class="number">256</span>];</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><pre><code>        上面声明了一种结构体类型，类型名字叫做struct student，这种类型里面包含了多种元素                比如这个时候想要用这种结构体类型声明一个变量            struct student var;//语法跟普通变量是一样的                    如果要访问结构体的元素，我们有两种形式：        1，通过结构体名字，用.符号来去引用里面的元素：            struct student var;            var.age = 100;                    2，可以通过结构体的内存地址来访问            struct student var;            struct student *ptr = &amp;var;            (*ptr).age = 100;            ptr-&gt;age = 200;//下面这两种语句的作用完全等价        一定要记住，大家都是访问其结构体元素的，.用的是结构体变量名字（结构体变量本身），        -&gt;是用的结构体变量的地址，去访问其元素的        声明了一种类型，他跟int等类型的操作是一样的，所以他可以直接进行变量之间的直接赋值操作        struct student var， var1;        var = var1；//没有问题        </code></pre><h2 id="结构体的初始化："><a href="#结构体的初始化：" class="headerlink" title="结构体的初始化："></a>结构体的初始化：</h2><pre><code>初始化：    1，先声明类型，然后通过类型定义变量    struct test&#123;        int a;        char string[256];    &#125;;//仅仅只是一个类型声明</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">aa</span> =</span> &#123;<span class="number">100</span>, <span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">bb</span> =</span> &#123;<span class="number">100</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">cc</span> =</span> &#123;.a = <span class="number">100</span>, .<span class="built_in">string</span>=<span class="string">&quot;hello world&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">dd</span> =</span> &#123;.<span class="built_in">string</span>=<span class="string">&quot;hello world&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><pre><code>    2，同时声明变量跟类型</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">256</span>];</span><br><span class="line">&#125;tt;<span class="comment">//声明了struct test类型，同时定义了一个这种类型的tt变量出来</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> <span class="built_in">string</span>[<span class="number">256</span>];</span><br><span class="line">&#125;tt=&#123;<span class="number">100</span>， “hello world”&#125;;<span class="comment">//第1点的都可以借鉴</span></span><br></pre></td></tr></table></figure><pre><code>取别名的方式：    了解typedef的语法：        typedef  变量声明语句；            例如： typedef int array[10];            以后array这个名字就会变成int [10]这种类型的别名            array i;//等价于 int i[10];        typedef void (*point)(int);                point p;    1，    /*将结构体类型struct test2 取了个类型别名，名字叫做st*/    typedef struct test2&#123;        char c;    &#125;st;            2,结合匿名结构体的思想，可以出现以下写法    /*定义了一个匿名结构体类型，并且给这个匿名结构体类型取个别名叫做obj*/    typedef struct&#123;        int a;        char b;    &#125;student;    以后student就是这个结构体的名字        </code></pre><h2 id="匿名结构体："><a href="#匿名结构体：" class="headerlink" title="匿名结构体："></a>匿名结构体：</h2><pre><code>    结构体可以没有名字：    struct student&#123;        int numb;        short age;        /*匿名结构体：结构体没有名字*/        struct &#123;            int a;        &#125;stt;    &#125;;    </code></pre><h2 id="结构数组跟指针的操作："><a href="#结构数组跟指针的操作：" class="headerlink" title="结构数组跟指针的操作："></a>结构数组跟指针的操作：</h2><pre><code>    跟普通的数据操作是一样的    struct student sd[3]=&#123;&#123;.numb=100&#125;, &#123;100, 200&#125;, &#123; .string="hello"&#125;&#125;;    </code></pre><h2 id="结构体的大小："><a href="#结构体的大小：" class="headerlink" title="结构体的大小："></a>结构体的大小：</h2><pre><code>    内存对齐的方式来去决定结构体的内存：        它会根据结构体元素当中的类型最大值来决定按照多少个字节对齐        在64位系统当中，最大的内存对齐字节数是16个字节        在32位系统当中，最大的内存对齐字节数是4个字节        元素存放的时候回根据自己元素的大小来去找到对齐的位置        </code></pre><h2 id="共用体-x2F-联合体：所有元素共享一片内存"><a href="#共用体-x2F-联合体：所有元素共享一片内存" class="headerlink" title="共用体&#x2F;联合体：所有元素共享一片内存"></a>共用体&#x2F;联合体：所有元素共享一片内存</h2><pre><code>    关键字：union    实现思想：一片内存，多种解释    语法跟struct一模一样    参照结构体的内容            共用体的大小：里面最大的元素的内存大小    </code></pre><h2 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h2><pre><code>    枚举整型常量    功能：        统一给一些整型数取别名（跟#define都点像）        格式：        /*            声明了一种枚举类型ｃｏｌｏｒ            语法跟结构体很像，但是有以下这么几个区别:            １，元素的结束符号从;变成了,最后一个元素不需要加符号            ２，里面的元素是不需要写类型的，默认都是整型            ３，里面的元素不是个变量，是个常亮来着（不能变）            功能：给里面的数字取个别名         */        enum color&#123;            red=&#39;a&#39;,            green,            blue,        &#125;;                匿名的方式定义枚举类型        enum &#123;            red=&#39;a&#39;,            green,            blue,        &#125;;        经过以上定义后，red等元素可以直接在代码当中被使用        例如：        int main(void)        &#123;            //enum color cl;//在Ｃ语言中，枚举的类型被优化，枚举变量的类型都是ｉｎｔ型                        int col;            col = red;            printf(&quot;red=%d\n&quot;, red);//直接引用元素            printf(&quot;green=%d\n&quot;, green);            printf(&quot;blue=%d\n&quot;, blue);            return 0;        &#125;                注意点：            枚举的元素是个常量，而且是整型的，一定不能更改            枚举声明中如果有指定初始化值，则按照初始化值，如果没有，每个枚举元素的值都等于上一个元素的值+1；            如果第一个没有定义值，则将0赋值给第一个元素                                                                        </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++核心编程</title>
      <link href="/2023/05/04/c++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/04/c++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="内存分区模型"><a href="#内存分区模型" class="headerlink" title="内存分区模型"></a>内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为4个区域</p><p>  代码区：存放函数体的二进制代码，由操作系统进行管理的<br>  全局区：存放全局变量和静态变量以及常量<br>  栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等<br>  堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收<br>  内存四区意义：</p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="程序运行前"><a href="#程序运行前" class="headerlink" title="程序运行前"></a>程序运行前</h3><p>​ 在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域</p><p>​ 代码区：</p><p>​ 存放 CPU 执行的机器指令</p><p>​ 代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​ 代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​ 全局区：</p><p>​ 全局变量和静态变量存放在此.</p><p>​ 全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​ 该区域的数据在程序结束后由操作系统释放.</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> g_b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_g_b = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部变量</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//打印地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="type">int</span>)&amp;g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> s_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;s_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;<span class="string">&quot;hello world1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_g_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> c_l_b = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;c_l_b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：<br> <img src="/img/dayinjieguo.png"></img><br> 总结：</p><p>  C++中在程序运行前分为全局区和代码区<br>  代码区特点是共享和只读<br>  全局区中存放全局变量、静态变量、常量<br>  常量区中存放 const修饰的全局常量 和 字符串常量</p><h3 id="程序运行后"><a href="#程序运行后" class="headerlink" title="程序运行后"></a>程序运行后</h3><p>程序运行后<br>​  栈区：</p><p>​  由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>​  注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> * <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆区：</p><p>​ 由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p><p>​ 在C++中主要利用new在堆区开辟内存</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>堆区数据由程序员管理开辟和释放</p><p>堆区数据利用new关键字进行开辟内存</p><h3 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h3><p>​ C++中利用new操作符在堆区开辟数据</p><p>​ 堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 delete</p><p>​ 语法： new 数据类型</p><p>​ 利用new创建的数据，会返回该数据对应的类型的指针</p><p>示例1： 基本语法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用delete释放堆区数据</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2：开辟数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆区开辟数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = i + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//释放数组 delete 后加 []</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="引用基本使用"><a href="#引用基本使用" class="headerlink" title="引用基本使用"></a>引用基本使用</h3><p>作用： 给变量起别名</p><p>语法： 数据类型 &amp;别名 &#x3D; 原名</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>引用必须初始化<br>引用在初始化后，不可以改变<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//int &amp;c; //错误，引用必须初始化</span></span><br><span class="line"><span class="type">int</span> &amp;c = a; <span class="comment">//一旦初始化后，就不可以更改</span></span><br><span class="line">c = b; <span class="comment">//这是赋值操作，不是更改引用</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用做函数参数"><a href="#引用做函数参数" class="headerlink" title="引用做函数参数"></a>引用做函数参数</h3><p>作用：函数传参时，可以利用引用的技术让形参修饰实参</p><p>优点：可以简化指针修改实参<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap02</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mySwap03</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap01</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap02</span>(&amp;a, &amp;b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">mySwap03</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p><h3 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：不要返回局部变量引用</p><p>用法：函数调用作为左值</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回局部变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//局部变量</span></span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回静态变量引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能返回局部变量的引用</span></span><br><span class="line"><span class="type">int</span>&amp; ref = <span class="built_in">test01</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果函数做左值，那么必须返回引用</span></span><br><span class="line"><span class="type">int</span>&amp; ref2 = <span class="built_in">test02</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>() = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h3><p>本质：引用的本质在c++内部实现是一个指针常量.<br>讲解示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">ref = <span class="number">100</span>; <span class="comment">// ref是引用，转换为*ref = 100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br><span class="line">    </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">func</span>(a);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="常量引用"><a href="#常量引用" class="headerlink" title="常量引用"></a>常量引用</h3><p>作用：常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加const修饰形参，防止形参改变实参<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用使用的场景，通常用来修饰形参</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="comment">//v += 10;</span></span><br><span class="line">cout &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span></span><br><span class="line"><span class="comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ref = 100;  //加入const后不可以修改变量</span></span><br><span class="line">cout &lt;&lt; ref &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数中利用常量引用防止误操作修改实参</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">showValue</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h2><h3 id="函数默认参数"><a href="#函数默认参数" class="headerlink" title="函数默认参数"></a>函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法： 返回值类型 函数名 （参数&#x3D; 默认值）{}</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>, <span class="type">int</span> c = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span></span><br><span class="line"><span class="comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a = <span class="number">10</span>, <span class="type">int</span> b = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">20</span>, <span class="number">20</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; <span class="built_in">func</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数占位参数"><a href="#函数占位参数" class="headerlink" title="函数占位参数"></a>函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p>语法： 返回值类型 函数名 (数据类型){}</p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数占位参数 ，占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">//占位参数必须填补</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>作用：函数名可以相同，提高复用性</p><p>函数重载满足条件：</p><p>同一个作用域下<br>函数名称相同<br>函数参数类型不同 或者 个数不同 或者 顺序不同<br>注意: 函数的返回值不可以作为函数重载的条件</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载需要函数都在同一个作用域下</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a ,<span class="type">double</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数返回值不可以作为函数重载条件</span></span><br><span class="line"><span class="comment">//int func(double a, int b)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>();</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>,<span class="number">3.14</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">3.14</span> , <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><p>引用作为重载条件<br>函数重载碰到函数默认参数<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数重载注意事项</span></span><br><span class="line"><span class="comment">//1、引用作为重载条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数重载碰到函数默认参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">10</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">func</span>(a); <span class="comment">//调用无const</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">10</span>);<span class="comment">//调用有const</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//func2(10); //碰到默认参数产生歧义，需要避免</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性为：封装、继承、多态</p><p>C++认为万事万物都皆为对象，对象上有其属性和行为</p><p>例如：</p><p>​ 人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…</p><p>​ 车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…</p><p>​ 具有相同性质的对象，我们可以抽象称为类，人属于人类，车属于车类</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><p>  将属性和行为作为一个整体，表现生活中的事物<br>  将属性和行为加以权限控制<br>封装意义一：</p><p>​ 在设计类的时候，属性和行为写在一起，表现事物</p><p>语法： class 类名{ 访问权限： 属性 &#x2F; 行为 };</p><p>示例1：设计一个圆类，求圆的周长</p><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//圆周率</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、封装的意义</span></span><br><span class="line"><span class="comment">//将属性和行为作为一个整体，用来表现生活中的事物</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装一个圆类，求圆的周长</span></span><br><span class="line"><span class="comment">//class代表设计一个类，后面跟着的是类名</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:  <span class="comment">//访问权限  公共的权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line"><span class="type">int</span> m_r;<span class="comment">//半径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//行为</span></span><br><span class="line"><span class="comment">//获取到圆的周长</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculateZC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//2 * pi  * r</span></span><br><span class="line"><span class="comment">//获取圆的周长</span></span><br><span class="line"><span class="keyword">return</span>  <span class="number">2</span> * PI * m_r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过圆类，创建圆的对象</span></span><br><span class="line"><span class="comment">// c1就是一个具体的圆</span></span><br><span class="line">Circle c1;</span><br><span class="line">c1.m_r = <span class="number">10</span>; <span class="comment">//给圆对象的半径 进行赋值操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2 * pi * 10 = = 62.8</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;圆的周长为： &quot;</span> &lt;&lt; c1.<span class="built_in">calculateZC</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p>示例2代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setID</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">m_id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student stu;</span><br><span class="line">stu.<span class="built_in">setName</span>(<span class="string">&quot;德玛西亚&quot;</span>);</span><br><span class="line">stu.<span class="built_in">setID</span>(<span class="number">250</span>);</span><br><span class="line">stu.<span class="built_in">showStudent</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>封装意义二：</p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><p>public 公共权限<br>protected 保护权限<br>private 私有权限<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种权限</span></span><br><span class="line"><span class="comment">//公共权限  public     类内可以访问  类外可以访问</span></span><br><span class="line"><span class="comment">//保护权限  protected  类内可以访问  类外不可以访问</span></span><br><span class="line"><span class="comment">//私有权限  private    类内可以访问  类外不可以访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//姓名  公共权限</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_Name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//汽车  保护权限</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string m_Car;</span><br><span class="line"></span><br><span class="line"><span class="comment">//银行卡密码  私有权限</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_Name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">m_Car = <span class="string">&quot;拖拉机&quot;</span>;</span><br><span class="line">m_Password = <span class="number">123456</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">p.m_Name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line"><span class="comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span></span><br><span class="line"><span class="comment">//p.m_Password = 123; //私有权限类外访问不到</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h4><p>在C++中 struct和class唯一的区别就在于 默认的访问权限不同</p><p>区别：</p><p>  struct 默认权限为公共<br>  class 默认权限为私有<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">C1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>  m_A; <span class="comment">//默认是私有权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">C2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_A;  <span class="comment">//默认是公共权限</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">C1 c1;</span><br><span class="line">c1.m_A = <span class="number">10</span>; <span class="comment">//错误，访问权限是私有</span></span><br><span class="line"></span><br><span class="line">C2 c2;</span><br><span class="line">c2.m_A = <span class="number">10</span>; <span class="comment">//正确，访问权限是公共</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="成员属性设为私有"><a href="#成员属性设为私有" class="headerlink" title="成员属性设为私有"></a>成员属性设为私有</h4><p>优点1：**将所有成员属性设置为私有，可以自己控制读写权限</p><p>优点2：对于写权限，我们可以检测数据的有效性</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//姓名设置可读可写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string name)</span> </span>&#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取年龄 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置年龄</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置为只写</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setLover</span><span class="params">(string lover)</span> </span>&#123;</span><br><span class="line">m_Lover = lover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_Name; <span class="comment">//可读可写  姓名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Age; <span class="comment">//只读  年龄</span></span><br><span class="line"></span><br><span class="line">string m_Lover; <span class="comment">//只写  情人</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//姓名设置</span></span><br><span class="line">p.<span class="built_in">setName</span>(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄设置</span></span><br><span class="line">p.<span class="built_in">setAge</span>(<span class="number">50</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="built_in">getAge</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//情人设置</span></span><br><span class="line">p.<span class="built_in">setLover</span>(<span class="string">&quot;苍井&quot;</span>);</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象初始化和清理"><a href="#对象初始化和清理" class="headerlink" title="对象初始化和清理"></a>对象初始化和清理</h3><p>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全<br>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</p><h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>对象的初始化和清理也是两个非常重要的安全问题</p><p>​ 一个对象或者变量没有初始状态，对其使用后果是未知</p><p>​ 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p><p>c++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供</p><p>编译器提供的构造函数和析构函数是空实现。</p><p>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。<br>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。<br>构造函数语法：类名(){}</p><p>构造函数，没有返回值也不写void<br>函数名称与类名相同<br>构造函数可以有参数，因此可以发生重载<br>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次<br>析构函数语法： ~类名(){}</p><p>析构函数，没有返回值也不写void<br>函数名称与类名相同,在名称前加上符号 ~<br>析构函数不可以有参数，因此不可以发生重载<br>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="析构函数的分类和调用"><a href="#析构函数的分类和调用" class="headerlink" title="析构函数的分类和调用"></a>析构函数的分类和调用</h4><p>两种分类方式：</p><p>​ 按参数分为： 有参构造和无参构造</p><p>​ 按类型分为： 普通构造和拷贝构造</p><p>三种调用方式：</p><p>​ 括号法</p><p>​ 显示法</p><p>​ 隐式转换法</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、构造函数分类</span></span><br><span class="line"><span class="comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span></span><br><span class="line"><span class="comment">// 按照类型分类分为 普通构造和拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、构造函数的调用</span></span><br><span class="line"><span class="comment">//调用无参构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//调用无参构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用有参的构造函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.1  括号法，常用</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span></span><br><span class="line"><span class="comment">//Person p2();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 显式法</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="number">10</span>); </span><br><span class="line">Person p3 = <span class="built_in">Person</span>(p2);</span><br><span class="line"><span class="comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.3 隐式转换法</span></span><br><span class="line">Person p4 = <span class="number">10</span>; <span class="comment">// Person p4 = Person(10); </span></span><br><span class="line">Person p5 = p4; <span class="comment">// Person p5 = Person(p4); </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span></span><br><span class="line"><span class="comment">//Person p5(p4);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况:</p><p>  使用一个已经创建完毕的对象来初始化一个新对象<br>  值传递的方式给函数参数传值<br>  以值方式返回局部对象<br>  示例：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">mAge = p.mAge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数在释放内存之前调用</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person newman3;</span></span><br><span class="line"><span class="comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 值传递的方式给函数参数传值</span></span><br><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 以值方式返回局部对象</span></span><br><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p = <span class="built_in">doWork2</span>();</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"><span class="built_in">test03</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="析构函数调用规则"><a href="#析构函数调用规则" class="headerlink" title="析构函数调用规则"></a>析构函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a) &#123;</span><br><span class="line">age = a;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">age = p.age;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span></span><br><span class="line">Person p1; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//用户提供的有参</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">//此时如果用户没有提供拷贝构造，编译器会提供</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span></span><br><span class="line">Person p4; <span class="comment">//此时如果用户自己没有提供默认构造，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//此时如果用户自己没有提供有参，会出错</span></span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(p5)</span></span>; <span class="comment">//用户自己提供拷贝构造</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><p>浅拷贝：简单的赋值拷贝操作</p><p>深拷贝：在堆区重新申请空间，进行拷贝操作</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//无参（默认）构造函数</span></span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//有参构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age ,<span class="type">int</span> height) &#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝构造函数  </span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span></span><br><span class="line">m_age = p.m_age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_height);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~<span class="built_in">Person</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_height;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="type">int</span>* m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>, <span class="number">180</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄： &quot;</span> &lt;&lt; p1.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄： &quot;</span> &lt;&lt; p2.m_age &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p><h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>作用：</p><p>C++提供了初始化列表语法，用来初始化属性</p><p>语法：构造函数()：属性1(值1),属性2（值2）… {}</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">////传统方式初始化</span></span><br><span class="line"><span class="comment">//Person(int a, int b, int c) &#123;</span></span><br><span class="line"><span class="comment">//m_A = a;</span></span><br><span class="line"><span class="comment">//m_B = b;</span></span><br><span class="line"><span class="comment">//m_C = c;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表方式初始化</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) :<span class="built_in">m_A</span>(a), <span class="built_in">m_B</span>(b), <span class="built_in">m_C</span>(c) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">PrintPerson</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类对象作为类成员"><a href="#类对象作为类成员" class="headerlink" title="类对象作为类成员"></a>类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    A a；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">m_PhoneName = name;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Phone析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_PhoneName;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化列表可以告诉编译器调用哪一个构造函数</span></span><br><span class="line"><span class="built_in">Person</span>(string name, string pName) :<span class="built_in">m_Name</span>(name), <span class="built_in">m_Phone</span>(pName)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person构造&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Person析构&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">playGame</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; m_Name &lt;&lt; <span class="string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line">Phone m_Phone;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span></span><br><span class="line"><span class="comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span></span><br><span class="line"><span class="comment">//析构顺序与构造相反</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span> , <span class="string">&quot;苹果X&quot;</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">playGame</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>  静态成员分为：</p><p>静态成员变量<br>    所有对象共享同一份数据<br>    在编译阶段分配内存<br>    类内声明，类外初始化<br>静态成员函数<br>    所有对象共享同一个函数<br>    静态成员函数只能访问静态成员变量<br>示例1 ：静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员变量特点：</span></span><br><span class="line"><span class="comment">//1 在编译阶段分配内存</span></span><br><span class="line"><span class="comment">//2 类内声明，类外初始化</span></span><br><span class="line"><span class="comment">//3 所有对象共享同一份数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_B; <span class="comment">//静态成员变量也是有访问权限的</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> Person::m_B = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.m_A = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_A = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.m_A = &quot;</span> &lt;&lt; p1.m_A &lt;&lt; endl; <span class="comment">//共享同一份数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.m_A = &quot;</span> &lt;&lt; p2.m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2：静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数特点：</span></span><br><span class="line"><span class="comment">//1 程序共享一个函数</span></span><br><span class="line"><span class="comment">//2 静态成员函数只能访问静态成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//m_B = 100; //错误，不可以访问非静态成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A; <span class="comment">//静态成员变量</span></span><br><span class="line"><span class="type">int</span> m_B; <span class="comment">// </span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态成员函数也是有访问权限的</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func2调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_A = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//静态成员变量两种访问方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、通过对象</span></span><br><span class="line">Person p1;</span><br><span class="line">p1.<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、通过类名</span></span><br><span class="line">Person::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person::func2(); //私有权限访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-对象模型和this指针"><a href="#C-对象模型和this指针" class="headerlink" title="C++对象模型和this指针"></a>C++对象模型和this指针</h3><h4 id="成员函数和成员变量分开存储"><a href="#成员函数和成员变量分开存储" class="headerlink" title="成员函数和成员变量分开存储"></a>成员函数和成员变量分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">mA = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">int</span> mA;</span><br><span class="line"><span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB; </span><br><span class="line"><span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mA &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="this指针概念"><a href="#this指针概念" class="headerlink" title="this指针概念"></a>this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象</p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><p>  当形参和成员变量同名时，可用this指针来区分<br>  在类的非静态成员函数中返回对象本身，可使用return *this<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//1、当形参和成员变量同名时，可用this指针来区分</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Person&amp; <span class="title">PersonAddPerson</span><span class="params">(Person p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="comment">//返回对象本身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1.age = &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p2.<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1).<span class="built_in">PersonAddPerson</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2.age = &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="空指针访问成员成员函数"><a href="#空指针访问成员成员函数" class="headerlink" title="空指针访问成员成员函数"></a>空指针访问成员成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空指针访问成员函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">p-&gt;<span class="built_in">ShowPerson</span>();  <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const修饰成员函数"><a href="#const修饰成员函数" class="headerlink" title="const修饰成员函数"></a>const修饰成员函数</h4><p>常函数：</p><p>   成员函数后加const后我们称为这个函数为常函数<br>  常函数内不可以修改成员属性<br>  成员属性声明时加关键字mutable后，在常函数中依然可以修改<br>常对象：</p><p>  声明对象前加const称该对象为常对象<br>  常对象只能调用常函数<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;</span><br><span class="line">m_A = <span class="number">0</span>;</span><br><span class="line">m_B = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//this指针的本质是一个指针常量，指针的指向不可修改</span></span><br><span class="line"><span class="comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//const Type* const pointer;</span></span><br><span class="line"><span class="comment">//this = NULL; //不能修改指针的指向 Person* const this;</span></span><br><span class="line"><span class="comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyFunc</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="comment">//mA = 10000;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> m_B; <span class="comment">//可修改 可变的</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰对象  常对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Person person; <span class="comment">//常量对象  </span></span><br><span class="line">cout &lt;&lt; person.m_A &lt;&lt; endl;</span><br><span class="line"><span class="comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span></span><br><span class="line">person.m_B = <span class="number">100</span>; <span class="comment">//但是常对象可以修改mutable修饰成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常对象访问成员函数</span></span><br><span class="line">person.<span class="built_in">MyFunc</span>(); <span class="comment">//常对象不能调用const的函数</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为 friend</p><p>友元的三种实现</p><p>  全局函数做友元<br>  类做友元<br>  成员函数做友元</p><h4 id="全局函数做友元"><a href="#全局函数做友元" class="headerlink" title="全局函数做友元"></a>全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom; <span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay</span><span class="params">(Building * building)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Building b;</span><br><span class="line"><span class="built_in">goodGay</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类做友元"><a href="#类做友元" class="headerlink" title="类做友元"></a>类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodGay</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="成员函数做友元"><a href="#成员函数做友元" class="headerlink" title="成员函数做友元"></a>成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodGay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">goodGay</span>();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>; <span class="comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit2</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">Building *building;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Building</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_SittingRoom; <span class="comment">//客厅</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">string m_BedRoom;<span class="comment">//卧室</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Building::<span class="built_in">Building</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_BedRoom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">goodGay::<span class="built_in">goodGay</span>()</span><br><span class="line">&#123;</span><br><span class="line">building = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodGay::visit2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">goodGay  gg;</span><br><span class="line">gg.<span class="built_in">visit</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="加号运算符重载"><a href="#加号运算符重载" class="headerlink" title="加号运算符重载"></a>加号运算符重载</h4><p>加号运算符重载<br>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//成员函数实现 + 号运算符重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = <span class="keyword">this</span>-&gt;m_A + p.m_A;</span><br><span class="line">temp.m_B = <span class="keyword">this</span>-&gt;m_B + p.m_B;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现 + 号运算符重载</span></span><br><span class="line"><span class="comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span></span><br><span class="line"><span class="comment">//Person temp(0, 0);</span></span><br><span class="line"><span class="comment">//temp.m_A = p1.m_A + p2.m_A;</span></span><br><span class="line"><span class="comment">//temp.m_B = p1.m_B + p2.m_B;</span></span><br><span class="line"><span class="comment">//return temp;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运算符重载 可以发生函数重载 </span></span><br><span class="line">Person <span class="keyword">operator</span>+(<span class="type">const</span> Person&amp; p2, <span class="type">int</span> val)  </span><br><span class="line">&#123;</span><br><span class="line">Person temp;</span><br><span class="line">temp.m_A = p2.m_A + val;</span><br><span class="line">temp.m_B = p2.m_B + val;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数方式</span></span><br><span class="line">Person p3 = p2 + p1;  <span class="comment">//相当于 p2.operaor+(p1)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p3.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p3.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Person p4 = p3 + <span class="number">10</span>; <span class="comment">//相当于 operator+(p3,10)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mA:&quot;</span> &lt;&lt; p4.m_A &lt;&lt; <span class="string">&quot; mB:&quot;</span> &lt;&lt; p4.m_B &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p><p>总结2：不要滥用运算符重载</p><h4 id="左移运算符重载"><a href="#左移运算符重载" class="headerlink" title="左移运算符重载"></a>左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> a, <span class="type">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_A = a;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_B = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span></span><br><span class="line"><span class="comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数实现左移重载</span></span><br><span class="line"><span class="comment">//ostream对象只能有一个</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;</span><br><span class="line">out &lt;&lt; <span class="string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="string">&quot; b:&quot;</span> &lt;&lt; p.m_B;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="comment">//链式编程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p><h4 id="递增运算符重载"><a href="#递增运算符重载" class="headerlink" title="递增运算符重载"></a>递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInteger</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyInteger</span>() &#123;</span><br><span class="line">m_Num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置++</span></span><br><span class="line">MyInteger&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line"><span class="comment">//先++</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="comment">//再返回</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++</span></span><br><span class="line">MyInteger <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">//先返回</span></span><br><span class="line">MyInteger temp = *<span class="keyword">this</span>; <span class="comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span></span><br><span class="line">m_Num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_Num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;</span><br><span class="line">out &lt;&lt; myint.m_Num;</span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置++ 先++ 再返回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; ++myInt &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置++ 先返回 再++</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">MyInteger myInt;</span><br><span class="line">cout &lt;&lt; myInt++ &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; myInt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 前置递增返回引用，后置递增返回值</p><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><p>1.默认构造函数(无参，函数体为空)<br>2.默认析构函数(无参，函数体为空)<br>3.默认拷贝构造函数，对属性进行值拷贝<br>4.赋值运算符 operator&#x3D;, 对属性进行值拷贝<br>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将年龄数据开辟到堆区</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载赋值运算符 </span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译器提供的代码是浅拷贝</span></span><br><span class="line"><span class="comment">//m_Age = p.m_Age;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提供深拷贝 解决浅拷贝的问题</span></span><br><span class="line">m_Age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_Age);</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回自身</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_Age;</span><br><span class="line">m_Age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//年龄的指针</span></span><br><span class="line"><span class="type">int</span> *m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="number">30</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p3 = p2 = p1; <span class="comment">//赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p1.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p2.m_Age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p3.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//int a = 10;</span></span><br><span class="line"><span class="comment">//int b = 20;</span></span><br><span class="line"><span class="comment">//int c = 30;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//c = b = a;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关系运算符重载"><a href="#关系运算符重载" class="headerlink" title="关系运算符重载"></a>关系运算符重载</h4><p>作用：重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string m_Name;</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//int a = 0;</span></span><br><span class="line"><span class="comment">//int b = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a != b)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a和b相等&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="函数调用运算符重载"><a href="#函数调用运算符重载" class="headerlink" title="函数调用运算符重载"></a>函数调用运算符重载</h4><p>函数调用运算符 () 也可以重载<br>由于重载后使用的方式非常像函数的调用，因此称为仿函数<br>仿函数没有固定写法，非常灵活<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string text)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; text &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//重载的（）操作符 也称为仿函数</span></span><br><span class="line">MyPrint myFunc;</span><br><span class="line"><span class="built_in">myFunc</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyAdd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd add;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">add</span>(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象调用  </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="built_in">MyAdd</span>()(<span class="number">100</span>, <span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是面向对象三大特性之一</p><p>我们发现，定义这些类，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代码</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p>普通实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Java</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Python</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CPP</span> : <span class="keyword">public</span> BasePage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Java页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Python页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;--------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++页面</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;</span><br><span class="line">CPP cp;</span><br><span class="line">cp.<span class="built_in">header</span>();</span><br><span class="line">cp.<span class="built_in">footer</span>();</span><br><span class="line">cp.<span class="built_in">left</span>();</span><br><span class="line">cp.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>继承的好处：可以减少重复的代码</p><p>class A : public B;</p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p>派生类中的成员，包含两大部分：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="继承方式"><a href="#继承方式" class="headerlink" title="继承方式"></a>继承方式</h4><p>继承的语法：class 子类 : 继承方式 父类</p><p>继承方式一共有三种：</p><p>  公共继承<br>  保护继承<br>  私有继承<br>      <img src="/img/jicheng.png"></img><br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> :<span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 public权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son1 s1;</span><br><span class="line">s1.m_A; <span class="comment">//其他类只能访问到公共权限</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保护继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>:<span class="keyword">protected</span> Base2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 protected权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 protected权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myClass2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2 s;</span><br><span class="line"><span class="comment">//s.m_A; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//私有继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>:<span class="keyword">private</span> Base3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_A; <span class="comment">//可访问 private权限</span></span><br><span class="line">m_B; <span class="comment">//可访问 private权限</span></span><br><span class="line"><span class="comment">//m_C; //不可访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandSon3</span> :<span class="keyword">public</span> Son3</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span></span><br><span class="line"><span class="comment">//m_A;</span></span><br><span class="line"><span class="comment">//m_B;</span></span><br><span class="line"><span class="comment">//m_C;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><p>问题：从父类继承过来的成员，哪些属于子类对象中？</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_B;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_C; <span class="comment">//私有成员只是被隐藏了，但是还是会继承下去</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//公共继承</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Son) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用工具查看：<br>    <img src="/img/cahkan.png"></img><br>    打开工具窗口后，定位到当前CPP文件的盘符</p><p>然后输入： cl &#x2F;d1 reportSingleClassLayout查看的类名 所属文件名</p><p>效果如下图：<br>  <img src="/img/xiaoguo.png"></img><br>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p><h4 id="继承中的构造和析构顺序"><a href="#继承中的构造和析构顺序" class="headerlink" title="继承中的构造和析构顺序"></a>继承中的构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span></span><br><span class="line">Son s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p><h4 id="继承同名函数的处理"><a href="#继承同名函数的处理" class="headerlink" title="继承同名函数的处理"></a>继承同名函数的处理</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><p>  访问子类同名成员 直接访问即可<br>  访问父类同名成员 需要加作用域<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span></span><br><span class="line"><span class="comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1.子类对象可以直接访问到子类中同名成员<br>2.子类对象加作用域可以访问到父类同名成员<br>3.当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</p><h4 id="继承同名静态成员函数的处理方式"><a href="#继承同名静态成员函数的处理方式" class="headerlink" title="继承同名静态成员函数的处理方式"></a>继承同名静态成员函数的处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><p>  访问子类同名成员 直接访问即可<br>  访问父类同名成员 需要加作用域<br>  示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p><h4 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h4><p>C++允许一个类继承多个类</p><p>语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2…</p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p>C++实际开发中不建议用多继承</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_A = <span class="number">200</span>;  <span class="comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base2, <span class="keyword">public</span> Base1 </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_C = <span class="number">300</span>;</span><br><span class="line">m_D = <span class="number">400</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_C;</span><br><span class="line"><span class="type">int</span> m_D;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多继承容易产生成员同名的情况</span></span><br><span class="line"><span class="comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(s) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>菱形继承概念：</p><p>​ 两个派生类继承同一个基类</p><p>​ 又有某个类同时继承者两个派生类</p><p>​ 这种继承被称为菱形继承，或者钻石继承</p><p>菱形继承问题：</p><p>  羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。<br>  草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sheep</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>   : <span class="keyword">virtual</span> <span class="keyword">public</span> Animal &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SheepTuo</span> : <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Tuo &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SheepTuo st;</span><br><span class="line">st.Sheep::m_Age = <span class="number">100</span>;</span><br><span class="line">st.Tuo::m_Age = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>  菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义<br>  利用虚继承可以解决菱形继承问题</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>多态是C++面向对象三大特性之一</p><p>多态分为两类</p><p>  静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名<br>  动态多态: 派生类和虚函数实现运行时多态<br>静态多态和动态多态区别：</p><p>  静态多态的函数地址早绑定 - 编译阶段确定函数地址<br>  动态多态的函数地址晚绑定 - 运行阶段确定函数地址<br>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//Speak函数就是虚函数</span></span><br><span class="line"><span class="comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们希望传入什么对象，那么就调用什么对象的函数</span></span><br><span class="line"><span class="comment">//如果函数地址在编译阶段就能确定，那么静态联编</span></span><br><span class="line"><span class="comment">//如果函数地址在运行阶段才能确定，就是动态联编</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoSpeak</span><span class="params">(Animal &amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//多态满足条件： </span></span><br><span class="line"><span class="comment">//1、有继承关系</span></span><br><span class="line"><span class="comment">//2、子类重写父类中的虚函数</span></span><br><span class="line"><span class="comment">//多态使用：</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">DoSpeak</span>(cat);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="built_in">DoSpeak</span>(dog);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><p>有继承关系<br>子类重写父类中的虚函数<br>多态使用条件</p><p>父类指针或引用指向子类对象<br>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p><h4 id="多态案例–计算器类"><a href="#多态案例–计算器类" class="headerlink" title="多态案例–计算器类"></a>多态案例–计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><p>代码组织结构清晰<br>可读性强<br>利于前期和后期的扩展以及维护<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果要提供新的运算，需要修改源码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//普通实现测试</span></span><br><span class="line">Calculator c;</span><br><span class="line">c.m_Num1 = <span class="number">10</span>;</span><br><span class="line">c.m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; c.<span class="built_in">getResult</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//多态实现</span></span><br><span class="line"><span class="comment">//抽象计算器类</span></span><br><span class="line"><span class="comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractCalculator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_Num1;</span><br><span class="line"><span class="type">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//乘法计算器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MulCalculator</span> :<span class="keyword">public</span> AbstractCalculator</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建加法计算器</span></span><br><span class="line">AbstractCalculator *abc = <span class="keyword">new</span> AddCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  <span class="comment">//用完了记得销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建减法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> SubCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建乘法计算器</span></span><br><span class="line">abc = <span class="keyword">new</span> MulCalculator;</span><br><span class="line">abc-&gt;m_Num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_Num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="built_in">getResult</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p><h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为纯虚函数</p><p>纯虚函数语法：virtual 返回值类型 函数名 （参数列表）&#x3D; 0 ;</p><p>当类中有了纯虚函数，这个类也称为抽象类</p><p>抽象类特点：</p><p>  无法实例化对象<br>  子类必须重写抽象类中的纯虚函数，否则也属于抽象类<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//类中只要有一个纯虚函数就称为抽象类</span></span><br><span class="line"><span class="comment">//抽象类无法实例化对象</span></span><br><span class="line"><span class="comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//base = new Base; // 错误，抽象类无法实例化对象</span></span><br><span class="line">base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性：</p><p>  可以解决父类指针释放子类对象<br>  都需要有具体的函数实现<br>虚析构和纯虚析构区别：</p><p>  如果是纯虚析构，该类属于抽象类，无法实例化对象<br>虚析构语法：</p><p>virtual ~类名(){}</p><p>纯虚析构语法：</p><p>virtual ~类名() &#x3D; 0;</p><p>类名::~类名(){}</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数加上virtual关键字，变成虚析构函数</span></span><br><span class="line"><span class="comment">//virtual ~Animal()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;</span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; *m_Name &lt;&lt;  <span class="string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Cat</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">Speak</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span></span><br><span class="line"><span class="comment">//怎么解决？给基类增加一个虚析构函数</span></span><br><span class="line"><span class="comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​ 1. 虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p><p>​ 2. 如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p><p>​ 3. 拥有纯虚析构函数的类也属于抽象类</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过文件可以将数据持久化</p><p>C++中对文件操作需要包含头文件 &lt; fstream &gt;</p><p>文件类型分为两种：</p><p>1.文本文件 - 文件以文本的ASCII码形式存储在计算机中<br>2.二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们<br>操作文件的三大类:</p><p>1.ofstream：写操作<br>2.ifstream： 读操作<br>3.fstream ： 读写操作</p><h3 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h3><h4 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h4><p>写文件步骤如下：</p><p>1.包含头文件</p><p>#include <fstream></p><p>2.创建流对象</p><p>ofstream ofs;</p><p>3.打开文件</p><p>ofs.open(“文件路径”,打开方式);</p><p>4.写数据</p><p>ofs &lt;&lt; “写入的数据”;</p><p>5.关闭文件</p><p>ofs.close();</p><p>文件打开方式：<br>    <img src="/wenbentext.png"></img><br>注意： 文件打开方式可以配合使用，利用|操作符</p><p>例如：用二进制方式写文件 ios::binary | ios:: out</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;性别：男&quot;</span> &lt;&lt; endl;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>  文件操作必须包含头文件 fstream<br>  读文件可以利用 ofstream ，或者fstream类<br>  打开文件时候需要指定操作文件的路径，以及打开方式<br>  利用&lt;&lt;可以向文件中写数据<br>  操作完毕，要关闭文件</p><h4 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><p>1.包含头文件</p><p>#include <fstream></p><p>2.创建流对象</p><p>ifstream ifs;</p><p>3.打开文件并判断文件是否打开成功</p><p>ifs.open(“文件路径”,打开方式);</p><p>4.读数据</p><p>四种方式读取</p><p>5.关闭文件</p><p>ifs.close();</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种方式</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs &gt;&gt; buf)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="comment">//char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">//while (ifs.getline(buf,sizeof(buf)))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="keyword">while</span> ((c = ifs.<span class="built_in">get</span>()) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>  读文件可以利用 ifstream ，或者fstream类<br>  利用is_open函数可以判断文件是否打开成功<br>  close 关闭文件</p><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为 ios::binary</p><h4 id="写文件-1"><a href="#写文件-1" class="headerlink" title="写文件"></a>写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：ostream&amp; write(const char * buffer,int len);</p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二进制文件  写文件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、包含头文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、创建输出流对象</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、打开文件</span></span><br><span class="line"><span class="comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span></span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;张三&quot;</span>  , <span class="number">18</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、写文件</span></span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5、关闭文件</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：文件输出流对象 可以通过write函数，以二进制方式写数据</p><h4 id="读文件-1"><a href="#读文件-1" class="headerlink" title="读文件"></a>读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：istream&amp; read(char *buffer,int len);</p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p, <span class="built_in">sizeof</span>(p));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三周训练赛</title>
      <link href="/2023/04/22/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%AD%E7%BB%83%E8%B5%9B/"/>
      <url>/2023/04/22/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AC%AC%E4%B8%89%E5%91%A8%E8%AE%AD%E7%BB%83%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="B"><a href="#B" class="headerlink" title="B"></a>B</h2><p> 题目描述 ：<br>给你n个字符串。字符串内有大小写字母和数字。<br>请你输出有多少个不同的字符串。<br>输入描述：</p><pre><code> 第一行一个整数n 1≤n≤10000  以下n行每行一个字符串S 1≤n≤10000 1≤S.length()≤1500   </code></pre><p>输出描述：</p><pre><code> 输出一个整数 不同的字符串的个数</code></pre><p>示例：</p><pre><code> 输入： 5 AC AC ACC ACCC ACCCC 输出： 4</code></pre><p>题目分析：</p><pre><code> 我们要求的是不同种字符串的数量，那么我们可以手写字符串hash，然后来判断有多少不同的， 由于STL很方便，所以我们直接用map&lt;string,bool&gt;和.size()就可快速求出不同种字符串的数量</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* a, <span class="type">const</span> <span class="type">void</span>* b)</span><span class="comment">//用来做比较的函数。</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">long</span> <span class="type">long</span>  <span class="type">int</span>*)a - *(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> qc[<span class="number">100000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> mod1 = <span class="number">212370440130137957ll</span>, ans=<span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> f;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;2.in&quot;, &quot; r &quot;, stdin);</span></span><br><span class="line"> <span class="comment">//  freopen(&quot;2.out&quot;, &quot; w &quot;, stdout);</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">f = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sl = <span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sl; j++)</span><br><span class="line">&#123;</span><br><span class="line">f = (f * <span class="number">131</span> + (s[j - <span class="number">1</span>])) % mod1;</span><br><span class="line">&#125;</span><br><span class="line">qc[i] = f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qsort</span>(qc, n, <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>), comp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (qc[i] != qc[i - <span class="number">1</span>])</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>题目描述 ：<br>给你一个字符串S。S中只有大写字母。<br>你需要对字符串S的每个前缀Si进行以下运算。<br>在字符串Si中找到一个它的子串T。T 既是 Si 的前缀也是 Si 的后缀，且T不能是Si本身。<br>请输出每个字符串S的前缀Si中，T的最长长度。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> kmp[MAXN];</span><br><span class="line"><span class="type">int</span> la, lb, j;</span><br><span class="line"><span class="type">char</span> a[MAXN], b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    cin &gt;&gt; b + <span class="number">1</span>;</span><br><span class="line">    lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lb; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; b[i] != b[j + <span class="number">1</span>])</span><br><span class="line">            j = kmp[j];</span><br><span class="line">        <span class="keyword">if</span> (b[j + <span class="number">1</span>] == b[i])j++;</span><br><span class="line">        kmp[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= lb; i++)</span><br><span class="line">        cout &lt;&lt; kmp[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>  std;</span><br><span class="line">unordered_map&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>,<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;bcj,bcjzn;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> ZN, QC, N,Z ,Q,x,y,a[<span class="number">2100000</span>],b[<span class="number">2100000</span>], c[<span class="number">2100000</span>],d;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f == bcj[f] ? f : bcj[f] = <span class="built_in">find</span>(bcj[f]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;1.in&quot;, &quot; r &quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;1.out&quot;, &quot; w &quot;, stdout);</span></span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; ZN &gt;&gt; QC&gt;&gt;Z &gt;&gt; Q;</span><br><span class="line">    <span class="keyword">if</span> (N &gt; <span class="number">2e4</span> || N &lt; <span class="number">1</span> || ZN&gt;<span class="number">2e4</span> || ZN &lt; <span class="number">1</span> || QC&gt;<span class="number">2e4</span> || QC &lt; <span class="number">1</span> || Z &gt; <span class="number">2e4</span> || Z &lt; <span class="number">1</span>  || Q&gt;<span class="number">1e6</span>||Q&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        bcj[a[i]] = a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">1e18</span>||a[i]&lt;<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ZN; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">        bcjzn[b[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; <span class="number">1e18</span> || b[i] &lt; <span class="number">1</span>||bcj.<span class="built_in">find</span>(b[i])==bcj.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; QC; i++) &#123;</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">        <span class="keyword">if</span> (c[i] &gt; <span class="number">1e18</span> || c[i] &lt; <span class="number">1</span> || bcj.<span class="built_in">find</span>(c[i]) == bcj.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fx = <span class="built_in">find</span>(c[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fy = <span class="built_in">find</span>(c[i]);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy)</span><br><span class="line">        &#123;</span><br><span class="line">            bcj[fy] = fx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Z; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1e18</span>||x&lt;<span class="number">1</span>||y&gt;<span class="number">1e18</span> || y &lt; <span class="number">1</span> || bcj.<span class="built_in">find</span>(x) == bcj.<span class="built_in">end</span>() || bcj.<span class="built_in">find</span>(y) == bcj.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fx = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fy = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy)</span><br><span class="line">        &#123;</span><br><span class="line">            bcj[fx] = fy;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Q; i++) &#123;</span><br><span class="line">        cin &gt;&gt; d;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">1e18</span> || d &lt; <span class="number">1</span> || bcj.<span class="built_in">find</span>(d) == bcj.<span class="built_in">end</span>()||bcjzn.<span class="built_in">find</span>(d)==bcjzn.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fx = <span class="built_in">find</span>(d);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> fy = <span class="built_in">find</span>(c[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;ac\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;wa\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E"><a href="#E" class="headerlink" title="E"></a>E</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,v,a[<span class="number">10000</span>],b[<span class="number">10000</span>],dp[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;v;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=v;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j]=<span class="built_in">max</span>(dp[j],dp[j-a[i]]+b[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[v];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F"><a href="#F" class="headerlink" title="F"></a>F</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">find</span>(b)!=a.npos)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;YES&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;NO&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> hs[<span class="number">110000000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span>  ss[<span class="number">11000000</span>] = &#123; <span class="number">0</span> &#125;, sz, n = <span class="number">100000000</span>, sum[<span class="number">110000000</span>], t;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;10.in&quot;, &quot; r &quot;, stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;10.out&quot;,&quot; w &quot;, stdout);</span></span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">if</span> (t &gt; <span class="number">1e5</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hs[i] == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">ss[++sz] = i;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= sz &amp;&amp; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)i * (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)ss[j] &lt;= n; j++)</span><br><span class="line">&#123;</span><br><span class="line">hs[ss[j] * i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (i % ss[j] == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> q, p;</span><br><span class="line">cin &gt;&gt; p &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (p &gt; q)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (q &gt; <span class="number">1e8</span> || q &lt; <span class="number">1</span> || p &gt; <span class="number">1e8</span> || p &lt; <span class="number">1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">cout &lt;&lt; sum[q] - sum[p - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">lb</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> next;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> top;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> v;</span><br><span class="line">&#125;qxx[<span class="number">10000000</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qz</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> qz;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> d;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> <span class="keyword">struct</span> qz&amp; x)<span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> qz &gt; x.qz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;qz&gt;dl;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> m, q, lbys,z,s;</span><br><span class="line">unordered_map&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;bt;</span><br><span class="line">unordered_map&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;vis;</span><br><span class="line">unordered_map&lt;<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span>&gt;hx;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lj</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> qd, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> zd, <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> qz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    qxx[++lbys].next = bt[qd];</span><br><span class="line">    qxx[lbys].top = zd;</span><br><span class="line">    qxx[lbys].v = qz;</span><br><span class="line">    bt[qd] = lbys;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;20.in&quot;, &quot; r &quot;, stdin);</span></span><br><span class="line">    <span class="comment">//freopen(&quot;20.out&quot;, &quot; w &quot;, stdout);</span></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; q&gt;&gt;z&gt;&gt;s;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;<span class="number">2e5</span>||m&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(q&gt;<span class="number">1e18</span>||q&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(z&gt;<span class="number">1e18</span>||z&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(s&gt;<span class="number">1e5</span>||s&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    vis[q] = <span class="number">0</span>;</span><br><span class="line">    vis[z] = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> qd, zd, qz,w;</span><br><span class="line">        cin &gt;&gt; qd &gt;&gt; zd &gt;&gt; qz&gt;&gt;w;</span><br><span class="line">        <span class="keyword">if</span>(qd&gt;<span class="number">1e18</span>||qd&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(zd&gt;<span class="number">1e18</span>||zd&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(qz&gt;<span class="number">1e5</span>||qz&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(w&gt;<span class="number">2</span>||w&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">lj</span>(qd, zd, qz);</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">lj</span>(zd, qd, qz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[qd] == <span class="number">0</span> &amp;&amp; qd != q)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[qd] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vis[zd] == <span class="number">0</span> &amp;&amp; zd != q)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[zd] = <span class="number">1e18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dl.<span class="built_in">push</span>(qz&#123; <span class="number">0</span>,q &#125;);</span><br><span class="line">    <span class="keyword">while</span> (dl.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">qz</span> dz = dl.<span class="built_in">top</span>(); dl.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (hx.<span class="built_in">find</span>(dz.d) != hx.<span class="built_in">end</span>())<span class="keyword">continue</span>;</span><br><span class="line">        hx[dz.d] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span> i = bt[dz.d]; i != <span class="number">0</span>; i = qxx[i].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[qxx[i].top] &gt; vis[dz.d] + qxx[i].v)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[qxx[i].top] = vis[dz.d] + qxx[i].v;</span><br><span class="line">                <span class="keyword">if</span> (hx.<span class="built_in">find</span>(qxx[i].top) == hx.<span class="built_in">end</span>())</span><br><span class="line">                    dl.<span class="built_in">push</span>(qz&#123; vis[qxx[i].top],qxx[i].top &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vis[z] == <span class="number">1e18</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; (<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)<span class="built_in">ceil</span>((<span class="type">double</span>)vis[z] / (<span class="type">double</span>)s)&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//cout &lt;&lt;vis[z]&lt;&lt;&quot; &quot;&lt;&lt;s;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二周训练赛</title>
      <link href="/2023/04/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%AD%E7%BB%83%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
      <url>/2023/04/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E8%AE%AD%E7%BB%83%E9%A2%98%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="E-很二的拆分"><a href="#E-很二的拆分" class="headerlink" title="E.很二的拆分"></a>E.很二的拆分</h2><p>题目描述 ：<br>2022年，2月22日2时22分22秒，小二突发奇想，他认为任何一个正整数都可以拆分成若干个不同的 2 的正整数次幂，请编程帮他验证这个想法。</p><p>输入描述：</p><pre><code> 输入文件只有一行，一个正整数 𝑛（1≤ n≤ 231-1），代表需要判断的数。</code></pre><p>输出描述：</p><pre><code> 如果这个正整数可以拆分成若干个不同的 2 的正整数次幂，从大到小输出这个拆分中的每一个数， 相邻两个数之间用一个空格隔开。如果不存在这样的拆分，输出-1。</code></pre><p>示例：</p><pre><code> 输入: 7 输出： -1 输入: 14 输出： 8 4 2</code></pre><p>题目分析：枚举i从30到1即可，每次比较n和2的i次方，若n大，用n减去2的i次方；最后当前数字不为0的话就无解。<br>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> m[<span class="number">31</span>], N[<span class="number">31</span>];</span><br><span class="line">    m[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//存2--2的31次方</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        m[i] = m[i - <span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">30</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span> || i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= m[i]) &#123;</span><br><span class="line">            n -= m[i];</span><br><span class="line">            N[j++] = m[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">            cout &lt;&lt; N[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="F-构造字符串"><a href="#F-构造字符串" class="headerlink" title="F.构造字符串"></a>F.构造字符串</h2><p>题目描述 ：</p><p>给定长度为N的字符串S，要构造一个长度为N的字符串T。T初始是空字符串。S由大写字母构成。<br>构造过程通过反复进行以下任意操作：<br>从S的头部删除一个字符，添加到T的尾部<br>从S的尾部删除一个字符，添加到T的尾部<br>请你构造出字典序尽可能小的字符串T（字典序是指首先比较第一个字符，如果不同则第一个字符<br>较小的字符串更小，如果相同则比较第二个字符，以此类推</p><p>输入描述：</p><pre><code> 第一行一个整数N，表示字符串的长度（1&lt;=n&lt;=2000） 第二行输入一个长度为N的字符串S</code></pre><p>输出描述：</p><pre><code> 输出构造出的尽可能小的字符串T</code></pre><p>示例：</p><pre><code> 输入： ACDBCD 输出： ABCBCD</code></pre><p>题目考点：双指针</p><p>题目分析：主要判断两边相等的情况，每次判断输出左指针还是右指针即可：若两边不同，输出字典序小的；若相同则继续往中间找（ 此过程不能移动两边指针的位置 ），直到遇到不同字符再判断输出哪一个；<br>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; s ;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; left + i &lt; right; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[left+i] &lt; s[right-i])&#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[left+i] &gt; s[right-i])&#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) cout &lt;&lt; s[left++];</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; s[right--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-信号之旅"><a href="#G-信号之旅" class="headerlink" title="G.信号之旅"></a>G.信号之旅</h2><p>题目描述 :</p><p>某天，居住在VR世界的信号们收到了一条命令，命令指明每一个城市的两个信号必须要集合在一起，<br>信号们立刻行动了起来。VR世界是一个二维的网格，信号们只能向上下左右四个方向进行移动，并且，<br>由于VR世界存在一些bug，每个城市都有一个坐标是不能被走到的，也就是说信号们必须绕开这个坐标移动。<br>信号们希望走最短的路线到达集合位置，它们希望你能帮忙计算出需要匹配的两个信号间最短的路径长度。</p><p>输入描述:</p><pre><code> 第一行输入一个整数t（1&lt;=t&lt;=10^4)，代表需要配对的信号对数。 接下来对于每对信号输入三行，第一行包含两个整数xA，yA，代表信号A的坐标； 第二行包含两个整数xB，yB，代表信号B的坐标； 第三行包含两个整数xP，yP，代表bug所在的坐标； 所有的x和y满足 1&lt;=x,y&lt;=1000 数据保证bug所在坐标与信号A、B的坐标不同</code></pre><p>输出描述:<br>     输出t行，第i行表示第i对信号间的最短路径长度。</p><p>输入：</p><pre><code> 7 1 1 3 3 2 2 2 5 2 1 2 3 1000 42 1000 1 1000 1000 1 10 3 10 2 10 3 8 7 8 3 7 2 1 4 1 1 1 1 344 1 10 1 1</code></pre><p>输出：</p><pre><code> 4 6 41 4 4 2 334</code></pre><p>题目考点：思维题目</p><p>题目分析：求两点之间曼哈顿距离，若两点在同一直线上，则判断障碍是否在两信号中间即可。<br>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> tt;</span><br><span class="line">    cin &gt;&gt; tt;</span><br><span class="line">    <span class="keyword">while</span> (tt--) &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, x3, y3;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">abs</span>(x1 - x2) + <span class="built_in">abs</span>(y1 - y2);</span><br><span class="line">        <span class="keyword">if</span> (x1 == x2 &amp;&amp; x1 == x3 &amp;&amp; ((y3 &gt;= y1 &amp;&amp; y3 &lt;= y2) || (y3 &gt;= y2 &amp;&amp; y3 &lt;= y1))) &#123;</span><br><span class="line">            res += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y1 == y2 &amp;&amp; y1 == y3 &amp;&amp; ((x3 &gt;= x1 &amp;&amp; x3 &lt;= x2) || (x3 &gt;= x2 &amp;&amp; x3 &lt;= x1))) &#123;</span><br><span class="line">            res += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-小球滚动"><a href="#H-小球滚动" class="headerlink" title="H.小球滚动"></a>H.小球滚动</h2><p>题目描述<br>有n个小球以每秒1cm的速度在一个滑槽上滑行，滑槽没有封口，所以当小球滑到滑槽的端点时将会掉落下来。<br>滑槽的宽度只容许一个小球通过，小球之间的碰撞为弹性碰撞（即碰撞后小球的速度绝对值不变，方向相反）。<br>已知n个小球初始时的位置，但不知道小球初始时的朝向，小球与滑槽之间的摩擦力不计，<br>请你计算所有小球掉下所需要的最短和最长的时间（秒）。</p><p>输入描述:</p><pre><code> 第一行输入一个整数L代表滑槽的长度(单位厘米)（1 &lt;= L &lt;= 10^6）； 第二行输入一个整数n代表小球的个数（1 &lt;= n &lt;= 10^6）； 第三行输入n个整数，第i个整数xi（1 &lt;= xi &lt;= L）代表第i个小球初始时的位置（即，距离滑槽左端xi厘米），整数之间用空格分开。</code></pre><p>输出描述:<br>     输出一行两个整数，分别代表所有小球掉落的最短和最长时间（秒）。<br>输入：</p><pre><code> 10 3 2 6 7</code></pre><p>输出：</p><pre><code> 4 8</code></pre><p>题目分析：<br>题目考点：思维题目</p><p>题目分析：当两小球碰撞后，不需要理解成二者调头，我们完全可以理解为两个碰撞的小球可以互相穿透，毕竟小球之间没有区别，只要其中一个还在滑槽中，就一直在计时。这样一来：</p><pre><code> 最短时间 = 每个小球距两端的最近距离最大值 最长时间 = 每个小球距两端的最远距离最大值     </code></pre><p>题解代码：<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l, n;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> mmax = <span class="number">0</span>, mmin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        mmin = <span class="built_in">max</span>(mmin, <span class="built_in">min</span>(t, l - t));</span><br><span class="line">        mmax = <span class="built_in">max</span>(mmax, <span class="built_in">max</span>(t, l - t));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; mmin &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; mmax &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="I-kiki看球赛"><a href="#I-kiki看球赛" class="headerlink" title="I.kiki看球赛"></a>I.kiki看球赛</h2><p>题目描述<br>kiki看了一场非常激烈的球赛，他在比赛过程中分几次记录了当前两队的分数。<br>意犹未尽的kiki取出了自己记录的比分，想根据自己记录的不同时刻的比分推断<br>一下最多有多少次两队比分是持平的（包括0：0）。kiki希望你能帮助他计算这个结果。</p><p>输入描述:</p><pre><code> 第一行一个整数n（1&lt;=n&lt;=10^4），表示kyoka记录的次数。 之后输入n行，第i+i行输入以空格分开的两个整数ai,bi（1&lt;=ai,bi&lt;=10^9） 代表第i次记录时两队的比分（按时间顺序）</code></pre><p>输出描述:</p><pre><code> 在第一行中输出一个整数k，代表最多有k次两队的比分是持平的。</code></pre><p>示例：</p><pre><code> 输入：  3 2 0 3 1 3 4 输出： 2 说明： 样例中比赛过程可能是这样的：0:0, 1:0, 2:0, 2:1, 3:1, 3:2, 3:3, 3:4 共经历了0：0和3：3两次平分。</code></pre><p>题目分析：</p><pre><code>比分持平的条件是：上一次记录的落后者的比分，在本场的比分大于等于比上一场领先者的比分，一直维护ans即可</code></pre><p>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//freopen(&quot;aa.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">    <span class="type">int</span> n; <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> A = <span class="number">0</span> , B = <span class="number">0</span>; <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l , r; <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="keyword">if</span>(A == B) &#123;</span><br><span class="line">            ans += <span class="built_in">min</span>(l - A , r - B);</span><br><span class="line">            A = l; B = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(A &gt; B) &#123;</span><br><span class="line">                <span class="keyword">if</span>(A &lt;= r) ans += <span class="built_in">max</span>(<span class="number">0</span> , <span class="built_in">min</span>(l - A , r - A) + <span class="number">1</span>);</span><br><span class="line">                A = l; B = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(l &gt;= B) ans += <span class="built_in">max</span>(<span class="number">0</span> , <span class="built_in">min</span>(l - B , r - B) + <span class="number">1</span>);</span><br><span class="line">                A = l; B = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一周训练赛</title>
      <link href="/2023/04/12/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AC%AC%E4%B8%80%E5%91%A8%E8%AE%AD%E7%BB%83%E8%B5%9B/"/>
      <url>/2023/04/12/%E7%89%9B%E5%AE%A2%E7%BD%91%E7%AC%AC%E4%B8%80%E5%91%A8%E8%AE%AD%E7%BB%83%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="B-灵魂之火"><a href="#B-灵魂之火" class="headerlink" title="B.灵魂之火"></a>B.灵魂之火</h2><p>题目描述<br>在设计师加强“灵魂之火”后，“灵魂之火术”这一卡组成为了天梯霸主，因此设计师紧急发布补丁，将灵魂之火的效果回调为了：造成 4 点伤害，并从剩余手牌中随机弃一张牌（如果剩余手牌数为0，则无需弃牌）。<br>Slowfire 花大价钱合成的卡组仅仅使用了一天就被削弱，他大失所望。作为资深玩家的他现在又开始思考：如果他总共有 n 张手牌，其中 m 张为灵魂之火，并且他不断地打出“灵魂之火”直到手牌里没有“灵魂之火”，那么他能够造成伤害值的期望是多少，答案对 10（9次方）+7取模后输出。<br>输入：</p><pre><code> 第一行一个整数T T(1≤T≤10（5次方） ) ，表示数据数。 接下来 T 行，每行两个整数n,m(0≤m≤n≤2022) ，分别表示手牌的数量和其中“灵魂之火”的数量</code></pre><p>输出：</p><pre><code> 输出 T 行，每行一个整数，表示 Slowfire 能造成伤害的期望对 10（9次方） +7 取模后的结果。 令 M=10（9次方） +7 ，可以证明所求期望可以写成既约分数 q/p的形式，其中,p,q 均为整数且 q！≡0(mod M) 。输出的整数应当与   p⋅q （−1） modM 相等，换言之，输出一个整数 x 满足  0≤x&lt;M 且 x⋅q≡p(modM)。</code></pre><p>示例：<br>     输入：<br>     5<br>     0 0<br>     1 1<br>     5 2<br>     1145 14<br>     1919 810<br>     输出：<br>     0<br>     4<br>     7<br>     136363693<br>     555789839<br>题目分析：<br><img src="/img/fire.png"></img><br>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 2040</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ri int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LL long long </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, rev[N &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    a += b;</span><br><span class="line">    <span class="keyword">if</span> (a &gt;= mod) a -= mod;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * <span class="number">1LL</span> * b % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b &gt;&gt;= <span class="number">1</span>, a = <span class="built_in">mul</span>(a, a)) <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ret = <span class="built_in">mul</span>(ret, a);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ri i = <span class="number">1</span>; i &lt; (N &lt;&lt; <span class="number">1</span>); i++) rev[i] = <span class="built_in">pow</span>(i, mod - <span class="number">2</span>);</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">for</span> (ri i = <span class="number">2</span>; i &lt; N; i++) f[i][<span class="number">0</span>] = <span class="built_in">add</span>(f[i][<span class="number">0</span>], <span class="built_in">mul</span>(<span class="number">1</span>, <span class="built_in">add</span>(f[i - <span class="number">2</span>][<span class="number">0</span>], <span class="number">4</span>)));</span><br><span class="line">    <span class="keyword">for</span> (ri i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (ri j = <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                f[i][j] = <span class="built_in">add</span>(f[i][j], <span class="built_in">mul</span>(<span class="built_in">mul</span>(i - <span class="number">1</span>, rev[i - <span class="number">1</span> + j]), <span class="built_in">add</span>(f[i - <span class="number">2</span>][j], <span class="number">4</span>)));</span><br><span class="line">            f[i][j] = <span class="built_in">add</span>(f[i][j], <span class="built_in">mul</span>(<span class="built_in">mul</span>(j, rev[i - <span class="number">1</span> + j]), <span class="built_in">add</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="number">4</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[m][n - m]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="E-三十六方"><a href="#E-三十六方" class="headerlink" title="E.三十六方"></a>E.三十六方</h2><p>题目描述 ：<br>三十六方，必为大统！——小张<br>小张是一个热爱方阵的男孩子，他正在参加埃湖大学组织的军训。训练场上的方阵为若干个 n×n 的矩形，其中第 i 行第j列的同学的身高为 ℎ,h （i,j）。小方想设计一个函数来描述每个方阵的特征。他定义一个方阵的”方值”如下：<br>对于一个方阵，小张首先会尝试将方阵分割成若干个均匀（大小相等）的子方阵。他希望分割的方阵数量尽可能少（但要大于 1），且每个子方阵的边长大于 1。然后该方阵的”方值”即为分割出的子方阵的”方值”和。<br>如果一个方阵不能被按上述方式分割，则方阵的”方值”为方阵中学生所有学生身高的最大值。<br>例如，对于一个9×9 的方阵，小方会将其分割成 9 个3×3 的方阵，而对于 3×3 的方阵无法继续分割。现在，小张想知道对于一个给定的方阵，它的”方值”为多少。<br><img src="/img/36.png"></img><br>题目分析：<br>递归思想、模拟（、简单数论）<br>不难看出方阵的“方值”定义是以递归的方式定义的，而最终一定是将整个方阵分割成若干个相等的极小方阵。我们可以按照定义模拟，得到整个方阵最终能分割出的极小方阵的边长，然后对于子方阵的最大值求和即可。当然，你也可以直接看出这个极小的边长实际上就是n 的最大质因子。<br>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2022</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h[N][N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=x+d<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y;j&lt;=y+d<span class="number">-1</span>;++j)</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,h[i][j]);</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            cin&gt;&gt;h[i][j];</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>,x=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;++i)</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=i;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) p=x;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=p)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j+=p)</span><br><span class="line">            ans+=<span class="built_in">solve</span>(i,j,p);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="G-神秘信号"><a href="#G-神秘信号" class="headerlink" title="G.神秘信号"></a>G.神秘信号</h2><p>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2022</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> h[N][N],n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mx=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x;i&lt;=x+d<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=y;j&lt;=y+d<span class="number">-1</span>;++j)</span><br><span class="line">            mx=<span class="built_in">max</span>(mx,h[i][j]);</span><br><span class="line">    <span class="keyword">return</span> mx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            cin&gt;&gt;h[i][j];</span><br><span class="line">    <span class="type">int</span> p=<span class="number">1</span>,x=n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i*i&lt;=x;++i)</span><br><span class="line">        <span class="keyword">if</span>(x%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=i;</span><br><span class="line">            <span class="keyword">while</span>(x%i==<span class="number">0</span>) x/=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;<span class="number">1</span>) p=x;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=p)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j+=p)</span><br><span class="line">            ans+=<span class="built_in">solve</span>(i,j,p);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="H-轻松的数列题"><a href="#H-轻松的数列题" class="headerlink" title="H.轻松的数列题"></a>H.轻松的数列题</h2><p><img src="/img/shulie.png"></img><br>题目分析：二分，STL<br><img src="/img/数列.png"></img><br>题解代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,k;</span><br><span class="line">&#125; x[N];</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (node s, node t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> s.a&lt;t.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;x[i].a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) cin&gt;&gt;x[i].k;</span><br><span class="line">    <span class="built_in">sort</span>(x+<span class="number">1</span>,x+<span class="number">1</span>+n);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i<span class="number">-1</span>].a!=x[i].a) l=i<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> j=<span class="built_in">upper_bound</span>(x+<span class="number">1</span>,x+<span class="number">1</span>+n,(node)&#123;x[i].a/x[i].k,<span class="number">0</span>&#125;)-x;</span><br><span class="line">        ans+=<span class="built_in">max</span>(<span class="number">0</span>,l-j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++基础编程</title>
      <link href="/2023/04/08/c++%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/04/08/c++%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="C-初识"><a href="#C-初识" class="headerlink" title="C++初识"></a>C++初识</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>作用：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码<br>1.单行注释：&#x2F;&#x2F;描述信息<br>通常放在一行代码的上方，或者一条语句的末尾，对该行代码说明<br>2.多行注释：&#x2F;<em>描述信息</em>&#x2F;<br>通常放在一段代码的上方，对该段代码做整体说明</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>作用：给一段指定的内存空间起名，方便操作这段内存</p><p>语法：数据类型 变量名 &#x3D; 初始值;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量的定义</span></span><br><span class="line"><span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line">    <span class="comment">//注意：C++在创建变量时，必须给变量一个初始值，否则会报错</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>作用：用于记录程序中不可更改的数据<br>C++定义常量两种方式<br>1.#define宏常量：#define 常量名 常量值<br>通常在文件上方定义，表示一个常量<br>2.const修饰的变量 const 数据类型 常量名 &#x3D; 常量值<br>通常在变量定义前加关键字const，修饰该变量为常量，不可修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、const修饰变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>作用：关键字是C++中预先保留的单词（标识符）<br>在定义变量或者常量时候，不要用关键字<br>c++关键字如下：<br><img src="/img/guanjianzi.png"></img><br>提示：在给变量或者常量起名称时候，不要用C++得关键字，否则会产生歧义。</p><h3 id="标识符命名规则"><a href="#标识符命名规则" class="headerlink" title="标识符命名规则"></a>标识符命名规则</h3><p>作用：C++规定给标识符（变量、常量）命名时，有一套自己的规则<br>标识符不能是关键字<br>标识符只能由字母、数字、下划线组成<br>第一个字符必须为字母或下划线<br>标识符中字母区分大小写<br>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>作用：整型变量表示的是整数类型的数据</p><p>C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：<br><img src="/img/zhengxing.png"></img></p><h3 id="sizeof关键字"><a href="#sizeof关键字" class="headerlink" title="sizeof关键字"></a>sizeof关键字</h3><p>作用：利用sizeof关键字可以统计数据类型所占内存大小</p><p>语法： sizeof( 数据类型 &#x2F; 变量)<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//整型结论：short &lt; int &lt;= long &lt;= long long</span></span><br></pre></td></tr></table></figure><h3 id="实型（浮点型）"><a href="#实型（浮点型）" class="headerlink" title="实型（浮点型）"></a>实型（浮点型）</h3><p>作用：用于表示小数</p><p>浮点型变量分为两种：</p><p>1.单精度float<br>2.双精度double<br>两者的区别在于表示的有效数字范围不同。<br><img src="/img/fudian.png"></img><br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line"><span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>作用：字符型变量用于显示单个字符<br>语法：char ch &#x3D; ‘a’;<br>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号<br>注意2：单引号内只能有一个字符，不可以是字符串<br>C和C++中字符型变量只占用1个字节。<br>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line"><span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>作用：用于表示一些不能显示出来的ASCII字符</p><p>现阶段我们常用的转义字符有： \n \ \t<br><img src="/img/zhuanyi.png"></img><br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h3><p>作用：用于表示一串字符<br>两种风格<br>1.C风格字符串： char 变量名[] &#x3D; “字符串值”</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：C风格的字符串要用双引号括起来</p><p>2.C++风格字符串： string 变量名 &#x3D; “字符串值”<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：C++风格字符串，需要加入头文件#include<string></p><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><p>作用：布尔数据类型代表真或假的值</p><p>bool类型只有两个值：</p><p>  true — 真（本质是1）<br>  false — 假（本质是0）<br>bool类型占1个字节大小</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据的输入"><a href="#数据的输入" class="headerlink" title="数据的输入"></a>数据的输入</h3><p>作用：用于从键盘获取数据</p><p>关键字：cin</p><p>语法： cin &gt;&gt; 变量<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型输入</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型输入</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; d;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型输入</span></span><br><span class="line"><span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串型输入</span></span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型输入</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; flag;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>作用：用于执行代码的运算</p><p>本章我们主要讲解以下几类运算符：<br><img src="/img/yunsuanfu.png"></img></p><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>作用：用于处理四则运算</p><p>算术运算符包括以下符号：<br><img src="/img/suanshu.png"></img><br>示例1： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个小数可以相除</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line"><span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个小数不可以取模</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只有整型变量可以进行取模运算</span></span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置递增</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">++b;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前置递增先对变量进行++，再计算表达式，后置递增相反</span></span><br></pre></td></tr></table></figure><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>作用：用于将表达式的值赋给变量</p><p>赋值运算符包括以下几个符号：<br><img src="/img/fuzhi.png"></img><br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>作用：用于表达式的比较，并返回一个真值或假值</p><p>比较运算符有以下符号：<br><img src="/img/bijiao.png"></img><br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//C和C++ 语言的比较运算中， “真”用数字“1”来表示， “假”用数字“0”来表示。</span></span><br></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>作用：用于根据表达式的值返回真值或假值</p><p>逻辑运算符有以下符号：<br><img src="/img/luoji.png"></img><br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">```c++</span><br><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="程序流程结构"><a href="#程序流程结构" class="headerlink" title="程序流程结构"></a>程序流程结构</h2><p>C&#x2F;C++支持最基本的三种程序运行结构：顺序结构、选择结构、循环结构</p><p>顺序结构：程序按顺序执行，不发生跳转<br>选择结构：依据条件是否满足，有选择的执行相应功能<br>循环结构：依据条件是否满足，循环多次执行某段代码</p><h3 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>作用：执行满足条件的语句</p><p>if语句的三种形式</p><p>单行格式if语句</p><p>多行格式if语句</p><p>多条件的if语句</p><p>单行格式if语句：if(条件){ 条件满足执行的语句 }</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择结构-单行if语句</span></span><br><span class="line"><span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if语句</span></span><br><span class="line"><span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：if条件表达式后不要加分号</p><p> 多行格式if语句<br>if(条件){ 条件满足执行的语句 }else{ 条件不满足执行的语句 };</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 多条件的if语句<br>if(条件1){ 条件1满足执行的语句 }else if(条件2){条件2满足执行的语句}… else{ 都不满足执行的语句}<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套if语句：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><p>案例需求：</p><p>提示用户输入一个高考考试分数，根据分数做如下判断<br>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；<br>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>作用： 通过三目运算符实现简单的判断</p><p>语法：表达式1 ? 表达式2 ：表达式3</p><p>解释：</p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">c = a &gt; b ? a : b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p><h4 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h4><p>作用：执行多条件分支语句</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请给电影评分 </span></span><br><span class="line"><span class="comment">//10 ~ 9   经典   </span></span><br><span class="line"><span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line"><span class="comment">// 6 ~ 5   一般</span></span><br><span class="line"><span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意1：switch语句中表达式类型只能是整型或者字符型</p><p>注意2：case里如果没有break，那么程序会一直向下执行</p><p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p><h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><p>while循环语句<br>作用：满足循环条件，执行循环语句</p><p>语法： while(循环条件){ 循环语句 }</p><p>解释：只要循环条件的结果为真，就执行循环语句</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>do…while循环语句<br>作用： 满足循环条件，执行循环语句</p><p>语法： do{ 循环语句 } while(循环条件);</p><p>注意：与while的区别在于do…while会先执行一次循环语句，再判断循环条件</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：与while循环区别在于，do…while先执行一次循环语句，再判断循环条件<br>for循环语句<br>作用： 满足循环条件，执行循环语句</p><p>语法： for(起始表达式;条件表达式;末尾循环体) { 循环语句; }</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/xunhuan.png"></img><br>注意：for循环中的表达式，要用分号进行分隔</p><p>总结：while , do…while, for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p><p>跳转语句<br>break语句<br>作用: 用于跳出选择结构或者循环结构</p><p>break使用的时机：</p><p>出现在switch条件语句中，作用是终止case并跳出switch<br>出现在循环语句中，作用是跳出当前的循环语句<br>出现在嵌套循环中，跳出最近的内层循环语句<br>示例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//2、在循环语句中用break</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例3：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continue语句<br>作用：在循环语句中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：continue并没有使整个循环终止，而break会跳出循环</p><p>goto语句<br>作用：可以无条件跳转语句</p><p>语法： goto 标记;</p><p>解释：如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line">FLAG:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p><p>特点1：数组中的每个数据元素都是相同的数据类型</p><p>特点2：数组是由连续的内存位置组成的</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="一维数组定义方式"><a href="#一维数组定义方式" class="headerlink" title="一维数组定义方式"></a>一维数组定义方式</h4><p>一维数组定义的三种方式：</p><p>1.数据类型 数组名[ 数组长度 ];<br>2.数据类型 数组名[ 数组长度 ] &#x3D; { 值1，值2 …};<br>3.数据类型 数组名[ ] &#x3D; { 值1，值2 …};<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方式1</span></span><br><span class="line"><span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line"><span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用下标赋值</span></span><br><span class="line">score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用下标输出</span></span><br><span class="line">cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种定义方式</span></span><br><span class="line"><span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line"><span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line"><span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐个输出</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方式3</span></span><br><span class="line"><span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line"><span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p><p>总结2：数组中下标是从0开始索引</p><h4 id="一维数组数组名"><a href="#一维数组数组名" class="headerlink" title="一维数组数组名"></a>一维数组数组名</h4><p>一维数组名称的用途：</p><p>1.可以统计整个数组在内存中的长度<br>2.可以获取数组在内存中的首地址<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名用途</span></span><br><span class="line"><span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：数组名是常量，不可以赋值</p><p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p><p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>作用： 最常用的排序算法，对数组内元素进行排序</p><p>1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>2.对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。<br>3.重复以上的步骤，每次比较次数-1，直到不需要比较<br>示例： 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组就是在一维数组上，多加一个维度。</p><h4 id="二维数组定义方式"><a href="#二维数组定义方式" class="headerlink" title="二维数组定义方式"></a>二维数组定义方式</h4><p>二维数组定义的四种方式：</p><p>1.数据类型 数组名[ 行数 ][ 列数 ];<br>2.数据类型 数组名[ 行数 ][ 列数 ] &#x3D; { {数据1，数据2 } ，{数据3，数据4 } };<br>3.数据类型 数组名[ 行数 ][ 列数 ] &#x3D; { 数据1，数据2，数据3，数据4};<br>4.数据类型 数组名[ ][ 列数 ] &#x3D; { 数据1，数据2，数据3，数据4};<br>建议：以上4种定义方式，利用第二种更加直观，提高代码的可读性</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1  </span></span><br><span class="line"><span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//方式4 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p><h4 id="二维数组数组名"><a href="#二维数组数组名" class="headerlink" title="二维数组数组名"></a>二维数组数组名</h4><p>查看二维数组所占内存空间<br>获取二维数组首地址<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组数组名</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结1：二维数组名就是这个数组的首地址</p><p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>作用：将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>函数的定义一般主要有5个步骤：</p><p>1、返回值类型</p><p>2、函数名</p><p>3、参数表列</p><p>4、函数体语句</p><p>5、return 表达式</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值类型 ：一个函数可以返回一个值。在函数定义中<br>函数名：给函数起个名称<br>参数列表：使用该函数时，传入的数据<br>函数体语句：花括号内的代码，函数内需要执行的语句<br>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据<br>示例：定义一个加法函数，实现两个数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><p>功能：使用定义好的函数</p><p>语法： 函数名（参数）</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//调用add函数</span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>所谓值传递，就是函数调用时实参将数值传入给形参<br>值传递时，如果形参发生，并不会影响实参<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp = num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 值传递时，形参是修饰不了实参的</p><h3 id="常见形式"><a href="#常见形式" class="headerlink" title="常见形式"></a>常见形式</h3><p>常见的函数样式有4种</p><p>1.无参无返<br>2.有参无返<br>3.无参有返<br>4.有参有返<br>示例：</p><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><p>作用： 告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><p>函数的声明可以多次，但是函数的定义只能有一次<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数的分文件编写"><a href="#函数的分文件编写" class="headerlink" title="函数的分文件编写"></a>函数的分文件编写</h3><p>作用：**让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><p>1.创建后缀名为.h的头文件<br>2.创建后缀名为.cpp的源文件<br>3.在头文件中写函数的声明<br>4.在源文件中写函数的定义<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>指针的基本概念<br>  指针的作用： 可以通过指针间接访问内存</p><pre><code>内存编号是从0开始记录的，一般用十六进制数字表示可以利用指针变量保存地址</code></pre><h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p>指针变量定义语法： 数据类型 * 变量名；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指针的定义</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量赋值</span></span><br><span class="line">p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、指针的使用</span></span><br><span class="line"><span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针变量和普通变量的区别</p><p>普通变量存放的是数据,指针变量存放的是地址<br>指针变量可以通过” * “操作符，操作指针变量指向的内存空间，这个过程称为解引用<br>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p><p>总结2：利用指针可以记录地址</p><p>总结3：对指针变量解引用，可以操作指针指向的内存</p><h3 id="所占内存空间"><a href="#所占内存空间" class="headerlink" title="所占内存空间"></a>所占内存空间</h3><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：所有指针类型在32位操作系统下是4个字节</p><h3 id="空指针和野指针"><a href="#空指针和野指针" class="headerlink" title="空指针和野指针"></a>空指针和野指针</h3><p>空指针：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><p>示例1：空指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line"><span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问空指针报错 </span></span><br><span class="line"><span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>野指针：指针变量指向非法的内存空间</p><p>示例2：野指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line"><span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问野指针报错 </span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p><h3 id="cost修饰指针"><a href="#cost修饰指针" class="headerlink" title="cost修饰指针"></a>cost修饰指针</h3><p>const修饰指针有三种情况:</p><p>1.const修饰指针 — 常量指针<br>2.const修饰常量 — 指针常量<br>3.const即修饰指针，又修饰常量<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//*p1 = 100;  报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line"><span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量</p><h3 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h3><p>作用：利用指针访问数组中元素</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//利用指针遍历数组</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h3><p>作用： 利用指针作函数参数，可以修改实参的值</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b; </span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p><h3 id="指针-数组，函数"><a href="#指针-数组，函数" class="headerlink" title="指针,数组，函数"></a>指针,数组，函数</h3><p>案例描述：**封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><p>例如数组：int arr[10] &#x3D; { 4,3,6,9,1,2,10,8,7,5 };</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p><h3 id="定义和使用-1"><a href="#定义和使用-1" class="headerlink" title="定义和使用"></a>定义和使用</h3><p>语法：struct 结构体名 { 结构体成员列表 }；</p><p>通过结构体创建变量的方式有三种：</p><p>struct 结构体名 变量名<br>struct 结构体名 变量名 &#x3D; { 成员1值 ， 成员2值…}<br>定义结构体时顺便创建变量<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">18</span>;</span><br><span class="line">stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">stu3.age = <span class="number">18</span>;</span><br><span class="line">stu3.score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结1：定义结构体时的关键字是struct，不可省略</p><p>总结2：创建结构体变量时，关键字struct可以省略</p><p>总结3：结构体变量利用操作符 “.”访问成员</p><h3 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h3><p>作用：将自定义的结构体放入到数组中方便维护</p><p>语法： struct 结构体名 数组名[元素个数] &#x3D; { {} , {} , … {} }</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><p>作用： 通过指针访问结构体中的成员</p><p>利用操作符 -&gt; 可以通过结构体指针访问结构体属性<br>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line"></span><br><span class="line">p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p><h3 id="结构体嵌套结构体"><a href="#结构体嵌套结构体" class="headerlink" title="结构体嵌套结构体"></a>结构体嵌套结构体</h3><p>作用： 结构体中的成员可以是另一个结构体</p><p>例如：每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">string name;  <span class="comment">//教师姓名</span></span><br><span class="line"><span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">t1.id = <span class="number">10000</span>;</span><br><span class="line">t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">t1.stu.age = <span class="number">18</span>;</span><br><span class="line">t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p><h3 id="结构体作函数参数"><a href="#结构体作函数参数" class="headerlink" title="结构体作函数参数"></a>结构体作函数参数</h3><p>作用：将结构体作为参数向函数中传递</p><p>  传递方式有两种：</p><pre><code>1.值传递2.地址传递示例：</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu.age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printStudent</span>(stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p><h3 id="结构体中const使用场景"><a href="#结构体中const使用场景" class="headerlink" title="结构体中const使用场景"></a>结构体中const使用场景</h3><p>作用：用const来防止误操作</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
